#@+leo-ver=5-thin
#@+node:ekr.20170302123956.1: * @file ../doc/leoAttic.txt
# This is Leo's final resting place for dead code.
# New in Leo 6.7.5. The attic will contain only code retired in the present release.

#@@language python
#@@killbeautify
#@+all
#@+node:ekr.20220917052540.1: ** retire read-outline-only
#@+node:ekr.20031218072017.2839: *3* c_file.readOutlineOnly
@g.commander_command('read-outline-only')
def readOutlineOnly(self: Self, event: Event = None) -> None:
    """Open a Leo outline, but do not read any derived files."""
    c = self
    c.endEditing()
    fileName = g.app.gui.runOpenFileDialog(c,
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo *.leojs *.db"), ("All files", "*")],
        defaultextension=".leo")
    if not fileName:
        return
    try:
        # pylint: disable=assignment-from-no-return
        # Can't use 'with" because readOutlineOnly closes the file.
        theFile = open(fileName, 'r')
        g.chdir(fileName)
        c = g.app.newCommander(fileName)
        frame = c.frame
        frame.deiconify()
        frame.lift()
        c.fileCommands.readOutlineOnly(theFile, fileName)  # closes file.
    except Exception:
        g.es("can not open:", fileName)
#@+node:ekr.20031218072017.3030: *3* fc.readOutlineOnly
def readOutlineOnly(self, theFile: Any, fileName: str) -> VNode:
    c = self.c
    # Set c.openDirectory
    theDir = g.os_path_dirname(fileName)
    if theDir:
        c.openDirectory = c.frame.openDirectory = theDir
    v, ratio = self.getLeoFile(theFile, fileName, readAtFileNodesFlag=False)
    c.redraw()
    c.frame.deiconify()
    junk, junk, secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio, secondary_ratio)
    return v
#@+node:ekr.20230913131425.1: ** retire ctext importer & writer
#@+node:tbrown.20140801105909.47549: *3* ../plugins/importers/ctext.py
from __future__ import annotations
import re
from typing import TYPE_CHECKING
from leo.core import leoGlobals as g  # Required
from leo.plugins.importers.base_importer import Importer

if TYPE_CHECKING:
    from leo.core.leoCommands import Commands as Cmdr
    from leo.core.leoNodes import Position, VNode

@others

def do_import(c: Cmdr, parent: Position, s: str) -> None:
    """The importer callback for ctext."""
    CText_Importer(c).import_from_string(parent, s)

importer_dict = {
    '@auto': ['@auto-ctext'],
    'extensions': ['.ctext'],  # A made-up extension for unit tests.
    'func': do_import,
}
@language python
@tabwidth -4
#@+node:tbrown.20140801105909.47551: *4* class CText_Importer(Importer)
class CText_Importer(Importer):
    << ctext docstring >>

    language = 'plain'  # A reasonable default.

    @others
#@+node:ekr.20161130053507.1: *5* << ctext docstring >>
"""
Read/Write simple text files with hierarchy embedded in headlines::

    Leading text in root node of subtree

    Etc. etc.

    ### A level one node #####################################

    This would be the text in this level one node.

    And this.

    ### Another level one node ###############################

    Another one

    #### A level 2 node ######################################

    See what we did there - one more '#' - this is a subnode.

Leading / trailing whitespace may not be preserved.  '-' and '/'
are used in place of '#' for SQL and JavaScript.

"""
#@+node:tbrown.20140801105909.47553: *5* ctext_i.import_from_string
def import_from_string(self, parent: Position, s: str) -> None:
    """CText_Importer.import_from_string."""
    c = self.c
    root = parent.copy()
    ft = c.importCommands.fileType.lower()
    cchar = (
        '#' if g.unitTesting else
        '-' if ft == '.sql' else
        '/' if ft == '.js' else '#'
    )
    header_pat = re.compile(fr"^\s*({cchar}{{3,}})(.*?){cchar}*\s*$")
    lines_dict: dict[VNode, list[str]] = {root.v: []}
    parents: list[Position] = [root]
    for line in g.splitLines(s):
        m = header_pat.match(line)
        if m:
            level = len(m.group(1)) - 2
            assert level >= 1, m.group(1)
            parents = parents[:level]
            self.create_placeholders(level, lines_dict, parents)
            parent = parents[-1]
            child = parent.insertAsLastChild()
            child.h = m.group(2).strip()
            lines_dict[child.v] = []
            parents.append(child)
        else:
            parent = parents[-1]
            lines_dict[parent.v].append(line)

    for p in root.self_and_subtree():
        p.b = ''.join(lines_dict[p.v])

    # Importers should dirty neither nodes nor the outline.
    for p in root.self_and_subtree():
        p.clearDirty()
#@+node:tbrown.20140804103545.29975: *3* ../plugins/writers/ctext.py
@language python
@tabwidth -4
from leo.core import leoGlobals as g  # Required.
from leo.core.leoNodes import Position
import leo.plugins.writers.basewriter as basewriter
@others
writer_dict = {
    '@auto': ['@auto-ctext',],
    'class': CTextWriter,
}
@language python
@tabwidth -4
#@+node:tbrown.20140804103545.29977: *4* class CTextWriter(BaseWriter)
class CTextWriter(basewriter.BaseWriter):
    @others
#@+node:tbrown.20140804103545.29978: *5* put_node
def put_node(self, p: Position, level: int = 0) -> None:
    self.put(p.b.strip() + '\n\n')
    for child in p.children():
        txt = self.cchar * 3 + self.cchar * level + ' ' + child.h.strip() + ' '
        txt += self.cchar * max(0, 75 - len(txt))
        self.put(txt + '\n\n')
        self.put_node(child, level + 1)
#@+node:tbrown.20140804103545.29979: *5* write
def write(self, root: Position) -> None:

    h = root.h.lower()
    self.cchar = (
        '#' if g.unitTesting else
        '%' if h.startswith('.tex') else
        '-' if h.startswith('.sql') else
        '/' if h.startswith('.js') else '#'
    )
    self.put_node(root, 0)
#@+node:ekr.20220812144913.1: *3* class TestCTextWriter(BaseTestWriter)
class TestCTextWriter (BaseTestWriter):
    """Test cases for the ctext writer plugin."""
    @others
#@+node:ekr.20220812144243.1: *4* TestCTextWriter.test_1
def test_1(self):

    c, root = self.c, self.c.p
    child = root.insertAsLastChild()
    child.h = 'h'
    x = CTextWriter(c)
    x.write(root)
#@-all
#@@nosearch
#@-leo
