#@+leo-ver=5-thin
#@+node:ekr.20170302123956.1: * @file ../doc/leoAttic.txt
# This is Leo's final resting place for dead code.
# New in Leo 6.7.5. The attic will contain only code retired in the present release.

#@@language python
#@@killbeautify
#@+all
#@+node:ekr.20230913144248.1: ** retire g.SherlockTracer
# I am going to leave this class in the attic indefinitely.
# It might be useful as the base for other classes.
#@+node:ekr.20121128031949.12605: *3* class g.SherlockTracer
class SherlockTracer:
    """
    A stand-alone tracer class with many of Sherlock's features.

    This class should work in any environment containing the re, os and sys modules.

    The arguments in the pattern lists determine which functions get traced
    or which stats get printed. Each pattern starts with "+", "-", "+:" or
    "-:", followed by a regular expression::

    "+x"  Enables tracing (or stats) for all functions/methods whose name
          matches the regular expression x.
    "-x"  Disables tracing for functions/methods.
    "+:x" Enables tracing for all functions in the **file** whose name matches x.
    "-:x" Disables tracing for an entire file.

    Enabling and disabling depends on the order of arguments in the pattern
    list. Consider the arguments for the Rope trace::

    patterns=['+.*','+:.*',
        '-:.*\\lib\\.*','+:.*rope.*','-:.*leoGlobals.py',
        '-:.*worder.py','-:.*prefs.py','-:.*resources.py',])

    This enables tracing for everything, then disables tracing for all
    library modules, except for all rope modules. Finally, it disables the
    tracing for Rope's worder, prefs and resources modules.

    Being able to zero in on the code of interest can be a big help in
    studying other people's code. This is a non-invasive method: no tracing
    code needs to be inserted anywhere.

    Usage:

    g.SherlockTracer(patterns).run()
    """
    @others
#@+node:ekr.20121128031949.12602: *4* sherlock.__init__
def __init__(
    self,
    patterns: list[Any],
    indent: bool = True,
    show_args: bool = True,
    show_return: bool = True,
    verbose: bool = True,
) -> None:
    """SherlockTracer ctor."""
    self.bad_patterns: list[str] = []  # List of bad patterns.
    self.indent = indent  # True: indent calls and returns.
    self.contents_d: dict[str, list] = {}  # Keys are file names, values are file lines.
    self.n = 0  # The frame level on entry to run.
    self.stats: dict[str, dict] = {}  # Keys are full file names, values are dicts.
    self.patterns: list[Any] = None  # A list of regex patterns to match.
    self.pattern_stack: list[str] = []
    self.show_args = show_args  # True: show args for each function call.
    self.show_return = show_return  # True: show returns from each function.
    self.trace_lines = True  # True: trace lines in enabled functions.
    self.verbose = verbose  # True: print filename:func
    self.set_patterns(patterns)
    try:  # Don't assume g.app exists.
        from leo.core.leoQt import QtCore
        if QtCore:
            # pylint: disable=no-member
            QtCore.pyqtRemoveInputHook()
    except Exception:
        pass
#@+node:ekr.20140326100337.16844: *4* sherlock.__call__
def __call__(self, frame: Any, event: Any, arg: Any) -> Any:
    """Exists so that self.dispatch can return self."""
    return self.dispatch(frame, event, arg)
#@+node:ekr.20140326100337.16846: *4* sherlock.bad_pattern
def bad_pattern(self, pattern: Any) -> None:
    """Report a bad Sherlock pattern."""
    if pattern not in self.bad_patterns:
        self.bad_patterns.append(pattern)
        print(f"\nignoring bad pattern: {pattern}\n")
#@+node:ekr.20140326100337.16847: *4* sherlock.check_pattern
def check_pattern(self, pattern: str) -> bool:
    """Give an error and return False for an invalid pattern."""
    try:
        for prefix in ('+:', '-:', '+', '-'):
            if pattern.startswith(prefix):
                re.match(pattern[len(prefix) :], 'xyzzy')
                return True
        self.bad_pattern(pattern)
        return False
    except Exception:
        self.bad_pattern(pattern)
        return False
#@+node:ekr.20121128031949.12609: *4* sherlock.dispatch
def dispatch(self, frame: Any, event: Any, arg: Any) -> Any:
    """The dispatch method."""
    if event == 'call':
        self.do_call(frame, arg)
    elif event == 'return' and self.show_return:
        self.do_return(frame, arg)
    elif event == 'line' and self.trace_lines:
        self.do_line(frame, arg)
    # Queue the SherlockTracer instance again.
    return self
#@+node:ekr.20121128031949.12603: *4* sherlock.do_call & helper
def do_call(self, frame: Any, unused_arg: Any) -> None:
    """Trace through a function call."""
    frame1 = frame
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    function_name = code.co_name
    try:
        full_name = self.get_full_name(locals_, function_name)
    except Exception:
        full_name = function_name
    if not self.is_enabled(file_name, full_name, self.patterns):
        # 2020/09/09: Don't touch, for example, __ methods.
        return
    n = 0  # The number of callers of this def.
    while frame:
        frame = frame.f_back
        n += 1
    indent = ' ' * max(0, n - self.n) if self.indent else ''
    path = f"{os.path.basename(file_name):>20}" if self.verbose else ''
    leadin = '+' if self.show_return else ''
    args_list = self.get_args(frame1)
    if self.show_args and args_list:
        args_s = ','.join(args_list)
        args_s2 = f"({args_s})"
        if len(args_s2) > 100:
            print(f"{path}:{indent}{leadin}{full_name}")
            g.printObj(args_list, indent=len(indent) + 22)
        else:
            print(f"{path}:{indent}{leadin}{full_name}{args_s2}")
    else:
        print(f"{path}:{indent}{leadin}{full_name}")
    # Always update stats.
    d = self.stats.get(file_name, {})
    d[full_name] = 1 + d.get(full_name, 0)
    self.stats[file_name] = d
#@+node:ekr.20130111185820.10194: *5* sherlock.get_args
def get_args(self, frame: Any) -> list[str]:
    """Return a list of string "name=val" for each arg in the function call."""
    code = frame.f_code
    locals_ = frame.f_locals
    name = code.co_name
    n = code.co_argcount
    if code.co_flags & 4:
        n = n + 1
    if code.co_flags & 8:
        n = n + 1
    result = []
    for i in range(n):
        name = code.co_varnames[i]
        if name != 'self':
            arg = locals_.get(name, '*undefined*')
            if arg:
                if isinstance(arg, (list, tuple)):
                    val_s = ','.join([self.show(z) for z in arg if self.show(z)])
                    val = f"[{val_s}]"
                elif isinstance(arg, str):
                    val = arg
                else:
                    val = self.show(arg)
                if val:
                    result.append(f"{name}={val}")
    return result
#@+node:ekr.20140402060647.16845: *4* sherlock.do_line (not used)
bad_fns: list[str] = []

def do_line(self, frame: Any, arg: Any) -> None:
    """print each line of enabled functions."""
    if 1:
        return
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    full_name = self.get_full_name(locals_, name)
    if not self.is_enabled(file_name, full_name, self.patterns):
        return
    n = frame.f_lineno - 1  # Apparently, the first line is line 1.
    d = self.contents_d
    lines = d.get(file_name)
    if not lines:
        print(file_name)
        try:
            with open(file_name) as f:
                s = f.read()
        except Exception:
            if file_name not in self.bad_fns:
                self.bad_fns.append(file_name)
                print(f"open({file_name}) failed")
            return
        lines = g.splitLines(s)
        d[file_name] = lines
    line = lines[n].rstrip() if n < len(lines) else '<EOF>'
    if 0:
        print(f"{name:3} {line}")
    else:
        print(f"{g.shortFileName(file_name)} {n} {full_name} {line}")
#@+node:ekr.20130109154743.10172: *4* sherlock.do_return & helper
def do_return(self, frame: Any, arg: Any) -> None:  # Arg *is* used below.
    """Trace a return statement."""
    code = frame.f_code
    fn = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    self.full_name = self.get_full_name(locals_, name)
    if not self.is_enabled(fn, self.full_name, self.patterns):
        return
    n = 0
    while frame:
        frame = frame.f_back
        n += 1
    path = f"{os.path.basename(fn):>20}" if self.verbose else ''
    if name and name == '__init__':
        try:
            ret1 = locals_ and locals_.get('self', None)
            self.put_ret(ret1, n, path)
        except NameError:
            self.put_ret(f"<{ret1.__class__.__name__}>", n, path)
    else:
        self.put_ret(arg, n, path)
#@+node:ekr.20220605141445.1: *5* sherlock.put_ret
def put_ret(self, arg: Any, n: int, path: str) -> None:
    """Print arg, the value returned by a "return" statement."""
    indent = ' ' * max(0, n - self.n + 1) if self.indent else ''
    try:
        if isinstance(arg, types.GeneratorType):
            ret = '<generator>'
        elif isinstance(arg, (tuple, list)):
            ret_s = ','.join([self.show(z) for z in arg])
            if len(ret_s) > 40:
                g.printObj(arg, indent=len(indent))
                ret = ''
            else:
                ret = f"[{ret_s}]"
        elif arg:
            ret = self.show(arg)
            if len(ret) > 100:
                ret = f"\n    {ret}"
        else:
            ret = '' if arg is None else repr(arg)
        print(f"{path}:{indent}-{self.full_name} -> {ret}")
    except Exception:
        exctype, value = sys.exc_info()[:2]
        try:  # Be extra careful.
            arg_s = f"arg: {arg!r}"
        except Exception:
            arg_s = ''  # arg.__class__.__name__
        print(
            f"{path}:{indent}-{self.full_name} -> "
            f"{exctype.__name__}, {value} {arg_s}"
        )
#@+node:ekr.20121128111829.12185: *4* sherlock.fn_is_enabled
def fn_is_enabled(self, func: Any, patterns: list[str]) -> bool:
    """Return True if tracing for the given function is enabled."""
    if func in self.ignored_functions:
        return False

    def ignore_function() -> None:
        if func not in self.ignored_functions:
            self.ignored_functions.append(func)
            print(f"Ignore function: {func}")
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '<frozen>', '<genexpr>', '<listcomp>',
        # '<decorator-gen-.*>',
        'get\b',
        # String primitives.
        'append\b', 'split\b', 'join\b',
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    g.trace('=====', func)
    for z in table:
        if re.match(z, func):
            ignore_function()
            return False
    #
    # Legacy code.
    try:
        enabled, pattern = False, None
        for pattern in patterns:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], func):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], func):
                    enabled = False
        return enabled
    except Exception:
        self.bad_pattern(pattern)
        return False
#@+node:ekr.20130112093655.10195: *4* sherlock.get_full_name
def get_full_name(self, locals_: Any, name: str) -> str:
    """Return class_name::name if possible."""
    full_name = name
    try:
        user_self = locals_ and locals_.get('self', None)
        if user_self:
            full_name = user_self.__class__.__name__ + '::' + name
    except Exception:
        pass
    return full_name
#@+node:ekr.20121128111829.12183: *4* sherlock.is_enabled
ignored_files: list[str] = []  # List of files.
ignored_functions: list[str] = []  # List of files.

def is_enabled(
    self,
    file_name: str,
    function_name: str,
    patterns: list[str] = None,
) -> bool:
    """Return True if tracing for function_name in the given file is enabled."""
    #
    # New in Leo 6.3. Never trace through some files.
    if not os:
        return False  # Shutting down.
    base_name = os.path.basename(file_name)
    if base_name in self.ignored_files:
        return False

    def ignore_file() -> None:
        if base_name not in self.ignored_files:
            self.ignored_files.append(base_name)

    def ignore_function() -> None:
        if function_name not in self.ignored_functions:
            self.ignored_functions.append(function_name)

    if f"{os.sep}lib{os.sep}" in file_name:
        ignore_file()
        return False
    if base_name.startswith('<') and base_name.endswith('>'):
        ignore_file()
        return False
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '<frozen>', '<genexpr>', '<listcomp>',
        # '<decorator-gen-.*>',
        'get\b',
        # String primitives.
        'append\b', 'split\b', 'join\b',
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    for z in table:
        if re.match(z, function_name):
            ignore_function()
            return False
    #
    # Legacy code.
    enabled = False
    if patterns is None:
        patterns = self.patterns
    for pattern in patterns:
        try:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], file_name):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], file_name):
                    enabled = False
            elif pattern.startswith('+'):
                if re.match(pattern[1:], function_name):
                    enabled = True
            elif pattern.startswith('-'):
                if re.match(pattern[1:], function_name):
                    enabled = False
            else:
                self.bad_pattern(pattern)
        except Exception:
            self.bad_pattern(pattern)
    return enabled
#@+node:ekr.20121128111829.12182: *4* sherlock.print_stats
def print_stats(self, patterns: list[str] = None) -> None:
    """Print all accumulated statisitics."""
    print('\nSherlock statistics...')
    if not patterns:
        patterns = ['+.*', '+:.*',]
    for fn in sorted(self.stats.keys()):
        d = self.stats.get(fn)
        if self.fn_is_enabled(fn, patterns):
            result = sorted(d.keys())  # type:ignore
        else:
            result = [key for key in sorted(d.keys())  # type:ignore
                if self.is_enabled(fn, key, patterns)]
        if result:
            print('')
            fn = fn.replace('\\', '/')
            parts = fn.split('/')
            print('/'.join(parts[-2:]))
            for key in result:
                print(f"{d.get(key):4} {key}")
#@+node:ekr.20121128031949.12614: *4* sherlock.run
# Modified from pdb.Pdb.set_trace.

def run(self, frame: Any = None) -> None:
    """Trace from the given frame or the caller's frame."""
    print("SherlockTracer.run:patterns:\n%s" % '\n'.join(self.patterns))
    if frame is None:
        frame = sys._getframe().f_back
    # Compute self.n, the number of frames to ignore.
    self.n = 0
    while frame:
        frame = frame.f_back
        self.n += 1
    # Pass self to sys.settrace to give easy access to all methods.
    sys.settrace(self)
#@+node:ekr.20140322090829.16834: *4* sherlock.push & pop
def push(self, patterns: list[str]) -> None:
    """Push the old patterns and set the new."""
    self.pattern_stack.append(self.patterns)  # type:ignore
    self.set_patterns(patterns)
    print(f"SherlockTracer.push: {self.patterns}")

def pop(self) -> None:
    """Restore the pushed patterns."""
    if self.pattern_stack:
        self.patterns = self.pattern_stack.pop()  # type:ignore
        print(f"SherlockTracer.pop: {self.patterns}")
    else:
        print('SherlockTracer.pop: pattern stack underflow')
#@+node:ekr.20140326100337.16845: *4* sherlock.set_patterns
def set_patterns(self, patterns: list[str]) -> None:
    """Set the patterns in effect."""
    self.patterns = [z for z in patterns if self.check_pattern(z)]
#@+node:ekr.20140322090829.16831: *4* sherlock.show
def show(self, item: Any) -> str:
    """return the best representation of item."""
    if not item:
        return repr(item)
    if isinstance(item, dict):
        return 'dict'
    if isinstance(item, str):
        s = repr(item)
        if len(s) <= 20:
            return s
        return s[:17] + '...'
    s = repr(item)
    # A Hack for mypy:
    if s.startswith("<object object"):
        s = "_dummy"
    return s
#@+node:ekr.20121128093229.12616: *4* sherlock.stop
def stop(self) -> None:
    """Stop all tracing."""
    sys.settrace(None)
#@+node:ekr.20240322064529.1: ** retire .cmd scripts
#@+node:ekr.20240322064529.2: *3* beautify-leo.cmd
@language batch
@echo off
cd %~dp0..\..

echo beautify-leo

call py -m leo.core.leoAst --orange --verbose leo\core
call py -m leo.core.leoAst --orange --verbose leo\commands
call py -m leo.core.leoAst --orange --verbose leo\plugins
call py -m leo.core.leoAst --orange --verbose leo\modes
#@+node:ekr.20240322064529.3: *3* beautify-leo-force.cmd
@language batch
@echo off
cd %~dp0..\..

echo beautify-leo

call py -m leo.core.leoAst --orange --force --verbose leo\core
call py -m leo.core.leoAst --orange --force --verbose leo\commands

rem It's ok to beautify everything:

call py -m leo.core.leoAst --orange --verbose leo\plugins
call py -m leo.core.leoAst --orange --verbose leo\modes

rem call py -m leo.core.leoAst --orange --force --verbose leo\plugins\importers
rem call py -m leo.core.leoAst --orange --force --verbose leo\plugins\writers
#@+node:ekr.20240322064529.4: *3* blacken-leo.cmd
@language batch
@echo off
cd %~dp0..\..

rem not recommended!
echo black leo.core
call py -m black --skip-string-normalization leo\core
#@+node:ekr.20240322064529.5: *3* flake8-leo.cmd
@language batch
@echo off
cd %~dp0..\..

rem: See leo-editor/setup.cfg for defaults.

echo flake8-leo
py -m flake8 %*
#@+node:ekr.20240322064529.6: *3* full-test-leo.cmd
@language batch
@echo off
cls
cd %~dp0..\..

rem Run all of Leo's pre-commit tests.

call tbo.cmd --all --beautified --report --write
call python312 -m unittest
call ruff-leo.cmd
call mypy-leo.cmd
echo Done!
#@+node:ekr.20240322064529.7: *3* make-leo.cmd
@language batch
@echo off
cls
rem -a: write all files  (make clean)
cd %~dp0..\..
cd leo\doc\html

echo.
echo sphinx-build -a (make clean)
echo.
sphinx-build -M html . _build -a
#@+node:ekr.20240322064529.8: *3* mypy-leo.cmd
@language batch
@echo off
cd %~dp0..\..

rem See leo-editor/.mypy.ini for exclusions!
rem Always use the fast (official) version of mypy.

echo mypy-leo
py -m mypy --debug-cache leo %*
#@+node:ekr.20240322064529.9: *3* pylint-leo.cmd
@language batch
@echo off
cd %~dp0..\..

echo pylint-leo
time /T
call py -m pylint leo --extension-pkg-allow-list=PyQt6.QtCore,PyQt6.QtGui,PyQt6.QtWidgets %*
time /T
#@+node:ekr.20240322064529.10: *3* reindent-leo.cmd
@language batch
@echo off
cd %~dp0..\..

:: Save path to reindent.py to a file .leo\reindent-path.txt
call py %~dp0\find-reindent.py

set PATH_FILE=%USERPROFILE%\.leo\reindent-path.txt
set /P "REINDENT_PATH="< %PATH_FILE%

:: echo %REINDENT_PATH%

if "%REINDENT_PATH%"=="" goto no_reindent

echo reindent-leo

rem echo reindent leo/core
call py %REINDENT_PATH% -r leo\core
rem echo reindent leo/commands
call py %REINDENT_PATH% -r leo\commands
rem echo reindent leo/plugins/importers
call py %REINDENT_PATH% -r leo\plugins\importers
rem echo reindent leo/plugins/commands
call py %REINDENT_PATH% leo\plugins\qt_commands.py
call py %REINDENT_PATH% leo\plugins\qt_events.py
call py %REINDENT_PATH% leo\plugins\qt_frame.py
call py %REINDENT_PATH% leo\plugins\qt_gui.py
call py %REINDENT_PATH% leo\plugins\qt_idle_time.py
call py %REINDENT_PATH% leo\plugins\qt_text.py
call py %REINDENT_PATH% leo\plugins\qt_tree.py
rem echo reindent leo/plugins/writers
call py %REINDENT_PATH% -r leo\plugins\writers
rem echo reindent leo/unittests
call py %REINDENT_PATH% -r leo\unittests
rem echo reindent official plugins.
call py %REINDENT_PATH% leo\plugins\indented_languages.py
goto done

:no_reindent
echo Cannot find reindent.py, skipping reindentation

:done
#@+node:ekr.20240322064529.11: *3* test-leo.cmd
@language batch
@echo off
cd %~dp0..\..

call reindent-leo.cmd

echo test-leo
py -m unittest %*
#@+node:ekr.20240322064529.12: *3* test-one-leo.cmd
@language batch
@echo off
cls
cd %~dp0..\..

echo test-one-leo
call py -m unittest leo.unittests.core.test_leoGlobals.TestGlobals.test_g_handleScriptException
#@+node:ekr.20240322064529.13: *3* tbo.cmd
@language batch

@echo off
cls
cd %~dp0..\..

rem Use leoTokens.py to beautify all files.

IF [%1]==[-h] goto help
IF [%1]==[--help] goto help

:tbo:

echo tbo [%*]
call python312 -m leo.core.leoTokens leo\core %*
call python312 -m leo.core.leoTokens leo\commands %*
call python312 -m leo.core.leoTokens leo\plugins\importers %*
call python312 -m leo.core.leoTokens leo\plugins\writers %*
call python312 -m leo.core.leoTokens leo\modes %*

call python312 -m leo.core.leoTokens leo\unittests\core %*
call python312 -m leo.core.leoTokens leo\unittests\commands %*
call python312 -m leo.core.leoTokens leo\unittests\plugins %*
call python312 -m leo.core.leoTokens leo\unittests\misc_tests %*
goto done

:help:
call python312 -m leo.core.leoTokens  --help

:done:
#@+node:ekr.20240324061253.1: ** retire Qt5 plugins & files
#@+node:tbrown.20171028115144.3: *3* @@@file ../plugins/editpane/pandownview.py
<< pandownview imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115505.1: *4* << pandownview imports >>
"""Markdown view using Pandoc.

There could also be a more generic Pandoc view that handles more input
languages, but this just does markdown.
"""
from subprocess import Popen, PIPE

from leo.core import leoGlobals as g
assert g
# from leo.core.leoQt import QtCore, QtGui, QtWidgets, QtConst

# FIXME: for now, prefer the older WebKit over WebEngine.  WebEngine is
# probably superior, but needs --disable-web-security passed to the
# QApplication to load local images without a server.
try:
    from leo.plugins.editpane.webkitview import LEP_WebKitView as HtmlView
except ImportError:
    from leo.plugins.editpane.webengineview import LEP_WebEngineView as HtmlView

from leo.plugins.editpane.plaintextview import LEP_PlainTextView as TextView

#@+node:tbrown.20171028115505.2: *4* to_html
def to_html(text, from_='markdown'):
    """to_html - convert to HTML

    Args:
        text (str): markdown text to convert

    Returns:
        str: html
    """

    cmd = f"pandoc --smart --standalone --mathjax --from {from_} --to html"
    cmd = cmd.split()
    proc = Popen(cmd, stdin=PIPE, stdout=PIPE)
    out, err = proc.communicate(text)
    return out

# see if Pandoc's installed

try:
    to_html("test")
except:  # pylint: disable=raise-missing-from
    raise ImportError
#@+node:tbrown.20171028115505.3: *4* class LEP_PanDownView
class LEP_PanDownView(HtmlView):
    """LEP_MarkdownView -
    """
    lep_type = "MARKDOWN"
    lep_name = "PanDoc Markdown View"
    from_fmt = 'markdown'
    @others
#@+node:tbrown.20171028115505.4: *5* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super().__init__(c=c, lep=lep, *args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115505.5: *5* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setHtml(to_html(text, from_=self.from_fmt))
#@+node:tbrown.20171028115505.6: *5* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    # h = self.horizontalScrollBar().value()
    # v = self.verticalScrollBar().value()
    self.new_text(text)
    # self.horizontalScrollBar().setValue(h)
    # self.verticalScrollBar().setValue(v)
#@+node:tbrown.20171028115505.7: *4* class LEP_PanDownHtmlView
class LEP_PanDownHtmlView(TextView):
    """LEP_PanDownHtmlView - view the HTML for markdown from PanDoc
    """
    lep_type = "MARKDOWN-HTML"
    lep_name = "PanDoc Markdown Html View"
    from_fmt = 'markdown'
    @others
#@+node:tbrown.20171028115505.8: *5* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super().__init__(c=c, lep=lep, *args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115505.9: *5* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setPlainText(to_html(text, from_=self.from_fmt))
#@+node:tbrown.20171128074654.1: *4* class LEP_PanRstView
class LEP_PanRstView(LEP_PanDownView):
    """LEP_PanDownView -
    """
    lep_type = "RST"
    lep_name = "PanDoc rst View"
    from_fmt = 'rst'
#@+node:tbrown.20171128074707.1: *4* class LEP_PanRstHtmlView
class LEP_PanRstHtmlView(LEP_PanDownHtmlView):
    """LEP_PanDownHtmlView -
    """
    lep_type = "RST-HTML"
    lep_name = "PanDoc rst Html View"
    from_fmt = 'rst'
#@+node:tbrown.20171028115143.2: *3* @@@file ../plugins/editpane/webengineview.py
@nosearch

<< webengineview imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115459.1: *4* << webengineview imports >>
# EKR: Use QtWebKitWidgets instead of QtWebEngineWidgets
# TNB: No, there are two HTML viewers, this one must be QtWebEngineWidgets
#      it's ok if it fails to load
# pylint: disable=no-name-in-module
### from PyQt5 import QtWebEngineWidgets

### from leo.core.leoQt import QtWebKitWidgets
from leo.core import leoGlobals as g
assert g
#@+node:tbrown.20171028115459.2: *4* class LEP_WebEngineView
class LEP_WebEngineView(QtWebEngineWidgets.QWebEngineView):
    """LEP_PlainTextView - simplest possible LeoEditorPane viewer
    """
    lep_type = "HTML"
    lep_name = "Web Engine View"
    @others
#@+node:tbrown.20171028115459.3: *5* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super().__init__(*args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115459.4: *5* new_text
def new_text(self, text):
    """new_text - update for new text

    :param str text: new text
    """
    # see https://stackoverflow.com/questions/36609489,
    # widget grabs focus on .setHTML()
    self.setEnabled(False)
    self.setHtml(text)
    self.setEnabled(True)
#@+node:tbrown.20171028115459.5: *5* update_text
def update_text(self, text):
    """update_text - update for current text

    :param str text: current text
    """
    # h = self.horizontalScrollBar().value()
    # v = self.verticalScrollBar().value()
    self.new_text(text)
    # self.horizontalScrollBar().setValue(h)
    # self.verticalScrollBar().setValue(v)
#@+node:tbrown.20171028115143.1: *3* @@@file ../plugins/editpane/webkitview.py
<< webkitview imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115457.1: *4* << webkitview imports >> (webkitview.py)
import os
from leo.core import leoGlobals as g
assert g
from leo.core.leoQt import QtWebKit QtWebKitWidgets
if not QtWebKitWidgets or 'engine' in g.os_path_basename(
    QtWebKitWidgets.__file__).lower():
    # not loading webkit view, webengine masquerading as webkit
    raise ImportError
#@+node:tbrown.20171028115457.2: *4* _path_from_pos
def _path_from_pos(c, p):
    """_path_from_pos - get folder for position

    FIXME: should be in Leo core somewhere.

    Args:
        p (position): position

    Returns:
        str: path
    """
    p = p.copy()

    def atfile(p):
        word0 = p.h.split()[0]
        return (
            word0 in g.app.atFileNames | set(['@auto']) or
            word0.startswith('@auto-')
        )

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    while c.positionExists(p):
        if atfile(p):  # see if it's a @<file> node of some sort
            nodepath = p.h.split(None, 1)[-1]
            nodepath = g.os_path_join(path, nodepath)
            if not g.os_path_isdir(nodepath):  # remove filename
                nodepath = g.os_path_dirname(nodepath)
            if g.os_path_isdir(nodepath):  # append if it's a directory
                path = nodepath
            break
        p.moveToParent()

    return path
#@+node:tbrown.20171028115457.3: *4* class LEP_WebKitView
class LEP_WebKitView(QtWebKitWidgets.QWebView):
    """LEP_WebKitView - Web Kit View
    """
    lep_type = "HTML"
    lep_name = "Web Kit View"
    @others
#@+node:tbrown.20171028115457.4: *5* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super().__init__(*args, **kwargs)
    self.c = c
    self.lep = lep

    # enable inspector
    try:
        QtWebKit.QWebSettings.globalSettings().setAttribute(
          QtWebKit.QWebSettings.DeveloperExtrasEnabled, True)
    except AttributeError:
        # leoQt substitutes QtWebEngine for QtWebKit
        # if QtWebKit isn't available, causing this to fail
        pass
#@+node:tbrown.20171028115457.5: *5* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    owd = os.getcwd()
    path = _path_from_pos(self.c, self.c.p)
    g.es("FIXME: _path_from_pos() in WebKitView - not self.c.p")
    os.chdir(path)
    g.es(path)
    self.setHtml(text)
    os.chdir(owd)
#@+node:tbrown.20171028115457.6: *5* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    self.new_text(text)
#@+node:ville.20120604212857.4215: *3* @@@file ../plugins/notebook.py
""" QML Notebook

Edit several nodes at once, in a pannable "notebook" view.

Use <Alt-x>nb-<tab> to see the list of commands.
"""
from typing import Any
from leo.core import leoGlobals as g
from leo.core.leoQt import QtCore, QtGui  ### QtDeclarative
#
# Fail fast, right after all imports.
g.assertUi('qt')  # May raise g.UiTypeException, caught by the plugins manager.

controllers: dict[str, Any] = {}  # keys are c.hash(), values are NavControllers

@others
#@+node:ville.20120604212857.4219: *4* init
def init():
    """Return True if the plugin has loaded successfully."""
    ok = g.app.gui.guiName() == "qt"
    if ok:
        g.registerHandler('after-create-leo-frame', onCreate)
        g.plugin_signon(__name__)
    return ok
#@+node:ville.20120604212857.4231: *4* onCreate
def onCreate(tag, keys):
    """notebook.py onCreate"""
    global controllers
    c = keys.get('c')
    if c:
        h = c.hash()
        nb = controllers.get(h)
        if not nb:
            controllers[h] = NbController(c)
#@+node:ville.20120604212857.4227: *4* class ModelWrapper
class ModelWrapper:
    @others
#@+node:ville.20120604212857.4228: *5* __init__
def __init__(self, fieldlist):
    """Ctor for ModelWrapper class."""
    self.rolenames = rn = {}
    self.roleids = ri = {}
    for n, f in enumerate(fieldlist):
        rid = n + 100
        rn[rid] = f
        ri[f] = rid
    self.model = mo = QtGui.QStandardItemModel()
    try:
        mo.setRoleNames(rn)
    except AttributeError:
        pass
#@+node:ville.20120604212857.4229: *5* mkitem
def mkitem(self, d):
    """ dict with field->value """
    si = QtGui.QStandardItem()
    for k, v in d.items():
        rid = self.roleids[k]
        si.setData(v, rid)
    return si
#@+node:ville.20120604212857.4237: *4* class NbController
class NbController:
    @others
#@+node:ville.20120604212857.4241: *5* __init__ (NBController, notebook.py)
def __init__(self, c):
    """Ctor for NbController class."""
    self.c = c
    self.gnxcache = {}
    self.mw = ModelWrapper(["h", "b", "gnx", "level", "style"])
    try:
        # pylint: disable=import-error, no-name-in-module
        from PyQt5.QtQuick import QQuickView
        self.view = view = QQuickView()
    except Exception:  #1746.
        self.view = view = QtDeclarative.QDeclarativeView()
    ctx = view.rootContext()

    @g.command("nb-all")
    def nb_all_f(event):
        self.add_all_nodes()
        self.view.show()

    @g.command("nb-subtree")
    def nb_subtree_f(event):
        p = self.c.p
        self.add_subtree(p)
        self.view.show()

    ctx.setContextProperty("nodesModel", self.mw.model)
    path = g.os_path_join(g.computeLeoDir(), 'plugins', 'qmlnb', 'qml', 'leonbmain.qml')
    view.setSource(QtCore.QUrl(path))
    mode = view.SizeRootObjectToView
    view.setResizeMode(mode)
    # Display the user interface and allow the user to interact with it.
    view.hide()
    view.setGeometry(100, 100, 800, 600)
    c.dummy = view
#@+node:ville.20120604212857.4239: *5* add_all_nodes
def add_all_nodes(self):
    self.mw.model.clear()
    for p in self.c.all_positions():
        self.addNode(p)
#@+node:ville.20120604212857.4240: *5* add_subtree
def add_subtree(self, pos):
    self.mw.model.clear()
    for p in pos.self_and_subtree():
        self.addNode(p)

#@+node:ville.20120604212857.4238: *5* addNode
def addNode(self, p, styling=None):
    if styling is None:
        styling = {}
    v = p.v
    d = {
        "h": v.h,
        "b": v.b,
        "gnx": v.gnx,
        "level": p.level(),
    }
    d.update(styling)
    self.gnxcache[v.gnx] = v
    si = self.mw.mkitem(d)
    self.mw.model.appendRow(si)
#@+node:tbrown.20130813134319.11942: *3* @@@file ../plugins/richtext.py
@nosearch

<< docstring >>
<< imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20130813134319.14333: *4* << docstring >> (richtext.py)
"""
richtext.py - Rich text editing
===============================

This plugin allows you to use CKEditor__ to edit rich text
in Leo.  Text is stored as HTML in Leo nodes.

__ http://ckeditor.com/

``richtext.py`` provides these ``Alt-X`` commands (also available from
Plugins -> richtext menu):

  cke-text-close
    Close the rich text editor, unhide the regular editor.
  cke-text-open
    Open the rich text editor, hide the regular editor.
  cke-text-switch
    Switch between regular and rich text editor.
  cke-text-toggle-autosave
    Toggle autosaving of changes when you leave a node.
    Be careful not to convert plain text (e.g. source code) to rich
    text unintentionally.  As long as you make no edits, the original
    text will not be changed.

Unless autosaving is enabled, you must confirm saving of edits
each time you edit a node with the rich text editor.

``@rich`` in the headline or first few lines (1000 characters) of a node or its
ancestors will automatically open the rich text editor. ``@norich`` cancels this
action.  Manually opened editors are not affected.

``richtext.py`` uses these ``@settings``:

  @bool richtext_cke_autosave = False
    Set this to True for rich text edits to be saved automatically.

    *BE CAREFUL* - plain-text nodes will be converted to rich text
    without confirmation if you edit them in rich text mode when
    this is True.

  @data richtext_cke_config Configuration info. for CKEditor, see
    http://docs.ckeditor.com/#!/guide/dev_configuration the content of this node
    is the javascript object passed to ``CKEDITOR.replace()`` as it's second
    argument. The version supplied in LeoSettings.leo sets up a sensible
    toolbar. To enable *all* CKEditor toolbar features copy this setting to
    myLeoSettings.leo and remove the default content, i.e. make this node blank,
    then CKEditor will generate a toolbar with all available features.

To make a button to toggle the editor on and off, use::

    @button rich
      c.doCommandByName('cke-text-switch')

"""
#@+node:tbrown.20130813134319.14335: *4* << imports >> (richtext.py)
import time
from urllib.parse import unquote
from leo.core import leoGlobals as g
from leo.core.leoQt import QtCore, QtWidgets  ###, QtWebKitWidgets, QtWebKit
#
# Fail fast, right after all imports.
g.assertUi('qt')  # May raise g.UiTypeException, caught by the plugins manager.
#
# Alias.
### real_webkit = QtWebKit and 'engine' not in g.os_path_basename(QtWebKit.__file__).lower()
real_webkit = False
#@+node:tbrown.20130813134319.14337: *4* init (richtext.py)
def init():
    """Return True if the plugin has loaded successfully."""
    if not QtWebKit:
        return False
    name = g.app.gui.guiName()
    ok = name == 'qt'
    if ok:
        g.registerHandler('after-create-leo-frame', onCreate)
        g.registerHandler('select3', at_rich_check)
        g.plugin_signon(__name__)
    elif name != 'nullGui':
        print('richtext.py plugin not loading because gui is not Qt')
    return ok
#@+node:tbrown.20130813134319.5691: *4* class CKEEditor
class CKEEditor(QtWidgets.QWidget):  # type:ignore
    @others
#@+node:tbrown.20130813134319.7225: *5* __init__ & reloadSettings (CKEEditor)
def __init__(self, *args, **kwargs):

    self.c = kwargs['c']
    del kwargs['c']
    super().__init__(*args, **kwargs)
    # were we opened by an @ rich node? Calling code will set
    self.at_rich = False
    # are we being closed by leaving an @ rich node? Calling code will set
    self.at_rich_close = False
    # read settings.
    self.reloadSettings()
    # load HTML template
    template_path = g.os_path_join(g.computeLeoDir(), 'plugins', 'cke_template.html')
    self.template = open(template_path).read()
    path = g.os_path_join(g.computeLeoDir(), 'external', 'ckeditor')
    self.template = self.template.replace(
        '[CKEDITOR]', QtCore.QUrl.fromLocalFile(path).toString())
    # make widget containing QWebView
    self.setLayout(QtWidgets.QVBoxLayout())
    self.layout().setSpacing(0)
    self.layout().setContentsMargins(0, 0, 0, 0)
    ###
        # # enable inspector, if this really is QtWebKit
        # if real_webkit:
            # QtWebKit.QWebSettings.globalSettings().setAttribute(
                # QtWebKit.QWebSettings.DeveloperExtrasEnabled, True)
    self.webview = QtWebKitWidgets.QWebView()
    self.layout().addWidget(self.webview)
    g.registerHandler('select3', self.select_node)
    g.registerHandler('unselect1', self.unselect_node)
    # load current node
    self.select_node('', {'c': self.c, 'new_p': self.c.p})

def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    # read autosave preference
    if not hasattr(self.c, '_ckeeditor_autosave'):
        auto = self.c.config.getBool("richtext-cke-autosave") or False
        self.c._ckeeditor_autosave = auto
        if auto:
            g.es("NOTE: automatic saving of rich text edits")
    # load config
    self.config = self.c.config.getData("richtext_cke_config")
    if self.config:
        self.config = '\n'.join(self.config).strip()
#@+node:tbrown.20130813134319.7226: *5* select_node
def select_node(self, tag, kwargs):
    c = kwargs['c']
    if c != self.c:
        return

    p = kwargs['new_p']

    self.v = p.v  # to ensure unselect_node is working on the right node
    # currently (20130814) insert doesn't trigger unselect/select, but
    # even if it did, this would be safest

    data = self.template
    if p.b.startswith('<'):  # already rich text, probably
        content = p.b
        self.was_rich = True
    else:
        self.was_rich = p.b.strip() == ''
        # put anything except whitespace in a <pre/>
        content = "<pre>%s</pre>" % p.b if not self.was_rich else ''

    data = data.replace('[CONTENT]', content)

    # replace textarea with CKEditor, with or without config.
    if self.config:
        data = data.replace('[CONFIG]', ', ' + self.config)
    else:
        data = data.replace('[CONFIG]', '')

    # try and make the path for URL evaluation relative to the node's path
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    if p.h.startswith('@'):  # see if it's a @<file> node of some sort
        nodepath = p.h.split(None, 1)[-1]
        nodepath = g.os_path_join(path, nodepath)
        if not g.os_path_isdir(nodepath):  # remove filename
            nodepath = g.os_path_dirname(nodepath)
        if g.os_path_isdir(nodepath):  # append if it's a directory
            path = nodepath

    self.webview.setHtml(data, QtCore.QUrl.fromLocalFile(path + "/"))
#@+node:tbrown.20130813134319.7228: *5* unselect_node
def unselect_node(self, tag, kwargs):

    c = kwargs['c']
    if c != self.c:
        return None
    # read initial content and request and wait for final content
    frame = self.webview.page().mainFrame()
    ele = frame.findFirstElement("#initial")
    text = str(ele.toPlainText()).strip()
    if text == '[empty]':
        return None  # no edit
    frame.evaluateJavaScript('save_final();')
    ele = frame.findFirstElement("#final")
    for attempt in range(10):  # wait for up to 1 second
        new_text = str(ele.toPlainText()).strip()
        if new_text == '[empty]':
            time.sleep(0.1)
            continue
        break
    if new_text == '[empty]':
        print("Didn't get new text")
        return None
    text = unquote(str(text))
    new_text = unquote(str(new_text))
    if new_text != text:
        if self.c._ckeeditor_autosave:
            ans = 'yes'
        else:
            text = "Save edits?"
            if not self.was_rich:
                text += " *converting plain text to rich*"
            ans = g.app.gui.runAskYesNoCancelDialog(
                self.c,
                "Save edits?",
                text
            )
        if ans == 'yes':
            c.vnode2position(self.v).b = new_text
            c.redraw()  # but node has content marker still doesn't appear?
        elif ans == 'cancel':
            return 'STOP'
        else:
            pass  # discard edits
    return None
#@+node:tbrown.20130813134319.7229: *5* close
def close(self):
    if self.c and not self.at_rich_close:
        # save changes?
        self.unselect_node('', {'c': self.c, 'old_p': self.c.p})
    self.c = None
    g.unregisterHandler('select3', self.select_node)
    g.unregisterHandler('unselect1', self.unselect_node)
    return QtWidgets.QWidget.close(self)
#@+node:tbrown.20130813134319.5694: *4* class CKEPaneProvider
class CKEPaneProvider:
    ns_id = '_add_cke_pane'

    def __init__(self, c):
        self.c = c
        # Careful: we may be unit testing.
        if hasattr(c, 'free_layout'):
            splitter = c.free_layout.get_top_splitter()
            if splitter:
                splitter.register_provider(self)

    def ns_provides(self):
        return [('Rich text CKE editor', self.ns_id)]

    def ns_provide(self, id_):
        if id_ == self.ns_id:
            w = CKEEditor(c=self.c)
            return w
        return None

    def ns_provider_id(self):
        # used by register_provider() to unregister previously registered
        # providers of the same service
        return self.ns_id
#@+node:tbrown.20130813134319.14339: *4* onCreate
def onCreate(tag, key):

    c = key.get('c')

    CKEPaneProvider(c)
#@+node:tbrown.20130814090427.22458: *4* at_rich_check
def at_rich_check(tag, key):

    p = key.get('new_p')

    do = 'close'
    for nd in p.self_and_parents():
        if '@norich' in nd.h or '@norich' in nd.b[:1000]:
            do = 'close'
            break
        if '@rich' in nd.h or '@rich' in nd.b[:1000]:
            do = 'open'
            break

    if do == 'close':
        cmd_CloseEditor(key, at_rich=True)
    elif do == 'open':
        cmd_OpenEditor(key, at_rich=True)
#@+node:tbrown.20130813134319.5692: *4* @g.command('cke-text-open')
@g.command('cke-text-open')
def cmd_OpenEditor(event=None, at_rich=False):
    """Open the rich text editor, hide the regular editor."""
    c = event.get('c')
    splitter = c.free_layout.get_top_splitter()
    rte = splitter.find_child(CKEEditor, '')
    if rte:
        if not at_rich:
            g.es("CKE Editor appears to be open already")
        return
    body = splitter.find_child(QtWidgets.QWidget, 'bodyFrame')
    w = CKEEditor(c=c)
    w.at_rich = at_rich
    splitter = body.parent()
    splitter.replace_widget(body, w)
#@+node:tbrown.20130813134319.5693: *4* @g.command('cke-text-close')
@g.command('cke-text-close')
def cmd_CloseEditor(event=None, at_rich=False):
    """Close the rich text editor, unhide the regular editor."""
    c = event.get('c')
    splitter = c.free_layout.get_top_splitter()
    if not splitter:
        return
    rte = splitter.find_child(CKEEditor, '')
    if not rte:
        if not at_rich:
            g.es("No editor open")
        return
    if at_rich and not rte.at_rich:
        # don't close manually opened editor
        return
    body = splitter.get_provided('_leo_pane:bodyFrame')
    splitter = rte.parent()
    rte.at_rich_close = True
    splitter.replace_widget(rte, body)
#@+node:tbrown.20130813134319.7233: *4* @g.command('cke-text-switch')
@g.command('cke-text-switch')
def cmd_SwitchEditor(event):
    """Switch between regular and rich text editor."""
    c = event.get('c')
    splitter = c.free_layout.get_top_splitter()
    rte = splitter.find_child(CKEEditor, '')
    if not rte:
        cmd_OpenEditor(event)
    else:
        cmd_CloseEditor(event)
#@+node:tbrown.20130813134319.7231: *4* @g.command('cke-text-toggle-autosave')
@g.command('cke-text-toggle-autosave')
def cmd_ToggleAutosave(event):
    """
    Toggle autosaving of changes when you leave a node.

    Be careful not to convert plain text (e.g. source code) to rich
    text unintentionally.  As long as you make no edits, the original
    text will not be changed.
    """
    c = event.get('c')
    c._ckeeditor_autosave = not c._ckeeditor_autosave
    g.es("Rich text autosave " +
         ("ENABLED" if c._ckeeditor_autosave else "disabled"))
#@+node:ekr.20210407010914.1: *3* @@@file leoQt5.py
@nosearch

"""Import wrapper for pyQt5"""

# pylint: disable=import-error,no-name-in-module,unused-import

# Required imports
from PyQt5 import Qt
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5 import QtWidgets
from PyQt5.QtCore import QUrl
from PyQt5.QtCore import pyqtSignal as Signal
from PyQt5.QtGui import QCloseEvent
QtConst = QtCore.Qt
printsupport = Qt
qt_version = QtCore.QT_VERSION_STR
assert Qt and QtCore and QtGui and QtWidgets  # For pyflakes.
assert QCloseEvent and QUrl and Signal  # For pyflakes.
# Optional imports: Import this before creating the GUI.
try:
    # pylint: disable=ungrouped-imports
    from PyQt5 import QtWebEngineWidgets
    assert QtWebEngineWidgets
    has_WebEngineWidgets = True
except ImportError:
    # print('No Qt5 QtWebEngineWidgets')
    has_WebEngineWidgets = False
try:
    import PyQt5.QtDeclarative as QtDeclarative
except ImportError:
    QtDeclarative = None
try:
    import PyQt5.phonon as phonon
    phonon = phonon.Phonon
except ImportError:
    phonon = None
try:
    from PyQt5 import QtMultimedia
except ImportError:
    QtMultimedia = None
try:
    from PyQt5 import Qsci
except ImportError:
    Qsci = None
try:
    import PyQt5.QtSvg as QtSvg
except ImportError:
    QtSvg = None
try:
    from PyQt5 import uic
except ImportError:
    uic = None
try:
    from PyQt5 import QtWebKit
except ImportError:
    # 2016/07/13: Reinhard: Support pyqt 5.6...
    try:
        from PyQt5 import QtWebEngineCore as QtWebKit
    except ImportError:
        QtWebKit = None
try:
    import PyQt5.QtWebKitWidgets as QtWebKitWidgets
except ImportError:
    try:
        # https://groups.google.com/d/msg/leo-editor/J_wVIzqQzXg/KmXMxJSAAQAJ
        # Reinhard: Support pyqt 5.6...
        # used by viewrendered(2|3).py, bigdash.py, richtext.py.
        import PyQt5.QtWebEngineWidgets as QtWebKitWidgets  # type:ignore
        QtWebKitWidgets.QWebView = QtWebKitWidgets.QWebEngineView
        QtWebKit.QWebSettings = QtWebKitWidgets.QWebEngineSettings
        QtWebKitWidgets.QWebPage = QtWebKitWidgets.QWebEnginePage
    except ImportError:
        QtWebKitWidgets = None
#
# Default enum values. These apply to both Qt4 and Qt5
Alignment = QtCore.Qt
ButtonRole = QtWidgets.QMessageBox
ContextMenuPolicy = QtCore.Qt
ControlType = QtWidgets.QSizePolicy
DialogCode = QtWidgets.QDialog
DropAction = QtCore.Qt
EndEditHint = QtWidgets.QAbstractItemDelegate
FocusPolicy = QtCore.Qt
FocusReason = QtCore.Qt
Format = QtGui.QImage
GlobalColor = QtCore.Qt
Icon = QtWidgets.QMessageBox
Information = QtWidgets.QMessageBox
ItemFlag = QtCore.Qt  # 2347
ItemDataRole = QtCore.Qt  # 2347
Key = QtCore.Qt
KeyboardModifier = QtCore.Qt
Modifier = QtCore.Qt
MouseButton = QtCore.Qt
MoveMode = QtGui.QTextCursor
MoveOperation = QtGui.QTextCursor
Orientation = QtCore.Qt
Policy = QtWidgets.QSizePolicy
QAction = QtWidgets.QAction
QActionGroup = QtWidgets.QActionGroup
QStyle = QtWidgets.QStyle
ScrollBarPolicy = QtCore.Qt
SelectionBehavior = QtWidgets.QAbstractItemView
SelectionMode = QtWidgets.QAbstractItemView
Shadow = QtWidgets.QFrame
Shape = QtWidgets.QFrame
SizeAdjustPolicy = QtWidgets.QComboBox
SliderAction = QtWidgets.QAbstractSlider
SolidLine = QtCore.Qt.SolidLine
StandardButton = QtWidgets.QDialogButtonBox
StandardPixmap = QtWidgets.QStyle
Style = QtGui.QFont
TextInteractionFlag = QtCore.Qt
TextOption = QtGui.QTextOption
ToolBarArea = QtCore.Qt
Type = QtCore.QEvent
UnderlineStyle = QtGui.QTextCharFormat
if has_WebEngineWidgets:
    QWebEngineSettings = QtWebEngineWidgets.QWebEngineSettings
    WebEngineAttribute = QtWebEngineWidgets.QWebEngineSettings
else:
    QWebEngineSettings = None  # type:ignore
    WebEngineAttribute = None  # type:ignore

Weight = QtGui.QFont
WindowType = QtCore.Qt
WindowState = QtCore.Qt
WidgetAttribute = QtCore.Qt  # #2347
WrapMode = QtGui.QTextOption
#@+node:ekr.20210407011013.1: *3* @@@file leoQt6.py
@nosearch

"""
Import wrapper for pyQt6.

For Qt6, plugins are responsible for loading all optional modules.

"""

# pylint: disable=unused-import,no-name-in-module,c-extension-no-member,import-error

# Required imports
from typing import Any
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import Qt, QUrl
from PyQt6.QtGui import QAction, QActionGroup, QCloseEvent
from PyQt6.QtCore import pyqtSignal as Signal
#
# For pyflakes.
assert QtCore and QtGui and QtWidgets
assert QAction and QActionGroup
assert QCloseEvent
assert Qt and QUrl and Signal
#
# Standard abbreviations.
QtConst = Qt
qt_version = QtCore.QT_VERSION_STR
#
# Optional imports: #2005
# Must import this before creating the GUI
has_WebEngineWidgets = False
try:
    from PyQt6 import QtWebEngineWidgets
    from PyQt6 import QtWebEngineCore  # included with PyQt6-WebEngine
    assert QtWebEngineWidgets
    has_WebEngineWidgets = True
except ImportError:
    # 2866: This message pollutes leoserver.py.
        # print('No Qt6 QtWebEngineWidgets')
        # print('pip install PyQt6-WebEngine')
    pass

try:
    from PyQt6 import QtPrintSupport as printsupport
except Exception:
    printsupport = None

try:
    from PyQt6 import Qsci
except ImportError:
    Qsci = None
try:
    import PyQt6.QtSvg as QtSvg
except ImportError:
    QtSvg = None
try:
    from PyQt6 import uic
except ImportError:
    uic = None
#
# #2005: Do not import these by default. All of these *do* work.
if 0:
    try:
        from PyQt6 import QtDesigner
    except Exception:
        QtDesigner = None
    try:
        from PyQt6 import QtOpenGL
    except Exception:
        QtOpenGL = None
    try:
        from PyQt6 import QtMultimedia
    except ImportError:
        QtMultimedia = None
    try:
        from PyQt6 import QtNetwork
    except Exception:
        QtNetwork = None
#
# Enumerations, with (sheesh) variable spellings.
try:
    # New spellings (6.1+): mostly singular.
    Alignment = Qt.AlignmentFlag
    ControlType = QtWidgets.QSizePolicy.ControlType
    DropAction = Qt.DropAction
    ItemFlag = Qt.ItemFlag
    KeyboardModifier = Qt.KeyboardModifier
    Modifier = Qt.Modifier
    MouseButton = Qt.MouseButton
    Orientation = Qt.Orientation
    StandardButton = QtWidgets.QDialogButtonBox.StandardButton
    TextInteractionFlag = Qt.TextInteractionFlag
    ToolBarArea = Qt.ToolBarArea
    WidgetAttribute = Qt.WidgetAttribute  # #2347
    WindowType = Qt.WindowType
    WindowState = Qt.WindowState
except AttributeError:
    # Old spellings (6.0): mostly plural.
    Alignment = Qt.Alignment  # type:ignore
    ControlType = QtWidgets.QSizePolicy.ControlTypes  # type:ignore
    DropAction = Qt.DropActions  # type:ignore
    ItemFlag = Qt.ItemFlags  # type:ignore
    KeyboardModifier = Qt.KeyboardModifiers  # type:ignore
    Modifier = Qt.Modifiers  # type:ignore
    MouseButton = Qt.MouseButtons  # type:ignore
    Orientation = Qt.Orientations  # type:ignore
    StandardButton = QtWidgets.QDialog.StandardButtons  # type:ignore
    TextInteractionFlag = Qt.TextInteractionFlags  # type:ignore
    ToolBarArea = Qt.ToolBarAreas  # type:ignore
    WindowType = Qt.WindowFlags  # type:ignore
    WindowState = Qt.WindowStates  # type:ignore
#
# Other enums.
ButtonRole = QtWidgets.QMessageBox.ButtonRole
ContextMenuPolicy = Qt.ContextMenuPolicy
DialogCode = QtWidgets.QDialog.DialogCode
EndEditHint = QtWidgets.QAbstractItemDelegate.EndEditHint
FocusPolicy = Qt.FocusPolicy
FocusReason = Qt.FocusReason
Format = QtGui.QImage.Format
GlobalColor = Qt.GlobalColor
Icon = QtWidgets.QMessageBox.Icon
Information = Icon.Information
ItemDataRole = Qt.ItemDataRole  # 2347
Key = Qt.Key
MoveMode = QtGui.QTextCursor.MoveMode
MoveOperation = QtGui.QTextCursor.MoveOperation
Policy = QtWidgets.QSizePolicy.Policy
ScrollBarPolicy = Qt.ScrollBarPolicy
SelectionBehavior = QtWidgets.QAbstractItemView.SelectionBehavior
SelectionMode = QtWidgets.QAbstractItemView.SelectionMode
Shadow = QtWidgets.QFrame.Shadow
Shape = QtWidgets.QFrame.Shape
SizeAdjustPolicy = QtWidgets.QComboBox.SizeAdjustPolicy
SliderAction = QtWidgets.QAbstractSlider.SliderAction
SolidLine = Qt.PenStyle.SolidLine
StandardPixmap = QtWidgets.QStyle.StandardPixmap
Style = QtGui.QFont.Style
TextOption = QtGui.QTextOption
Type = QtCore.QEvent.Type
UnderlineStyle = QtGui.QTextCharFormat.UnderlineStyle
QWebEngineSettings: Any
WebEngineAttribute: Any
if has_WebEngineWidgets:
    QWebEngineSettings = QtWebEngineCore.QWebEngineSettings
    WebEngineAttribute = QWebEngineSettings.WebAttribute
else:
    QWebEngineSettings = None
    WebEngineAttribute = None

Weight = QtGui.QFont.Weight
WrapMode = QtGui.QTextOption.WrapMode
#@+node:ekr.20240417071834.1: ** prototype: leoTokens.rs
#@+node:ekr.20240417071834.2: *3* Cargo.toml
@language toml

[package]
name = "rust_beautifier"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
# fstrings = "0.2.3"
# regex = "1.10.4"
textwrap = "0.16.1"
rustpython-parser = {version = "0.3.1", features = ["full-lexer"]}
#@+node:ekr.20240417071834.3: *3* src/main.rs
mod leotokens;

fn main() {
    leotokens::entry();
}

@language rust
@tabwidth -4
#@+node:ekr.20240417071834.4: *3* src/leotokens.rs
<< leoTokens.rs: docstring >>
<< leoTokens.rs: global suppressions >>
<< leoTokens.rs: use statements >>

@others

@language rust
@tabwidth -4
@pagewidth 70
#@+node:ekr.20240417071834.5: *4* << leoTokens.rs: docstring >>
//! leoTokens.rs: A beautifier for Python that uses *only* tokens.
//!
//! Use Leo https://leo-editor.github.io/leo-editor/ to study this code!
//!
//! Without Leo, you will see special **sentinel comments** that create
//! Leo's outline structure. These comments have the form::
//!
//! `#@<comment-kind>:<user-id>.<timestamp>.<number>: <outline-level> <headline>`
//!
//! This file is part of Leo: https://leo-editor.github.io/leo-editor
//! Leo's copyright notice is based on the MIT license:
//! https://leo-editor.github.io/leo-editor/license.html
#@+node:ekr.20240417071834.6: *4* << leoTokens.rs: global suppressions >>
// All suppressions are local to a class or statement.

// #![allow(non_snake_case)]
// #![allow(unused_imports)]
// #![allow(unreachable_code)]
// #![allow(unused_mut)]
// #![allow(unused_variables)]
#@+node:ekr.20240417071834.7: *4* << leoTokens.rs: use statements >>
use rustpython_parser::{lexer::lex, Mode, Tok};

use std::env;
use std::fs;
use std::fmt;
// use std::time;

use textwrap;
#@+node:ekr.20240417071834.8: *4* Classes (leoTokens.rs)
@language rust
#@+node:ekr.20240417071834.9: *5* class Beautifier 
#[derive(Debug)]
pub struct Beautifier {
    args: Vec<String>,
    files_list: Vec<String>,
    input_list: Vec<InputTok>,
    output_list: Vec<String>,
}

///// Temporary.
#[allow(dead_code)]
#[allow(non_snake_case)]
impl Beautifier {
    @others
}
@language rust
#@+node:ekr.20240417071834.10: *6* Beautifier::add_input_token
// #[allow(dead_code)]
fn add_input_token (&mut self, kind: &str, value: &str) {
    //! Add one token to the output list.
    // println!("{:?}", kind);
    self.input_list.push(InputTok {
        kind: kind.to_string(),
        value: value.to_string(),
    });
}
@language rust
#@+node:ekr.20240417071834.11: *6* Beautifier::add_output_string
#[allow(unused_variables)]
fn add_output_string (&mut self, kind: &str, value: &str) {
    //! Add one string to the output list.
    self.output_list.push(value.to_string())
}
@language rust
#@+node:ekr.20240417071834.12: *6* Beautifier::beautify_all_files
pub fn beautify_all_files(&mut self) {
    for file_name in self.files_list.clone() {
        self.beautify_one_file(file_name);
    }
}
@language rust
#@+node:ekr.20240417071834.13: *6* Beautifier::beautify_one_file
fn beautify_one_file(&mut self, file_name: String) {
    // println!("beautifiy_one_file: {file_name}");
    self.output_list = Vec::new();
    // Read the file into contents (a String).
    let t1 = std::time::Instant::now();
    let contents = fs::read_to_string(file_name.clone())
        .expect("Error reading{file_name}");
    // print_type(&contents, "contents");
    let t2 = t1.elapsed();
    // Tokenize.
    let t3 = std::time::Instant::now();
    let n_tokens = self.tokenize_contents(contents);
    let t4 = t3.elapsed();
    // Report
    if self.enabled("--report") {
        println!(" file name: {file_name}");
        println!("      read: {:.2?}", t2);
        println!("  tokenize: {:.2?}", t4);
        println!("    tokens: {n_tokens}");
    }
    // Show tokens.
    << show output_list >>
}
@language rust
#@+node:ekr.20240417071834.14: *7* << show output_list >>
if false {  // --show-output
    self.show_output_list()
}
#@+node:ekr.20240417071834.15: *6* Beautifier::do_*
#@+node:ekr.20240417071834.16: *7* Handlers with values
#@+node:ekr.20240417071834.17: *8* do_Comment
fn do_Comment(&mut self, tok_value: &str) {
    // print!("{tok_value}");  // Correct.
    // print!("{value} ");  // Wrong!
    self.add_output_string("Comment", tok_value);
}
#@+node:ekr.20240417071834.18: *8* do_Complex
fn do_Complex(&mut self, tok_value: &str) {
    self.add_output_string("Complex", tok_value);
}
#@+node:ekr.20240417071834.19: *8* do_Float
fn do_Float(&mut self, tok_value: &str) {
    self.add_output_string("Float", tok_value);
}
#@+node:ekr.20240417071834.20: *8* do_Int
fn do_Int(&mut self, tok_value: &str) {
    self.add_output_string("Int", tok_value);
}
#@+node:ekr.20240417071834.21: *8* do_Name
fn do_Name(&mut self, tok_value: &str) {
    self.add_output_string("Name", tok_value);
}
#@+node:ekr.20240417071834.22: *8* do_String
fn do_String(&mut self, tok_value: &str) {
    // correct.
    // print!("{tok_value}");
    
    // incorrect.
        // let quote = if *triple_quoted {"'''"} else {"'"};
        // print!("{:?}:{quote}{value}{quote}", kind);

    self.add_output_string("String", tok_value);
}
#@+node:ekr.20240417071834.23: *7* Handlers using lws
#@+node:ekr.20240417071834.24: *8* do_Dedent
fn do_Dedent(&mut self, tok_value: &str) {
    self.add_output_string("Dedent", tok_value);
}
#@+node:ekr.20240417071834.25: *8* do_Indent
fn do_Indent(&mut self, tok_value: &str) {
    self.add_output_string("Indent", tok_value);
}
#@+node:ekr.20240417071834.26: *8* do_Newline
fn do_Newline(&mut self) {
    self.add_output_string("Indent", "\n");
}
#@+node:ekr.20240417071834.27: *8* do_NonLogicalNewline
fn do_NonLogicalNewline(&mut self) {
    self.add_output_string("Indent", "\n");
}
#@+node:ekr.20240417071834.28: *7* Handlers w/o values
#@+node:ekr.20240417071834.29: *8* do_Amper
fn do_Amper(&mut self) {
    self.add_output_string("Amper", "&");
}
#@+node:ekr.20240417071834.30: *8* do_AmperEqual
fn do_AmperEqual(&mut self) {
    self.add_output_string("AmperEqual", "&=");
}
#@+node:ekr.20240417071834.31: *8* do_And
fn do_And(&mut self) {
    self.add_output_string("And", "and");
}
#@+node:ekr.20240417071834.32: *8* do_As
fn do_As(&mut self) {
    self.add_output_string("As", "as");
}
#@+node:ekr.20240417071834.33: *8* do_Assert
fn do_Assert(&mut self) {
    self.add_output_string("Assert", "assert");
}
#@+node:ekr.20240417071834.34: *8* do_Async
fn do_Async(&mut self) {
    self.add_output_string("Async", "async");
}
#@+node:ekr.20240417071834.35: *8* do_At
fn do_At(&mut self) {
    self.add_output_string("At", "@");
}
#@+node:ekr.20240417071834.36: *8* do_AtEqual
fn do_AtEqual(&mut self) {
    self.add_output_string("AtEqual", "@=");
}
#@+node:ekr.20240417071834.37: *8* do_Await
fn do_Await(&mut self) {
    self.add_output_string("Await", "await");
}
#@+node:ekr.20240417071834.38: *8* do_Break
fn do_Break(&mut self) {
    self.add_output_string("Break", "break");
}
#@+node:ekr.20240417071834.39: *8* do_Case
fn do_Case(&mut self) {
    self.add_output_string("Case", "case");
}
#@+node:ekr.20240417071834.40: *8* do_CircumFlex
fn do_CircumFlex(&mut self) {
    self.add_output_string("CircumFlex", "^");
}
#@+node:ekr.20240417071834.41: *8* do_CircumflexEqual
fn do_CircumflexEqual(&mut self) {
    self.add_output_string("CircumflexEqual", "^=");
}
#@+node:ekr.20240417071834.42: *8* do_Class
fn do_Class(&mut self) {
    self.add_output_string("Class", "class");
}
#@+node:ekr.20240417071834.43: *8* do_Colon
fn do_Colon(&mut self) {
    self.add_output_string("Colon", ":");
}
#@+node:ekr.20240417071834.44: *8* do_ColonEqual
fn do_ColonEqual(&mut self) {
    self.add_output_string("ColonEqual", ":=");
}
#@+node:ekr.20240417071834.45: *8* do_Comma
fn do_Comma(&mut self) {
    self.add_output_string("Comma", ",");
}
#@+node:ekr.20240417071834.46: *8* do_Continue
fn do_Continue(&mut self) {
    self.add_output_string("Continue", "continue");
}
#@+node:ekr.20240417071834.47: *8* do_Def
fn do_Def(&mut self) {
    self.add_output_string("Def", "def");
}
#@+node:ekr.20240417071834.48: *8* do_Del
fn do_Del(&mut self) {
    self.add_output_string("Del", "del");
}
#@+node:ekr.20240417071834.49: *8* do_Dot
fn do_Dot(&mut self) {
    self.add_output_string("Dot", ".");
}
#@+node:ekr.20240417071834.50: *8* do_DoubleSlash
fn do_DoubleSlash(&mut self) {
    self.add_output_string("DoubleSlash", "//");
}
#@+node:ekr.20240417071834.51: *8* do_DoubleSlashEqual
fn do_DoubleSlashEqual(&mut self) {
    self.add_output_string("DoubleSlashEqual", "//=");
}
#@+node:ekr.20240417071834.52: *8* do_DoubleStar
fn do_DoubleStar(&mut self) {
    self.add_output_string("DoubleStar", "**");
}
#@+node:ekr.20240417071834.53: *8* do_DoubleStarEqual
fn do_DoubleStarEqual(&mut self) {
    self.add_output_string("DoubleStarEqual", "**=");
}
#@+node:ekr.20240417071834.54: *8* do_Elif
fn do_Elif(&mut self) {
    self.add_output_string("Elif", "elif");
}
#@+node:ekr.20240417071834.55: *8* do_Ellipsis
fn do_Ellipsis(&mut self) {
    self.add_output_string("Ellipsis", "...");
}
#@+node:ekr.20240417071834.56: *8* do_Else
fn do_Else(&mut self) {
    self.add_output_string("Else", "else");
}
#@+node:ekr.20240417071834.57: *8* do_EndOfFile
fn do_EndOfFile(&mut self) {
    self.add_output_string("EndOfFile", "EOF");
}
#@+node:ekr.20240417071834.58: *8* do_EqEqual
fn do_EqEqual(&mut self) {
    self.add_output_string("EqEqual", "==");
}
#@+node:ekr.20240417071834.59: *8* do_Equal
fn do_Equal(&mut self) {
    self.add_output_string("Equal", "=");
}
#@+node:ekr.20240417071834.60: *8* do_Except
fn do_Except(&mut self) {
    self.add_output_string("Except", "except");
}
#@+node:ekr.20240417071834.61: *8* do_False
fn do_False(&mut self) {
    self.add_output_string("False", "False");
}
#@+node:ekr.20240417071834.62: *8* do_Finally
fn do_Finally(&mut self) {
    self.add_output_string("Finally", "finally");
}
#@+node:ekr.20240417071834.63: *8* do_For
fn do_For(&mut self) {
    self.add_output_string("For", "for");
}
#@+node:ekr.20240417071834.64: *8* do_From
fn do_From(&mut self) {
    self.add_output_string("From", "from");
}
#@+node:ekr.20240417071834.65: *8* do_Global
fn do_Global(&mut self) {
    self.add_output_string("Global", "global");
}
#@+node:ekr.20240417071834.66: *8* do_Greater
fn do_Greater(&mut self) {
    self.add_output_string("Greater", ">");
}
#@+node:ekr.20240417071834.67: *8* do_GreaterEqual
fn do_GreaterEqual(&mut self) {
    self.add_output_string("GreaterEqual", ">-");
}
#@+node:ekr.20240417071834.68: *8* do_If
fn do_If(&mut self) {
    self.add_output_string("If", "if");
}
#@+node:ekr.20240417071834.69: *8* do_Import
fn do_Import(&mut self) {
    self.add_output_string("Import", "import");
}
#@+node:ekr.20240417071834.70: *8* do_In
fn do_In(&mut self) {
    self.add_output_string("In", "in");
}
#@+node:ekr.20240417071834.71: *8* do_Is
fn do_Is(&mut self) {
    self.add_output_string("Is", "is");
}
#@+node:ekr.20240417071834.72: *8* do_Lambda
fn do_Lambda(&mut self) {
    self.add_output_string("Lambda", "lambda");
}
#@+node:ekr.20240417071834.73: *8* do_Lbrace
fn do_Lbrace(&mut self) {
    self.add_output_string("Lbrace", "[");
}
#@+node:ekr.20240417071834.74: *8* do_LeftShift
fn do_LeftShift(&mut self) {
    self.add_output_string("LeftShift", "<<");
}
#@+node:ekr.20240417071834.75: *8* do_LeftShiftEqual
fn do_LeftShiftEqual(&mut self) {
    self.add_output_string("LeftShiftEqual", "<<=");
}
#@+node:ekr.20240417071834.76: *8* do_Less
fn do_Less(&mut self) {
    self.add_output_string("Less", "<");
}
#@+node:ekr.20240417071834.77: *8* do_LessEqual
fn do_LessEqual(&mut self) {
    self.add_output_string("LessEqual", "<=");
}
#@+node:ekr.20240417071834.78: *8* do_Lpar
fn do_Lpar(&mut self) {
    self.add_output_string("Lpar", "(");
}
#@+node:ekr.20240417071834.79: *8* do_Lsqb
fn do_Lsqb(&mut self) {
    self.add_output_string("Lsqb", "[");
}
#@+node:ekr.20240417071834.80: *8* do_Match
fn do_Match(&mut self) {
    self.add_output_string("Match", "match");
}
#@+node:ekr.20240417071834.81: *8* do_Minus
fn do_Minus(&mut self) {
    self.add_output_string("Minus", "-");
}
#@+node:ekr.20240417071834.82: *8* do_MinusEqual
fn do_MinusEqual(&mut self) {
    self.add_output_string("MinusEqual", "-=");
}
#@+node:ekr.20240417071834.83: *8* do_None
fn do_None(&mut self) {
    self.add_output_string("None", "None");
}
#@+node:ekr.20240417071834.84: *8* do_Nonlocal
fn do_Nonlocal(&mut self) {
    self.add_output_string("Nonlocal", "nonlocal");
}
#@+node:ekr.20240417071834.85: *8* do_Not
fn do_Not(&mut self) {
    self.add_output_string("Not", "not");
}
#@+node:ekr.20240417071834.86: *8* do_NotEqual
fn do_NotEqual(&mut self) {
    self.add_output_string("NotEqual", "!=");
}
#@+node:ekr.20240417071834.87: *8* do_Or
fn do_Or(&mut self) {
    self.add_output_string("Or", "or");
}
#@+node:ekr.20240417071834.88: *8* do_Pass
fn do_Pass(&mut self) {
    self.add_output_string("Pass", "pass");
}
#@+node:ekr.20240417071834.89: *8* do_Percent
fn do_Percent(&mut self) {
    self.add_output_string("Percent", "%");
}
#@+node:ekr.20240417071834.90: *8* do_PercentEqual
fn do_PercentEqual(&mut self) {
    self.add_output_string("PercentEqual", "%=");
}
#@+node:ekr.20240417071834.91: *8* do_Plus
fn do_Plus(&mut self) {
    self.add_output_string("Plus", "+");
}
#@+node:ekr.20240417071834.92: *8* do_PlusEqual
fn do_PlusEqual(&mut self) {
    self.add_output_string("PlusEqual", "+=");
}
#@+node:ekr.20240417071834.93: *8* do_Raise
fn do_Raise(&mut self) {
    self.add_output_string("Raise", "raise");
}
#@+node:ekr.20240417071834.94: *8* do_Rarrow
fn do_Rarrow(&mut self) {
    self.add_output_string("Rarrow", "->");
}
#@+node:ekr.20240417071834.95: *8* do_Rbrace
fn do_Rbrace(&mut self) {
    self.add_output_string("Rbrace", "]");
}
#@+node:ekr.20240417071834.96: *8* do_Return
fn do_Return(&mut self) {
    self.add_output_string("Return", "return");
}
#@+node:ekr.20240417071834.97: *8* do_RightShift
fn do_RightShift(&mut self) {
    self.add_output_string("RightShift", ">>");
}
#@+node:ekr.20240417071834.98: *8* do_RightShiftEqual
fn do_RightShiftEqual(&mut self) {
    self.add_output_string("RightShiftEqual", ">>=");
}
#@+node:ekr.20240417071834.99: *8* do_Rpar
fn do_Rpar(&mut self) {
    self.add_output_string("Rpar", ")");
}
#@+node:ekr.20240417071834.100: *8* do_Rsqb
fn do_Rsqb(&mut self) {
    self.add_output_string("Rsqb", "]");
}
#@+node:ekr.20240417071834.101: *8* do_Semi
fn do_Semi(&mut self) {
    self.add_output_string("Semi", ";");
}
#@+node:ekr.20240417071834.102: *8* do_Slash
fn do_Slash(&mut self) {
    self.add_output_string("Slash", "/");
}
#@+node:ekr.20240417071834.103: *8* do_SlashEqual
fn do_SlashEqual(&mut self) {
    self.add_output_string("SlashEqual", "/=");
}
#@+node:ekr.20240417071834.104: *8* do_Star
fn do_Star(&mut self) {
    self.add_output_string("Star", "*");
}
#@+node:ekr.20240417071834.105: *8* do_StarEqual
fn do_StarEqual(&mut self) {
    self.add_output_string("StarEqual", "*=");
}
#@+node:ekr.20240417071834.106: *8* do_StartExpression
fn do_StartExpression(&mut self) {
    // self.add_output_string("StartExpression", "");
}
#@+node:ekr.20240417071834.107: *8* do_StartInteractive
fn do_StartInteractive(&mut self) {
    // self.add_output_string("StartModule", "");
}
#@+node:ekr.20240417071834.108: *8* do_StarModule
fn do_StartModule(&mut self) {
    // self.add_output_string("StartModule", "");
    println!("do_StartModule");
}
#@+node:ekr.20240417071834.109: *8* do_Tilde
fn do_Tilde(&mut self) {
    self.add_output_string("Tilde", "~");
}
#@+node:ekr.20240417071834.110: *8* do_True
fn do_True(&mut self) {
    self.add_output_string("True", "True");
}
#@+node:ekr.20240417071834.111: *8* do_Try
fn do_Try(&mut self) {
    self.add_output_string("Try", "try");
}
#@+node:ekr.20240417071834.112: *8* do_Type
fn do_Type(&mut self) {
    self.add_output_string("Type", "type");
}
#@+node:ekr.20240417071834.113: *8* do_Vbar
fn do_Vbar(&mut self) {
    self.add_output_string("Vbar", "|");
}
#@+node:ekr.20240417071834.114: *8* do_VbarEqual
fn do_VbarEqual(&mut self) {
    self.add_output_string("VbarEqual", "|=");
}
#@+node:ekr.20240417071834.115: *8* do_While
fn do_While(&mut self) {
    self.add_output_string("While", "while");
}
#@+node:ekr.20240417071834.116: *8* do_With
fn do_With(&mut self) {
    self.add_output_string("With", "with");
}
#@+node:ekr.20240417071834.117: *8* do_Yield
fn do_Yield(&mut self) {
    self.add_output_string("Yield", "yield");
}
#@+node:ekr.20240417071834.118: *6* Beautifier::enabled
fn enabled(&self, arg: &str) -> bool {
    //! Beautifier::enabled: return true if the given command-line argument is enabled.
    //! Example:  x.enabled("--report");
    return self.args.contains(&arg.to_string());

}
@language rust
#@+node:ekr.20240417071834.119: *6* Beautifier::get_args
fn get_args(&mut self) {
    //! Beautifier::get_args: Set the args and files_list ivars.
    let args: Vec<String> = env::args().collect();
    let valid_args = vec![
        "--all", 
        "--beautified",
        "--diff",
        "-h", "--help",
        "--report",
        "--write",
    ];
    for (i, arg) in args.iter().enumerate() {
        if i > 0 {
            if valid_args.contains(&arg.as_str()) {
                self.args.push(arg.to_string())
            }
            else if 
                arg.as_str().starts_with("--") ||
                arg.as_str().starts_with("--")
            {
                println!("Ignoring invalid arg: {arg}");
            }
            else {
                println!("File: {arg}");
                self.files_list.push(arg.to_string());
            }
        }
    }
}
@language rust
#@+node:ekr.20240417071834.120: *6* Beautifier::make_input_list
fn make_input_list(&mut self, contents: &str) -> u32 {

    let mut count: u32 = 0;
    let results = lex(&contents, Mode::Module);  // An iterator yielding Option(Tok).
    for result in results {
        use Tok::*;
        count += 1;
        let token = result.ok().unwrap();
        let (ref tok_class, tok_range) = token;
        let tok_value = &contents[tok_range];

        // Variants names are necessary, but otherwise not used.
        #[allow(unused_variables)]
        let class_name = match tok_class {
            // Tokens with values...
            // Use tok_value for *all* values.
            Comment(value) => "Comment",  // No idea why parens are needed here.
            Complex { real, imag } => "Complex",
            Float { value } => "Float",
            Int { value } => "Int",
            Name { name } => "Name",
            Tok::String { value, kind, triple_quoted } => "String",
            
            // Common tokens...
            Class => "Class",
            Dedent => "Dedent",
            Def => "Def",
            Indent => "Indent",
            Newline => "Newline",
            NonLogicalNewline => "NonLogicalNewline",

            // All other tokens...
            Amper => "Amper",
            AmperEqual => "AmperEqual",
            And => "And",
            As => "As",
            Assert => "Assert",
            Async => "Async",
            At => "At",
            AtEqual => "AtEqual",
            Await => "Await",
            Break => "Break",
            Case => "Case",
            CircumFlex => "CircumFlex",
            CircumflexEqual => "CircumflexEqual",
            Colon => "Colon",
            ColonEqual => "ColonEqual",
            Comma => "Comma",
            Continue => "Continue",
            Del => "Del",
            Dot => "Dot",
            DoubleSlash => "DoubleSlash",
            DoubleSlashEqual => "DoubleSlashEqual",
            DoubleStar => "DoubleStar",
            DoubleStarEqual => "DoubleStarEqual",
            Elif => "Elif",
            Ellipsis => "Ellipsis",
            Else => "Else",
            EndOfFile => "EndOfFile",
            EqEqual => "EqEqual",
            Equal => "Equal",
            Except => "Except",
            False => "False",
            Finally => "Finally",
            For => "For",
            From => "From",
            Global => "Global",
            Greater => "Greater",
            GreaterEqual => "GreaterEqual",
            If => "If",
            Import => "Import",
            In => "In",
            Is => "Is",
            Lambda => "Lambda",
            Lbrace => "Lbrace",
            LeftShift => "LeftShift",
            LeftShiftEqual => "LeftShiftEqual",
            Less => "Less",
            LessEqual => "LessEqual",
            Lpar => "Lpar",
            Lsqb => "Lsqb",
            Match => "Match",
            Minus => "Minus",
            MinusEqual => "MinusEqual",
            None => "None",
            Nonlocal => "Nonlocal",
            Not => "Not",
            NotEqual => "NotEqual",
            Or => "Or",
            Pass => "Pass",
            Percent => "Percent",
            PercentEqual => "PercentEqual",
            Plus => "Plus",
            PlusEqual => "PlusEqual",
            Raise => "Raise",
            Rarrow => "Rarrow",
            Rbrace => "Rbrace",
            Return => "Return",
            RightShift => "RightShift",
            RightShiftEqual => "RightShiftEqual",
            Rpar => "Rpar",
            Rsqb => "Rsqb",
            Semi => "Semi",
            Slash => "Slash",
            SlashEqual => "SlashEqual",
            Star => "Star",
            StarEqual => "StarEqual",
            StartExpression => "StartExpression",
            StartInteractive => "StartInteractive",
            StartModule => "StartModule",
            Tilde => "Tilde",
            True => "True",
            Try => "Try",
            Type => "Type",
            Vbar => "Vbar",
            VbarEqual => "VbarEqual",
            While => "While",
            With => "With",
            Yield => "Yield",
        };
        self.add_input_token(class_name, tok_value);
    }
    return count;
}
@language rust
#@+node:ekr.20240417071834.121: *6* Beautifier::make_output_list
fn make_output_list(&mut self) {

    //// Prototype only.
    for input_token in &self.input_list.clone() {
        // println!("{:?}", input_token);
        self.add_output_string(input_token.kind.as_str(), input_token.value.as_str());
    }
}
@language rust
#@+node:ekr.20240417071834.123: *6* Beautifier::new
pub fn new() -> Beautifier {
    let mut x = Beautifier {
        args: Vec::new(),
        files_list: Vec::new(),
        input_list: Vec::new(),
        output_list: Vec::new(),
    };
    x.get_args();
    return x;
}
@language rust
#@+node:ekr.20240417071834.124: *6* Beautifier::show_args
fn show_args (&self) {
    println!("Command-line arguments...");
    for (i, arg) in self.args.iter().enumerate() {
        if i > 0 {
            println!("  {arg}");
        }
    }
    for file_arg in self.files_list.iter() {
        println!("  {file_arg}");
    }
}
@language rust
#@+node:ekr.20240417071834.125: *6* Beautifier::show_help
fn show_help (&self) {
    //! Beautifier::show_help: print the help messages.
    println!("{}", textwrap::dedent("
        Beautify or diff files.

        -h --help:      Print this help message and exit.
        --all:          Beautify all files, even unchanged files.
        --beautified:   Report beautified files individually, even if not written.
        --diff:         Show diffs instead of changing files.
        --report:       Print summary report.
        --write:        Write beautifed files (dry-run mode otherwise).
    "));
}
@language rust
#@+node:ekr.20240417071834.126: *6* Beautifier::show_output_list
fn show_output_list (&self) {
    println!("\nOutput list...");
    for (i, arg) in self.output_list.iter().enumerate() {
        if i > 0 {
            print!("{:?}", arg);
        }
    }
}
@language rust
#@+node:ekr.20240417071834.127: *6* Beautifier::tokenize_contents
fn tokenize_contents(&mut self, contents: String ) -> u32 {

    let count = self.make_input_list(&contents);
    
    // Simulate iterating the input list twice.
    for _z in &self.input_list.clone() {
    }
    for _z in &self.input_list.clone() {
    }

    // Simulate writing strings to the output list.
    // self.make_output_list();
    for _z in &self.input_list.clone() {
    }
    return count;
}
@language rust
#@+node:ekr.20240417071834.128: *5* class InputTok
// Only Clone is valid for String.
#[derive(Clone)]
struct InputTok {
    kind: String,
    value: String,
}

impl fmt::Debug for InputTok {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let kind_s = format!("{:?}", self.kind);
        let mut value = self.value.to_string();
        if true {
            return write!(f, "{value} ");
        }
        else {  // Debug format.
            value.truncate(60);
            // repr format is not useful.
            // let value_s = format!("{:?}", value);
            let value_s = format!("{}", value);
            return write!(f, "InputTok: {kind_s:>10}: {value_s}");
        }
    }
}
@language rust
#@+node:ekr.20240417071834.130: *4* pub fn entry & helpers
pub fn entry() {

    if false {
        tokenize();
        return;
    }
    // Main line of beautifier.
    let mut x = Beautifier::new();
    if x.enabled("--help") || x.enabled("-h") {
        x.show_help();
        return;
    }
    x.show_args();
    x.beautify_all_files();
}
@language rust
#@+node:ekr.20240417071834.131: *5* fn tokenize
fn tokenize() {
    << tokenize: define contents >>
    println!("fn tokenize");
    println!("\nSource:\n{contents}");

    for debug in [true, false].iter() {

        println!("{}", if *debug {"Tokens..."} else {"\nBeautified:"});

        let results = lex(contents, Mode::Module);  // An iterator yielding Option(Tok).
        let mut count = 0;
        let mut lws = String::new();
        for (i, result) in results.enumerate() {
            use Tok::*;
            let token = result.ok().unwrap();
            let (ref tok_class, tok_range) = token;
            let tok_value = &contents[tok_range];

            if *debug {
                let s = format!("{tok_class}");
                print!("\nToken: {s:20} {:?}", tok_value);
            }
            else {
                // Comment(value), Name(name)
                #[allow(unused_variables)]
                match tok_class {
                    Comment(value) => {
                        // print!("{value} ");  // Wrong!
                        print!("{tok_value}");
                    },
                    Dedent => {
                        lws.pop();
                        lws.pop();
                        print!("{lws}");
                    },
                    Def => {
                        print!("{tok_value} ");
                    },
                    Indent => {
                        lws.push_str("    ");
                        print!("{lws}");
                    },
                    Name {name} => {
                        print!("{tok_value} ");
                    },
                    Newline => {
                        print!("{tok_value}");
                        print!("{lws}");
                        if false {  // old
                            println!("");
                            print!("{lws}");
                        }
                    },
                    NonLogicalNewline => {
                        println!("");
                        print!("{lws}");
                    },
                    Return => {
                        print!("{tok_value} ");
                    },
                    Tok::String {value, kind, triple_quoted} => {
                        // correct.
                        print!("{tok_value}");
                        if false {  // incorrect.
                            let quote = if *triple_quoted {"'''"} else {"'"};
                            print!("{:?}:{quote}{value}{quote}", kind);
                        }
                    },
                    _ => {
                        print!("{tok_value}");
                        if false {
                            // to_string quotes values!
                            let s = tok_class.to_string().replace("'", "");
                            print!("{s}");
                        }
                    },
                }
            }
            count = i
        }
        if *debug {
            println!("\n{count} tokens")
        }
    }
}
#@+node:ekr.20240417071834.132: *6* << tokenize: define contents >>
let contents = r#"
def test():
# Comment 1.
print('abc')
# Comment 2.
"#;

// print("xyz")
// print(rf'pdb')
// print(fr'pdb2')
// return bool(i & 1)
#@+node:ekr.20240417071834.133: *4* fn print_type & type_of
#[allow(dead_code)]
fn print_type<T>(_: &T, tag: &str) {
    println!("{tag} type: {}", std::any::type_name::<T>())
}
@language rust
#@-all
#@@nosearch
#@-leo
