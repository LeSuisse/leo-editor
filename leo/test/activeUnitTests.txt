#@+leo-ver=5-thin
#@+node:edward.20160314170027.56: * @file activeUnitTests.txt
# All the following should pass when run locally (Alt-4).
#@@language python
#@+all
#@+node:ekr.20190608143232.1: ** commands/checkerCommands.py
#@+node:ekr.20190608071309.1: *3* @test regex for pylint
import re
import leo.commands.checkerCommands as checkerCommands
x = checkerCommands.PylintCommand(c)
pattern = re.compile(x.link_pattern)
table = (
    r'c:\test\pylint_links_test2.py:5:4: R1705: Unnecessary "else" after "return" (no-else-return)',
    r'c:\test\pylint_links_test.py:6:3: C1801: Do not use `len(SEQUENCE)` to determine if a sequence is empty (len-as-condition)',
    # A particularly good test, because it has two parenthesized expressions.
)
for message in table:
    # Windows style file names.
    m = pattern.match(message)
    assert m, message
    # Linux style file names.
    message = message.replace('\\', '/')
    m = pattern.match(message)
    assert m, message
#@+node:ekr.20100131171342.5506: ** leoApp
#@+node:ekr.20100131171342.5507: *3* @test consistency of leoApp tables
@
language_delims_dict 
    # Keys are languages, values are 1,2 or 3-tuples of delims. 
language_extension_dict
    # Keys are languages, values are extensions.
extension_dict = {
    # Keys are extensions, values are languages.
@c

delims_d    = g.app.language_delims_dict
lang_d      = g.app.language_extension_dict
ext_d       = g.app.extension_dict

for lang in lang_d:
    ext = lang_d.get(lang)
    assert lang in delims_d,'fail 1: %s' % lang
    assert ext in ext_d,'fail 2: %s' % ext
for ext in ext_d:
    lang = ext_d.get(ext)
    assert lang in lang_d,'fail 3: %s' % lang
#@+node:ekr.20100131180007.5417: *3* @test lm.openAnyLeoFile
import zipfile
lm = g.app.loadManager

# Create a zip file for testing.
s = 'this is a test file'
testDir = g.os_path_join(g.app.loadDir,'..','test')
assert g.os_path_exists(testDir)
path = g.os_path_finalize_join(testDir,'testzip.zip')
theFile = zipfile.ZipFile(path,'w')
theFile.writestr('leo-zip-file',s)
theFile.close()

# Open the file, and use read (with no args) to get the contents.
theFile = lm.openAnyLeoFile(path)
assert theFile
s2 = theFile.read()
assert s == s2,'s:  %s\ns2: %s' % (repr(s),repr(s2))
#@+node:ekr.20100211110729.5389: *3* @test rfm.writeRecentFilesFileHelper
@first # -*- coding: utf-8 -*-
#
# On Windows, this works with or without the following line in sitecustomize.py
    # sys.setdefaultencoding('utf-8')
import os
fn ='ффф.leo'
g.app.recentFilesManager.writeRecentFilesFileHelper(fn)
assert g.os_path_exists(fn),'fail 1'
os.remove(fn)
assert not g.os_path_exists(fn),'fail 1'
#@+node:ekr.20150521123343.1: ** leoBeautify
# These tests are now in leoAst.py.
#@+node:ekr.20111104171708.3843: *3* @test leoBeautify.CPrettyPrinter
import leo.core.leoBeautify as leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)

if 1: # test of indent.
    # import os ; os.system('cls')
    cpp.indent(p2)
if 0: # test of tokenize.
    aList = cpp.tokenize(p2.b)
    assert(p2.b == ''.join(aList))
#@+node:ekr.20111104171708.3844: *4* c tokenize test
@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos->can_break;
        }

        parser_state_tos->last_saw_nl = false;
        parser_state_tos->can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col > 0) &&
            (buf_break != NULL) &&
            ( ( (parser_state_tos->last_token == ident) &&
                (type_code != comma) &&
                (type_code != semicolon) &&
                (type_code != newline) &&
                (type_code != form_feed) &&
                (type_code != rparen) &&
                (type_code != struct_delim)) ||
              ( (parser_state_tos->last_token == rparen) &&
                (type_code != comma) &&
                (type_code != rparen) ) ) &&
            (output_line_length () > settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp > 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos->procname[0] != '\0') &&
                  parser_state_tos->in_parameter_declaration) ||
                 (parser_state_tos->classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&type_code, &force_nl, &flushed_nl, &last_else, &is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &paren_target);
            }

            if (parser_state_tos->tos > 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines > 0 && code_lines > 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            if (force_nl &&
                (type_code != semicolon) &&
                ( (type_code != lbrace) ||
                  (!parser_state_tos->in_decl && !settings.btype_2) ||
                  (parser_state_tos->in_decl && !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos->last_token == rbrace)))
            {
                if (settings.verbose && !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &paren_target);
                parser_state_tos->want_blank = false;
                force_nl = false;
            }

            parser_state_tos->in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos->want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &&
                 (type_code != cplus_comment) &&
                 !(settings.break_function_decl_args &&
                   (parser_state_tos->last_token == comma)) &&
                 !( (parser_state_tos->last_token == comma) &&
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &scase, &force_nl, &sp_sw, &flushed_nl,
                         &hd_type, &dec_ind, &last_token_ends_sp, &file_exit_value,
                         can_break, &last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            parser_state_tos->last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col > 0) && (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) && (scase || (squest <= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) && (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &&
                 (output_line_length () > settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
#@+node:ekr.20110608135658.3377: ** leoChapters
#@+node:ekr.20110608162543.3363: *3* @test chapter-create/remove & undo
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create/remove commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    cc.selectChapterByName('aaa',chaptersNode)
    cc.removeChapterByName('aaa')
    c.undoer.undo()
    assert cc.findChapterNode('aaa')
    cc.selectChapterByName('main',collapse=True)
else:
    self.skipTest('Can not be run locally')
#@+node:ekr.20110608162543.3365: *3* @test chapter-rename & undo
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create/remove commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    try:
        cc.selectChapterByName('aaa',chaptersNode)
        cc.renameChapterByName('bbb')
        cc.selectChapterByName('bbb',chaptersNode)
        cc.renameChapterByName('aaa')
        assert cc.findChapterNode('aaa'),'after undo'
    finally:
        cc.selectChapterByName('main',collapse=True)
else:
    self.skipTest('Can not be run locally')
#@+node:ekr.20110608181936.3368: *3* @test chapter-move/clone/copy-node-to
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('move/clone/copy commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode,'fail 0'
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    table = (
        ('node a',cc.moveNodeToChapterHelper),
        ('node b',cc.copyNodeToChapterHelper),
        ('node c',cc.cloneNodeToChapterHelper),
    )
    # Initialze 
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    for h,unused_f in table:
        p2 = p.insertAsLastChild()
        p2.h = h
        p2.b = '# %s' % h
    try:
        cc.selectChapterByName('aaa')
        for h,f in table:
            p2 = g.findNodeInTree(c,p,h)
            assert p2,'fail 1'
            c.selectPosition(p2) # All helpers work on c.p.
            f('aaa')
            assert g.findNodeInTree(c,chapterNode,h),(
                'fail 2', chapterNode.h, h, f.__name__)
        assert not g.findNodeInTree(c,p,'node a')
        assert g.findNodeInTree(c,p,'node b')
        assert g.findNodeInTree(c,p,'node c')
    finally:
        if 1: # Restore the tree so activeUnitTests.txt does not change.
            while p.hasChildren():
                p.firstChild().doDelete(newNode=None)
            for h,f in table:
                p3 = g.findNodeInTree(c,chapterNode,h)
                if p3: p3.doDelete()
        cc.selectChapterByName('main',collapse=True)
        c.redraw()
else:
    self.skipTest('Can not be run locally')
#@+node:ekr.20160402043006.1: *4* node a
# node a
#@+node:ekr.20160402043006.2: *4* node b
# node b
#@+node:ekr.20160402043006.3: *4* node c
# node c
#@+node:ekr.20080503132221.1: *3* @test chapter-create-from-node
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create-from-node no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    root = p.copy()
    # Init the children
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    child = p.insertAsNthChild(0)
    # c.setHeadString(child,'child') # Force the headline to update.
    child.h = 'child'
    child.b = '# child'
    # Kill the chapter so the test will not fail if run twice.
    chapter = cc.chaptersDict.get('new-chapter')
    if chapter:
        cc.removeChapterByName('new-chapter')
    try:
        c.selectPosition(child)
        c.chapterController.createChapterByName(
            'new-chapter',child,'Create Chapter From Node')
        if 0:
            c.undoer.undo()
            c.undoer.redo()
            c.undoer.undo()
            c.undoer.redo()
            c.undoer.undo() # Don't pollute future unit tests.
        else:
            c.redraw_now() # Required.
            chapterNode = cc.findChapterNode('new-chapter')
            assert chapterNode,'fail 1: %s' % (undoType)
            chapterNode.doDelete()
            c.redraw_now()
    finally:
        cc.selectChapterByName('main',collapse=True)
        if 1: # Do this so the activeUnitTests.txt does not change.
            while root.hasChildren():
                root.firstChild().doDelete(newNode=None)
        c.redraw_now()
else:
    self.skipTest('Can not be run locally')

#@+node:ekr.20071113194216: ** leoConfig
# 3 failurs with Alt-5
#@+node:ekr.20111115071700.3870: *3* @test c.config.printSettings
c.config.printSettings()

#@+node:ekr.20120201101804.3907: *3* @test c.config.updateSetting with no @settings node
import leo.core.leoConfig as leoConfig
    
p = c.config.settingsRoot()
assert c
if p:
    # p will not exist when run externally.
    h = p.h
    p.h = '@@' + h
try:
    parser = leoConfig.SettingsTreeParser(c,localFlag=True)
    d1,d2 = parser.traverse()
    assert isinstance(d1,g.TypedDict),d1
    assert isinstance(d2,g.TypedDict),d2
finally:
    if p:
        p.h = h
        c.redraw()
#@+node:ekr.20111124090010.3939: *3* @test g.app.config @buttons and @commands logic
if g.app.gui.guiName() == 'browser':
    self.skipTest('browser gui')
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
if getattr(g.app, 'isBrowserTest', None):
    # Set only in test_browser_gui.py.
    self.skipTest('Browser Gui test')
d = g.app.config.unitTestDict # Always created for this unit test.
keys = ('config.doButtons-file-names','config.doCommands-file-names')
for key in keys:
    aList = d.get(key,[])
    if 'leoSettings' not in aList:
        self.skipTest('no settings') # #1345
    for base in ('leoSettings', 'unitTest'):
        for ext in ('.leo', '.db'):
            if base+ext in aList:
                break
        else:
            print('key', key, 'ext', ext, 'base', base)
            g.printObj(aList)
            assert False,'%s not in unitTestDict[%s]' % (base,key)
#@+node:ekr.20050203084930.1: *3* @test g.app.config.get
w = g.app.config.get('global_setting_for_unit_tests','int')

assert w in (None,132) # Will be None when tests run dynamically.
#@+node:ekr.20111105124216.3840: *3* @test g.app.config.set
setting = 'import_html_tags'
html_tags = ('body','head','html','table','xxx')

# When run externally, c.config.getData will return None.
existing_tags = c.config.getData(setting)
if not existing_tags:
    g.app.config.set(None,setting,'data',html_tags)
    tags = c.config.getData(setting)
    assert c.config.getData(setting) == html_tags
#@+node:ekr.20060325071703.1: *3* @test ifplatform
import sys

win32  = c.config.getBool('test_win32_setting')
darwin = c.config.getBool('test_darwin_setting')

if win32 is None and darwin is None:
    self.skipTest('settings not loaded') # #1345

if sys.platform == 'win32':
    assert(win32)
    assert(not darwin)

elif sys.platform== 'darwin':
    assert(not win32)
    assert(darwin)

#@+node:ekr.20050203001146: *3* @test local settings (c.page_width)
assert c.page_width == c.config.getInt('page_width'),c.page_width
#@+node:ekr.20071113201854: *3* @test zz end of leoConfig tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoConfig tests')
#@+node:ekr.20100131171342.5592: ** leoDialogs
#@+node:ekr.20100131171342.5593: *3* @test ctors for all dialogs
# For some reason these don't select the dialog properly when run as a script.
# However, the main reason for the tests is to make sure the ctors don't crash.
# Also, for unit testing the value of c doesn't matter.
import leo.core.leoGui as leoGui
try:
    oldGui = g.app.gui
    guis = [g.app.gui]
    guis.append(leoGui.UnitTestGui())
    for gui in guis:
        gui.runAboutLeoDialog(c,'version','copyright','url','email')
        gui.runAskLeoIDDialog()
        gui.runAskOkDialog(c,'title','message')
        gui.runAskOkCancelNumberDialog(c,'title','message')
        gui.runAskOkCancelStringDialog(c,'title','message')
        gui.runAskYesNoDialog(c,'title','message')
        gui.runAskYesNoCancelDialog(c,'title','message')
        # gui.runCompareDialog(c) # Removed.
finally:
    g.app.gui = oldGui
#@+node:ekr.20061001114637: ** leoFileCommands
# 3 failures with Alt-5
#@+node:ekr.20080806072412.1: *3* @test fc.resolveArchivedPosition
child1 = p.firstChild()
child2 = p.firstChild().next()
grandChild1 = child2.firstChild()
grandChild2 = grandChild1.next()
greatGrandChild11 = grandChild1.firstChild()
greatGrandChild12 = greatGrandChild11.next()
greatGrandChild21 = grandChild2.firstChild()
greatGrandChild22 = greatGrandChild21.next()
root_v = p.v

table = (
    # Errors.
    (None,'-1'),
    (None,'1'),
    (None,'0.2'),
    (None,'0.0.0'),
    (None,'0.1.2'),
    # Valid.
    (root_v,'0'),
    (child1.v,'0.0'),
    (child2.v,'0.1'),
    (grandChild1.v,'0.1.0'),
    (greatGrandChild11.v,'0.1.0.0'),
    (greatGrandChild12.v,'0.1.0.1'),
    (grandChild2.v,'0.1.1'),
    (greatGrandChild21.v,'0.1.1.0'),
    (greatGrandChild22.v,'0.1.1.1'),
)

for v,archivedPosition in table:
    v2 = c.fileCommands.resolveArchivedPosition(archivedPosition,root_v)
    assert v == v2,'got %s, expected %s' % (v2,v)
#@+node:ekr.20080806072412.2: *4* first child
#@+node:ekr.20080806072412.3: *4* second child
#@+node:ekr.20080806072412.4: *5* grandChild1
#@+node:ekr.20080806080425.1: *6* greatGrandChild11
#@+node:ekr.20080806080425.2: *6* greatGrandChild12
#@+node:ekr.20080806072412.5: *5* grandChild 2
#@+node:ekr.20080806080425.3: *6* greatGrandChild21
#@+node:ekr.20080806080425.4: *6* greatGrandChild22
#@+node:ekr.20080805105541.1: *3* @test p.archivedPosition
val = p.archivedPosition(root_p=p)
assert val == [0],'expected %s, got %s' % ([0],val)

i = 0
for z in p.parent().children_iter():
    val = z.archivedPosition(root_p=p.parent())
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.firstChild().next().children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,1,i],'expected %s, got %s'%([0,1,i],val)
    i += 1
#@+node:ekr.20080805122315.1: *4* first child
#@+node:ekr.20080805122315.2: *4* second child
#@+node:ekr.20080805122315.3: *5* grandChild
#@+node:ekr.20080805122315.4: *5* grandChild 2
#@+node:ekr.20080805104144.1: *3* @test putDescendentVnodeUas
fc = c.fileCommands
child = p.firstChild()
grandChild = child.firstChild()
child.v.unknownAttributes = {'unit_test_child':'abcd'}
grandChild.v.unknownAttributes = {'unit_test_grandchild':'wxyz'}
try:
    s = fc.putDescendentVnodeUas (p)
    if 0: # This test is too flaky to be useful.
        expected = ' descendentVnodeUnknownAttributes=\
        7d7100285803000000302e3071017d7102580f000000756e6974\
        5f746573745f6368696c64710358040000006162636471047358\
        05000000302e302e3071057d71065814000000756e69745f7465\
        73745f6772616e646368696c64710758040000007778797a710873752e"'
        assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    del child.v.unknownAttributes
    del grandChild.v.unknownAttributes
#@+node:ekr.20080805104144.2: *4* child
#@+node:ekr.20080805104144.3: *5* grandChild
#@+node:ekr.20061001114236: *3* @test putUa
fc = c.fileCommands # self is a dummy
p.v.unknownAttributes = {'unit_test': 'abcd'}
s = fc.putUnknownAttributes (p.v)
expected = ' unit_test="58040000006162636471002e"'
assert s == expected, '\nexpected: %s\ngot:      %s' % (repr(expected),repr(s))
#@+node:ekr.20051107115231.9: *3* @test Select a node when file is first loaded
c.redraw(p) # To make node visible

c2 = c.new()
p2 = c2.p

try:
    # This fails, but it is possible to edit the headline.
    # assert c2.edit_widget(p2),'c2.edit_widget(p2) failed: %s' % repr(p2)
    assert p2,'p2 failed: %s' % repr(p2)
    # assert c.edit_widget(p),'c.edit_widget(p) failed: %s' % repr(p)
finally:
    ### c2.setChanged(False)
    c2.clearChanged()
    c2.close()
#@+node:ekr.20090507084947.5152: *3* @test t.fileIndex remains the same
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    # new_gnxs:
    assert p.v.fileIndex == 'ekr.20090507084947.5152',p.v.fileIndex
    # old gnxs:
    # assert p.v.fileIndex == ('ekr', '20090507084947', 5152)
#@+node:ekr.20071113202045: *3* @test zz end of leoFile tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoFileCommands tests.')
#@+node:ekr.20071113193527: ** leoFind
# 4 failures with Alt-5
#@+node:ekr.20060130151716.3: *3* @test minibuffer find commands
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
table = (
    're-search-forward',
    're-search-backward',
    'search-forward',
    'search-backward',
    'word-search-forward',
    'word-search-backward',
)

for command in table:
    # This is not a full test.  We must use keyboardQuit here!
    c.k.simulateCommand(command)
    c.k.keyboardQuit(None)
#@+node:ekr.20190603184713.1: *3* @test replace-all: plain search
fc = c.findCommands

plain_table = (
    # s         find    change  count   result
    ('aA',      'a',    'C',    1,      'CA'),
    ('Aa',      'A',    'C',    1,      'Ca'),
    ('Aba',     'b',    'C',    1,      'ACa'),
)
for s, find, change, count, result in plain_table:
    fc.ignore_case = False
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_plain(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603192140.1: *3* @test replace-all: plain search: ignore case
fc = c.findCommands

plain_table = (
    # s         find    change  count   result
    ('aA',      'a',    'C',    2,      'CC'),
    ('AbBa',    'b',    'C',    2,      'ACCa'),
)
for s, find, change, count, result in plain_table:
    fc.ignore_case = True
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_plain(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603193938.1: *3* @test replace-all: regex search
fc = c.findCommands
regex_table = (
    # s                 find        change  count   result
    ('a ba aa a ab a',  r'\b\w+\b', 'C',    6,      'C C C C C C'),
    ('a AA aa aab ab a',r'\baa\b',  'C',    1,      'a AA C aab ab a'),
    # Multi-line
    ('aaa AA\naa aab',  r'\baa\b',  'C',    1,      'aaa AA\nC aab'),
)
for s, find, change, count, result in regex_table:
    fc.ignore_case = False
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_regex(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603193204.1: *3* @test replace-all: word search
fc = c.findCommands

word_table = (
    # s                 find    change  count   result
    ('a ba aa a ab a',  'a',    'C',    3,      'C ba aa C ab C'),
    ('a ba aa a ab a',  'aa',   'C',    1,      'a ba C a ab a'),
)
for s, find, change, count, result in word_table:
    fc.ignore_case = False
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_word(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603193214.1: *3* @test replace-all: word search: ignore case
fc = c.findCommands

word_table = (
    # s                 find    change  count   result
    ('a ba aa A ab a',  'a',    'C',    3,      'C ba aa C ab C'),
    ('a ba aa AA ab a', 'aa',   'C',    2,      'a ba C C ab a'),
)
for s, find, change, count, result in word_table:
    fc.ignore_case = True
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_word(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20060130151716.2: *3* @test set find mode commands
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
table = (
    'set-find-everywhere',
    'set-find-node-only',
    'set-find-suboutline-only',
)
# show-find-tab-options     = Ctrl-o
# show-find-options         = o
for command in table:
    c.k.simulateCommand(command)
#@+node:ekr.20060130151716.4: *3* @test show-find-options
c.k.simulateCommand('show-find-options')
#@+node:ekr.20060130151716.1: *3* @test toggle find options commands
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
table = (
    # 'toggle-find-clone-find-all-option',
    'toggle-find-ignore-case-option',
    'toggle-find-in-body-option',
    'toggle-find-in-headline-option',
    'toggle-find-mark-changes-option',
    'toggle-find-mark-finds-option',
    'toggle-find-regex-option',
    # 'toggle-find-reverse-option',
    'toggle-find-word-option',
    # 'toggle-find-wrap-around-option',
)
for command in table:
    c.k.simulateCommand(command)
    c.k.simulateCommand(command)
#@+node:ekr.20190608143418.1: *3* New leoFind Tests
#@+node:ekr.20190608144111.1: *4* @test leoFind.LeoFind clean init
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)
table = (
    # 'batch',  # 'wrap', 
    'ignore_case', 'node_only', 'pattern_match', 
    'search_headline', 'search_body', 'suboutline_only',
    'mark_changes', 'mark_finds', 'whole_word',
   
)
for ivar in table:
    assert getattr(x, ivar) is None, ivar
assert x.reverse is False
#@+node:ekr.20190608143502.1: *4* @test find._inner_search_regex
import re
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)

def test(table, table_name, back, nocase):
    for pattern, s, expected in table:
        flags = re.IGNORECASE if nocase else 0
        x.re_obj = re.compile(pattern, flags)
        pos, new_pos = x._inner_search_regex(s, 0, len(s),
            pattern, backwards=back, nocase=nocase)
        got = s[pos:new_pos]
        assert expected==got, (
            '\n   table: %s'
            '\n pattern: %r'
            '\n       s: %r'
            '\nexpected: %r'
            '\n     got: %r' % (table_name, pattern, s, expected, got)
        )

plain_table = (
    # pattern   s       expected
    (r'.',      'A',    'A'),
    (r'A',      'xAy',  'A'),
)
nocase_table = (
    # pattern   s       expected
    (r'.',      'A',    'A'),
    (r'.',      'a',    'a'),
    (r'A',      'xay',  'a'),
    (r'a',      'xAy',  'A'),
)
back_table = (
    # pattern   s           expected
    (r'a.b',    'a1b a2b',  'a2b'),
)
test(plain_table,  'plain_table',  back=False, nocase=False)
test(nocase_table, 'nocase_table', back=False, nocase=True)
test(back_table,   'back_table',   back=True,  nocase=False)
#@+node:ekr.20190608143502.2: *4* @test find._inner_search_backward
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)

def test(table, table_name, nocase, word):
    test_n = 0
    for pattern, s, i, j, expected, expected_i, expected_j in table:
        test_n += 1
        if j == -1: j = len(s)
        got_i, got_j = x._inner_search_backward(s, i, j,
            pattern, nocase=nocase, word=word)
        got = s[got_i: got_j]
        assert expected==got and got_i == expected_i and got_j == expected_j, (
            '\n     table: %s'
            '\n    i test: %s'
            '\n   pattern: %r'
            '\n         s: %r'
            '\n  expected: %r'
            '\n       got: %r'
            '\nexpected i: %s'
            '\n     got i: %s'
            '\nexpected j: %s'
            '\n     got j: %s'
            % (table_name, test_n, pattern, s, expected, got, expected_i, got_i, expected_j, got_j))

plain_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',      'abaca',     0, -1,  'a',      4,          5),
    ('A',      'Abcde',     0, -1,  'A',      0,          1),
)
nocase_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  'a',      5,          6),
    ('A',       'Abcdca',   0, -1,  'a',      5,          6),
)
word_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  '',      -1,          -1),
    ('A',       'AA A AB',  0, -1,  'A',      3,          4),
)
test(plain_table,  'plain_table',  nocase=False, word=False)
test(nocase_table, 'nocase_table', nocase=True,  word=False)
test(word_table,   'word_table',   nocase=False, word=True)
#@+node:ekr.20190608143502.3: *4* @test find._inner_search_plain
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)

def test(table, table_name, nocase, word):
    test_n = 0
    for pattern, s, i, j, expected, expected_i, expected_j in table:
        test_n += 1
        if j == -1: j = len(s)
        got_i, got_j = x._inner_search_plain(s, i, j, pattern,
            nocase=nocase, word=word)
        got = s[got_i: got_j]
        assert expected==got and got_i == expected_i and got_j == expected_j, (
            '\n     table: %s'
            '\n    i test: %s'
            '\n   pattern: %r'
            '\n         s: %r'
            '\n  expected: %r'
            '\n       got: %r'
            '\nexpected i: %s'
            '\n     got i: %s'
            '\nexpected j: %s'
            '\n     got j: %s'
            % (table_name, test_n, pattern, s, expected, got, expected_i, got_i, expected_j, got_j))

plain_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',      'baca',     0, -1,   'a',      1,          2),
    ('A',      'bAcde',     0, -1,  'A',      1,          2),
)
nocase_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  'a',      0,          1),
    ('A',       'abcdca',   0, -1,  'a',      0,          1),
)
word_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  '',      -1,          -1),
    ('A',       'AA A AAB', 0, -1,  'A',      3,          4),
)
test(plain_table,  'plain_table',  nocase=False, word=False)
test(nocase_table, 'nocase_table', nocase=True,  word=False)
test(word_table,   'word_table',   nocase=False, word=True)
#@+node:ekr.20190608143503.1: *4* @test find.replace_back_slashes
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)
table = (
    ('\\\\', '\\'),
    ('\\n', '\n'),
    ('\\t', '\t'),
)
for s, expected in table:
    got = x.replace_back_slashes(s)
    assert expected==got, (
        '\n         s: %r'
        '\n  expected: %r'
        '\n       got: %r'
        % (s, expected, got))
#@+node:ekr.20071113202153: *3* @test zz end of leoFind tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoFind tests.')
#@+node:ekr.20071113194424: ** leoFrame
# 3 failures with Alt-5
#@+node:ekr.20061106201509.6: *3* @test c.frame.body.getInsertLines
# line 1
# line 2
# line 3

w = c.frame.body.wrapper
index = 11 # in the second line.
w.setInsertPoint(index)
before,ins,after = c.frame.body.getInsertLines()
assert before == '# line 1\n','Got %s' % repr(before)
assert ins    == '# line 2\n','Got %s' % repr(ins)
assert after.startswith('# line 3\n'),'line3'
assert after.endswith('# end.\n'),'end'

# end.
#@+node:ekr.20061106201509.7: *3* @test c.frame.body.getSelectionAreas
# line 1
# line 2
# line 3

w = c.frame.body.wrapper
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
#@+node:ekr.20071113145804.32: *3* @test c.frame.body.getSelectionAreas & test
# line 1
# line 2
# line 3

w = c.frame.body.wrapper
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
#@+node:ekr.20111121152019.3929: *3* @test c.frame.body.updateEditors
'''updateEditors was crashing due to calling setSelectionRange(ins=i).
The proper keyword argument is insert=i.
'''

c.frame.body.updateEditors()
#@+node:ekr.20111107065530.3833: *3* @test c.frame.resize-to-screen
# The actual code contains the unit test.
# This test will have effect only when run locally.

if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

d = g.app.unitTestDict
tag = 'resize-to-screen'
assert not d.get(tag)
c.frame.resizeToScreen()
assert d.get(tag) is True
#@+node:ekr.20100131180007.5359: *3* @test c.frame.tree.OnIconDoubleClick
c.frame.tree.OnIconDoubleClick(p)
#@+node:ekr.20071113202153.1: *3* @test zz end of leoFrame tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoFrame tests.')
#@+node:ekr.20100131171342.5604: ** leoKeys
#@+node:ekr.20100131171342.5608: *3* @test g.KeyStroke
table = [
    # Gang of four, unmodified)
    ('bksp', 'BackSpace'),
    ('backspace', 'BackSpace'),
    ('backtab', 'Tab'),
    ('linefeed', '\n'),
    ('\r', '\n'),
    ('return', '\n'),
    ('tab', 'Tab'),
    # Gang of four, with shift mod.
    ('Shift-bksp', 'Shift+BackSpace'),
    ('Shift-backspace', 'Shift+BackSpace'),
    ('Shift-backtab', 'Shift+Tab'),
    ('Shift-linefeed', 'Shift+Return'),
    ('Shift-\r', 'Shift+Return'),
    ('Shift-return', 'Shift+Return'),
    ('Shift-tab', 'Shift+Tab'),
    # Gang of four, with Alt mod.
    ('Alt-bksp', 'Alt+BackSpace'),
    ('Alt-backspace', 'Alt+BackSpace'),
    ('Alt-backtab', 'Alt+Tab'),
    ('Alt-linefeed', 'Alt+Return'),
    ('Alt-\r', 'Alt+Return'),
    ('Alt-return', 'Alt+Return'),
    ('Alt-tab', 'Alt+Tab'),
    #
    # #912: tilde.
    ('~', '~'),
    ('Shift-~', '~'),
    #
    # Alpha
    ('1', '1'),
    ('a','a'),
    ('A','A'),
    ('Alt-a','Alt+a'),
    ('Alt-A','Alt+a'),
    ('Alt-Shift-a','Alt+Shift+a'),
    # We can no longer ignore the shift.
    # ('Alt-Shift++','Alt+plus'), # Ignore the shift.
    ('Shift-a','A'),
    ('Shift-A','A'),
    ('RtArrow','Right'),
    ('Shift-RtArrow','Shift+Right'),
    ('PageUp','Prior'),
    ('Prior','Prior'),
    ('Shift-PageUp','Shift+Prior'),
    ('PageDn','Next'),
    ('Next','Next'),
    ('Shift-Next','Shift+Next'),
    ('Alt-=','Alt+='),
    ('Alt-+','Alt++'),
    ('Alt--','Alt+-'),
    ('Ctrl-RtArrow','Ctrl+Right'),
    ('Control-Right','Ctrl+Right'),
]
for setting, result in table:
    stroke = g.KeyStroke(binding=setting)
    val = stroke.s
    assert val==result,'For %r, expected %r, Got %r' % (setting, result,val)
#@+node:ekr.20180527141026.1: *3* @test g.KeyStroke (printable characters)
import string
# Unshifted.
for ch in string.printable:
    stroke = g.KeyStroke(binding=ch)
    assert stroke.s in string.printable, (repr(ch), repr(stroke.s))
    if ch == '\r':
        assert stroke.s == '\n', (repr(ch), repr(stroke.s))
    else:
        assert stroke.s == ch, (repr(ch), repr(stroke.s))
# Shifted.
for ch in string.digits + string.ascii_letters:
    stroke = g.KeyStroke(binding='Shift-'+ch)
    assert stroke.s in string.printable, (repr(ch), repr(stroke.s))
#@+node:ekr.20110509104953.3474: *3* @test k.get_leo_completions
table = (
    ( 50,'c.'),
    (  3,'p.ins'),
    ( 17,'g.print'),
)
g.pr
ac = c.k.autoCompleter
ac.w = c.frame.body.wrapper
for expected,prefix in table:
    aList = ac.get_leo_completions(prefix)
    assert len(aList) >= expected,'len(aList): %s, prefix: %s' % (len(aList),prefix)
#@+node:ekr.20100131171342.5605: *3* @test k.isPlainKey
import string
k = c.k
for ch in (string.printable):
    assert k.isPlainKey(ch), 'not plain: %s' % (repr(ch))
if 0:
    # The NullGui class knows nothing about these characters,
    # so these tests now fail.
    # Happily, there is a continuous unit test in k.checkKeyEvent.
    special = (
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )
    for ch in special:
        assert not k.isPlainKey(ch), 'is plain: %s' % (ch)
#@+node:ekr.20100212110954.5359: *3* @test k.print-bindings
lines = c.k.printBindings()
# assert lines[0].strip().endswith('Alt+Ctrl+Shift')
#@+node:ekr.20100131171342.5607: *3* @test k.registerCommand
k = c.k ; p = c.p
w = c.edit_widget(p)
commandName = 'test-registerCommand'

def callback (event=None,c=c): # Must have an event param to pass later unit test.
    g.app.unitTestDict[commandName] = True

# Test 1
g.app.unitTestDict[commandName] = False
# k.registerCommand(commandName,callback,pane='all',shortcut='Alt-Ctrl-Shift-z',verbose=True)
k.registerCommand(commandName,callback)
k.simulateCommand(commandName)
assert g.app.unitTestDict.get(commandName)

if 0: # Test 2
    g.app.unitTestDict[commandName] = False
    k.manufactureKeyPressForCommandName(w,commandName)
    assert g.app.unitTestDict.get(commandName)
#@+node:ekr.20100131171342.5609: *3* @test zz end of leoKeys tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoKeys tests.')
#@+node:ekr.20140712142620.4458: ** leoPersistence tests (do not clone)
#@+node:ekr.20140712142620.4503: *3* @test p.sort_key
aList = [p.copy() for p in c.all_positions()]
aList2 = sorted(reversed(aList),key=p.sort_key)
i = 0
for p in aList2:
    p2 = aList[i]
    i += 1
    assert p == p2,'\n%s:%s\n%s:%s' % (
        p.sort_key(p),p.h,p2.sort_key(p2),p2.h)
#@+node:ekr.20140712142620.4550: *3* @test pd.find_at_...
# Also a test of find_at_views_node, find_at_organizers_node and find_at_clones_node.
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    try:
        persistence = pd.find_at_persistence_node()
        assert persistence
        persistence.deleteAllChildren()
        root.h = '@auto root' # Make root look like an @auto node.
        assert pd.find_at_data_node(root)
        assert pd.find_at_gnxs_node(root)
    finally:
        root.h = 'root' # Make sure root is *not* an @auto node.
        # views.deleteAllChildren()
        c.selectPosition(p)
        c.redraw()
#@+node:ekr.20140712142620.4551: *4* root
#@+node:ekr.20140712142620.4552: *5* aClass
class aClass:
    @others
#@+node:ekr.20140712142620.4556: *6* clone
#@+node:ekr.20140712142620.4556: *4* clone
#@+node:ekr.20140712142620.4538: *3* @test pd.find_at_persistence_node
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    h = '@persistence'
    p1 = pd.find_at_persistence_node()
    assert p1
    p2 = pd.has_at_persistence_node()
    assert p1 == p2,(p1,p2)
#@+node:ekr.20140712142620.4539: *3* @test pd.find_position_for_relative_unl
pd = c.persistenceController
parent = p.copy()
node1 = p.firstChild()
node2 = node1.next()
node3 = node2.next()
assert node1 and node2 and node3
child11 = node1.firstChild()
child12 = child11.next()
assert child11 and child12
child21 = node2.firstChild()
child22 = child21.next()
assert child21 and child22
node3_child1 = node3.firstChild()
assert node3_child1
node3_child1_child21 = node3_child1.firstChild()
assert node3_child1_child21
table = (
    ('node1',node1),
    ('',parent), # This special case is important.
    ('node1-->child11',child11),
    ('node1-->child12',child12),
    ('node2',node2),
    ('node2-->child21',child21),
    ('node2-->child22',child22),
    # Partial matches.
    ### ('node3-->child1-->child21',node3_child1_child21),
    ### ('child1-->child21',node3_child1_child21),
    ### ('xxx-->child21',node3_child1_child21),
        # This is ambiguous.
    # No matches.
    ('nodex',None),
    ('node1-->childx',None),
    ('node3-->childx',None),
)
for unl,expected in table:
    got = pd.find_position_for_relative_unl(parent,unl)
    assert got == expected,'unl: %s expected: %s got: %s' % (
        unl,expected and expected.h,got and got.h)
#@+node:ekr.20140712142620.4540: *4* node1
#@+node:ekr.20140712142620.4541: *5* child11
#@+node:ekr.20140712142620.4542: *5* child12
#@+node:ekr.20140712142620.4543: *4* node2
#@+node:ekr.20140712142620.4544: *5* child21
#@+node:ekr.20140712142620.4545: *5* child22
#@+node:ekr.20140715080507.4340: *4* node3
#@+node:ekr.20140715080507.4341: *5* node3_child1
#@+node:ekr.20140715080507.4339: *6* child21
#@+node:ekr.20140712142620.4546: *3* @test pd.find_representative_node
if g.app.isExternalUnitTest:
    # There will not be a proper cloned node in the copy of these tests.
    self.skipTest('Can not be run externally')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    root.h = '@auto root'
    try:
        clone = root.next()
        assert clone and clone.h == 'clone'
        inner_clone = root.firstChild()
        assert inner_clone
        assert clone.v == inner_clone.v
        rep = pd.find_representative_node(root,inner_clone)
        # Careful: cloning this test can cause problems.
        oops = '\n  rep: %s\nparent:%s\nclone: %s\nparent:%s\ninner: %s\nparent: %s' % (
            rep,rep.parent(),clone,clone.parent(),inner_clone,inner_clone.parent())
        if g.app.isExternalUnitTest:
            pass
        else:
            assert rep == clone,(repr(rep),repr(clone))
    finally:
        root.h = 'root' # root must not be an @auto node.
        c.redraw()
#@+node:ekr.20140712142620.4547: *4* root
#@+node:ekr.20140712142620.4549: *5* clone
#@+node:ekr.20140712142620.4549: *4* clone
#@+node:ekr.20140712142620.4557: *3* @test pd.has_..._node
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    # Test pd.has_at_auto_view_node, pd.has_at_clones_node and pd.has_at_organizers_node.
    pd = c.persistenceController
    persistence = g.findNodeAnywhere(c,'@persistence')
    assert persistence
    assert pd.has_at_persistence_node()
    persistence.deleteAllChildren()
    assert persistence
    root = g.findNodeInTree(c,p,'root')
    assert root
    # The representative of clone_test node must appear outside of root's tree.
    clone_test = g.findNodeInTree(c,p,'clone-test')
    if g.app.isExternalUnitTest:
        # There will not be a proper node in the copied tree.
        self.skipTest('Can not be run externally')
    else:
        assert clone_test
        assert clone_test.v == root.next().v,(clone_test.v,root.next().v)
        try:
            root.h = '@auto root' # Make root look like an @auto node.
            pd.update_before_write_foreign_file(root)
            data = g.findNodeInTree(c,persistence,'@data:@auto root')
            assert data
            data2 = pd.has_at_data_node(root)
            assert data2
            assert data == data2,(data,data2)
            gnxs = g.findNodeInTree(c,persistence,'@gnxs')
            assert gnxs
            gnxs2 = pd.has_at_gnxs_node(root)
            assert gnxs2
            assert gnxs == gnxs2,(gnxs,gnxs2)
        finally:
            root.h = 'root' # Make the root *not* an @auto node.
            c.redraw()
#@+node:ekr.20140712142620.4558: *4* root
@others
#@+node:ekr.20140712142620.4559: *5* aClass
class aClass:
    @others
#@+node:ekr.20140712142620.4563: *6* clone-test
def clone_test():
    pass
#@+node:ekr.20140712142620.4561: *6* organizer node
#@+node:ekr.20140712142620.4562: *7* child2
def spam():
    pass
#@+node:ekr.20140712142620.4563: *4* clone-test
def clone_test():
    pass
#@+node:ekr.20140712142620.4507: *3* @test pd.restore_gnxs
pd = c.persistenceController
gnxs = g.findNodeInTree(c,p,'@gnxs')
root = g.findNodeInTree(c,p,'root')
node1 = g.findNodeInTree(c,p,'node1')
assert gnxs and root and node1
root.deleteAllChildren()
new_node1 = root.insertAsLastChild()
new_node1.h = 'node1'
gnxs.b = 'gnx: %s\nunl: %s\n' % (node1.v.gnx,'node1')
try:
    pd.restore_gnxs(gnxs,root)
    # Important: p._relinkAsCloneOf leaves new_node1 unchanged,
    # but new_node1 should not be used.
finally:
    c.redraw()
#@+node:ekr.20140712142620.4508: *4* @gnxs
gnx: ekr.20140923080452.6565
unl: node1
#@+node:ekr.20140923080452.6565: *4* node1
#@+node:ekr.20140712142620.4510: *4* root
#@+node:ekr.20140923080452.6565: *5* node1
#@+node:ekr.20140712142620.4574: *3* @test pd.unl
pd = c.persistenceController
unl = pd.unl(p)
expected = p.h if g.app.isExternalUnitTest else '-->'+p.h
assert unl.endswith(expected),repr(unl)
#@+node:ekr.20140712142620.4575: *3* @test pd.update_before_write_foreign_file
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    persistence = pd.find_at_persistence_node()
    assert persistence
    persistence.deleteAllChildren()
    try:
        root.h = '@auto root' # Make root look like an @auto node.
        pd.update_before_write_foreign_file(root)
        data = g.findNodeAnywhere(c,'@data:@auto root')
        assert data
        gnxs = g.findNodeInTree(c,data,'@gnxs')
        assert gnxs
    finally:
        root.h = 'root' # Make root *not* an @auto node.
        # persistence.deleteAllChildren()
        c.redraw()
#@+node:ekr.20140712142620.4576: *4* root
#@+node:ekr.20140712142620.4577: *5* aClass
class aClass:
    @others
#@+node:ekr.20140712142620.4582: *6* clone
#@+node:ekr.20140712142620.4579: *5* organizer node
#@+node:ekr.20140712142620.4580: *6* child1
#@+node:ekr.20140712142620.4581: *6* child2
def spam():
    pass
#@+node:ekr.20140712142620.4582: *4* clone
#@+node:ekr.20150216111306.25: *3* @test delete all children of @persistence node
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    persistence = g.findNodeAnywhere(c,'@persistence')
    assert persistence
    assert pd.has_at_persistence_node()
    persistence.deleteAllChildren()
    assert persistence
#@+node:ekr.20100131171342.5610: ** leoPlugins
#@+node:ekr.20100131171342.5611: *3* @test getHandlersForTag
pc = g.app.pluginsController

aList1 = pc.getHandlersForTag('select1')
aList2 = pc.getHandlersForOneTag('select1')

assert type(aList1) == type([])
assert type(aList2) == type([])
assert aList1 == aList2
#@+node:ekr.20100909082308.5990: *3* @test regularizeName
pc = g.app.pluginsController

table = (
    ('x',               'x'),
    ('foo.bar',         'foo.bar'),
    ('x.py',            'leo.plugins.x'),
    ('leo.plugins.x',   'leo.plugins.x')    
)

for fn,expected in table:
    result = pc.regularizeName(fn)
    assert result==expected,'expected %s, got %s' % (
        expected,result)
    # Make sure that calling regularizeName twice is benign.
    result2 = pc.regularizeName(result)
    assert result2==result
#@+node:ekr.20100131171342.5612: ** leoTest
#@+node:ekr.20111102122424.3975: *3* @test all unit tests have access to sources
if g.app.gui.guiName() == 'browser':
    self.skipTest('browser gui')
if c.shortFileName() == 'dynamicUnitTest.leo':
    setting = 'c.write-script-file'
    assert c.write_script_file,'fail 1: %s should be hard set' % (setting)
else:
    setting = "c.config.getBool('write-script-file')"
    assert c.write_script_file,'fail 2: check %s' % (setting)
#@+node:ekr.20111105221757.3833: *3* @test TM.findAllUnitTestNodes
p1 = p.copy()

def found(p,result):
    return any([p.v == p2.v for p2 in result])

table = (('all',True,False),('marked',False,True))
try:
    p.setMarked()
    assert p.isMarked(),p
    for kind,all,marked in table:
        result = c.testManager.findAllUnitTestNodes(all,marked)
        assert found(p,result),(kind,len(result))
    assert p == p1,(p,p1)
finally:
    p1.clearMarked()
#@+node:ekr.20100131171342.5613: *3* @test unit testing with embedded class
def sendEmail(self):
    pass # g.trace('self2',self)

class test:
    pass

X = test()
sendEmail(X)
#@+node:ekr.20071113193729: ** leoUndo
#@+node:ekr.20040712101754.37: *3* @suite Edit body tests
# Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeEditBodySuite(p)

# g.app.scriptDict['suite'] = suite
#@+node:ekr.20040712101754.38: *4* editBodyTests
@language plain
@

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:

- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
#@+node:ekr.20060127120604: *5* tempNode
#@+node:ekr.20050417202713: *5* addComments
#@+node:ekr.20050417202713.1: *6* before
@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@+node:ekr.20050417202713.2: *6* after
@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
#@+node:ekr.20050417202713.3: *6* selection
5.0
7.8
#@+node:ekr.20050417204940: *5* convertAllBlanks
#@+node:ekr.20050417204940.1: *6* before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417204940.2: *6* after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417204940.3: *6* selection
1.0
6.5
#@+node:ekr.20050417205012: *5* convertAllTabs
#@+node:ekr.20050417205012.1: *6* before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417205012.2: *6* after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417205012.3: *6* selection
1.0
6.5
#@+node:ekr.20050417203114: *5* convertBlanks
#@+node:ekr.20050417203310: *6* before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417203310.1: *6* after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417203336: *6* selection
1.0
6.5
#@+node:ekr.20050417203114.1: *5* convertTabs
#@+node:ekr.20050417204834: *6* before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417204830: *6* after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417204901: *6* selection
1.0
6.5
#@+node:ekr.20040712101754.49: *5* dedentBody
#@+node:ekr.20040712101754.50: *6* before
line 1
    line 2
    line 3
line 4
#@+node:ekr.20040712101754.51: *6* after
line 1
line 2
line 3
line 4
#@+node:ekr.20040712101754.52: *6* selection
2.0
3.5
#@+node:ekr.20050417202817: *5* deleteComments
# created by new add-comments
#@+node:ekr.20050417202817.1: *6* before
@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    pass
#@+node:ekr.20050417202817.2: *6* after
@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@+node:ekr.20050417202817.3: *6* selection
5.0
7.8
#@+node:ekr.20111112211307.3910: *5* deleteComments
# created by old and new add-comments.
#@+node:ekr.20111112211307.3911: *6* before
@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    # if 1:
        # a = 2
        # b = 3

    pass
#@+node:ekr.20111112211307.3912: *6* after
@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    if 1:
        a = 2
        b = 3

    pass
#@+node:ekr.20111112211307.3913: *6* selection
5.0
12.8
#@+node:ekr.20050417201845: *5* extract test1
#@+node:ekr.20050417201845.1: *6* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050417201845.2: *6* after
before
    << section >>
after
#@+node:ekr.20050417201845.3: *7* << section >>
sec line 1
    sec line 2 indented
sec line 3
#@+node:ekr.20050417201845.4: *6* selection
2.0
5.10
#@+node:ekr.20050518070540: *5* extract test2
#@+node:ekr.20050518070540.1: *6* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518070545: *6* after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518070540.4: *6* selection
2.0
2.16
#@+node:ekr.20050518070927: *5* extract test3
#@+node:ekr.20050518070927.1: *6* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518070927.2: *6* after
before
    << section >>
after
#@+node:ekr.20050518070927.3: *7* << section >>
sec line 1
    sec line 2 indented
sec line 3
#@+node:ekr.20050518070927.4: *6* selection
2.0
5.10
#@+node:ekr.20050518071251: *5* extract test4
#@+node:ekr.20050518071251.1: *6* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518071258: *6* after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518071251.4: *6* selection
2.0
2.16
#@+node:ekr.20190210103111.1: *5* line_to_headline test1
#@+node:ekr.20190210103111.2: *6* before
before
headline
after
#@+node:ekr.20190210103111.3: *6* after
before
after
#@+node:ekr.20190210103111.4: *7* headline
#@+node:ekr.20190210103111.5: *6* selection
2.0
2.0
#@+node:ekr.20201018144248.1: *3* @test restore marked bits
# Test of #1694.
u, w = c.undoer, c.frame.body.wrapper
oldText = p.b
newText = p.b + '\n#changed'
try:
    for marked in (True, False):
        c.undoer.clearUndoState()  # Required.
        p.setMarked() if marked else p.clearMarked()
        oldMarked = p.isMarked()
        w.setAllText(newText)  # For the new assert in w.updateAfterTyping.
        u.setUndoTypingParams(p,
            undo_type = 'typing',
            oldText = oldText,
            newText = newText,
        )
        u.undo()
        assert p.b == oldText, repr(p.b)
        assert p.isMarked() == oldMarked, ('fail 1', p.isMarked(), oldMarked)
        u.redo()
        assert p.b == newText, repr(p.b)
        assert p.isMarked() == oldMarked, ('fail 2', p.isMarked(), oldMarked)
finally:
    p.b = oldText
    p.clearMarked()
#@+node:ekr.20190923170025.1: *3* @test undo editHeadline
# Brian Theado.
c.undoer.clearUndoState()
assert [p.h for p in p.subtree()] == ['node 1', 'node 2', 'node 3']

# Select 'node 1' and modify the headline as if a user did it
node1 = p.copy().moveToFirstChild()
c.selectPosition(node1)
c.editHeadline()
w = c.frame.tree.edit_widget(node1)
w.insert('1.0', 'changed - ')
c.endEditing()
assert [p.h for p in p.subtree()] == ['changed - node 1', 'node 2', 'node 3']

# Move the selection and undo the headline change
c.selectPosition(node1.copy().moveToNext())
c.undoer.undo()

# The undo should restore the 'node 1' headline string
assert [p.h for p in p.subtree()] == ['node 1', 'node 2', 'node 3']

# The undo should select the edited headline.
assert c.p == node1, f"c.p: {c.p.h}, node1: {node1.h}"
#@+node:ekr.20190923170025.2: *4* node 1
#@+node:ekr.20190923170025.3: *4* node 2
#@+node:ekr.20190923170025.4: *4* node 3
#@+node:bpt.20190825074247.1: *3* @test undo/redoGroup
# This test exposed a bug with redoGroup c.undoer.bead index off-by-one
# The first c.pasteOutline() is there to setup the test cases, but it also serves
# an important hidden purpose of adding undo state to the undo stack. Due
# to the wrap-around nature of python index = -1, the original redoGroup code
# worked fine when the undo group is the first one on the undo stack.
# There are several commands which use undoGroup. The convertAllBlanks
# was arbitrarily chosen to expose the bug.
c.undoer.clearUndoState()
original = p.copy().moveToFirstChild()
c.selectPosition(original)
c.copyOutline()
# Do and undo
c.pasteOutline()
do_and_undo = original.copy().moveToNext()
do_and_undo.h = "do and undo"
c.convertAllBlanks()
c.undoer.undo()
assert original.b == do_and_undo.b, "Undo should restore to original"
# Do
c.pasteOutline()
do = do_and_undo.copy().moveToNext()
do.h = "do"
c.convertAllBlanks()
# Do, undo, redo
c.pasteOutline()
do_undo_redo = do.copy().moveToNext()
do_undo_redo.h = "do, undo, redo"
c.convertAllBlanks()
c.undoer.undo()
c.undoer.redo()
assert do.b == do_undo_redo.b, "Redo should do the operation again"
#@+node:bpt.20190825074316.1: *4* original
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20210906133808.1: *4* do and undo
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20210906133808.2: *4* do
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20210906133808.3: *4* do, undo, redo
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20071113202510: *3* @test zz end of leoUndo tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoUndo tests.')
#@+node:ekr.20140802074328.4471: ** leoVim.py
#@+node:ekr.20140802074328.4472: *3* @test vc.on_same_line
vc = c.vimCommands
s = '''
abc
xyz
pdq
'''
table = (
    ('ab','y',False),
    ('a','c',True),
    ('x','\np',True),
    ('\nx','z',False),
)
for a,b,expected in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.on_same_line(s,i1,i2)
    assert result == expected,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
#@+node:ekr.20140802074328.4473: *3* @test vc.to_bol
vc = c.vimCommands
s = '''
abc
xyz
'''
table = (
    ('a','a'),
    ('a','b'),
    ('a','\nx')
)
for a,b,in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.to_bol(s,i2)
    assert result == i1,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
#@+node:ekr.20140802074328.4474: *3* @test vc.to_eol
vc = c.vimCommands
s = '''
abc
xyz
'''
table = (
    ('a','\nx'),
    ('b','\nx'),
    ('c','\nx'),
    ('\nx','\nx'),
)
for a,b,in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.to_eol(s,i1)
    assert result == i2,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
#@+node:ekr.20050120095423: ** Plugins
# Do this last.
#@+node:ekr.20110610082755.3362: *3*  qt gui
#@+node:ekr.20100131171342.5503: *4* @test c.vnode2position
for p in c.all_positions():
    p2 = c.vnode2position(p.v)
    # print(p2.level(), p2.headString())
    # We can *not* assert that p == p2, only that
    # p2.v == p.v and c.positionExists(p2)
    assert p2
    assert p2.v == p.v,'p2.v: %s, p.v: %s' % (p2.v,v)
    assert c.positionExists(p2),'does not exist: %s' % p2
#@+node:ekr.20100131171342.5504: *4* @test position2Item
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses')
        # All "item" logic is for Qt only.

tree = c.frame.tree
# position2item does not exist when running unit tests dynamically.
if hasattr(tree,'position2item'):
    c.redraw()
    p = c.rootPosition()
    while p:
        item = tree.position2item(p)
        v = tree.item2vnode(item)
        if v: # New test needed with per-clone expansions.
            assert v == p.v, 'item2: %s, p.v: %s' % (item,p.v)
        p.moveToVisNext(c)
#@+node:ekr.20050120095423.11: *3* @suite import or test syntax of all plugins
'''Imports all plugins or just tests their syntax,
epending on a switch in PluginTestCase.runTest.'''

import glob
import sys
import unittest

@others

suite = makePluginsTestSuite(c)

# g.app.scriptDict['suite'] = suite
#@+node:ekr.20050120095423.12: *4* makePluginsTestSuite
def makePluginsTestSuite(c):

    '''Create a plugin test for .py file in the plugins directory'''

    # Create the suite.
    suite = unittest.makeSuite(unittest.TestCase)

    # Add a test case for every plugin.
    paths = (
        g.os_path_join(g.app.loadDir,'..','plugins','*.py'),
        g.os_path_join(g.app.loadDir,'..','plugins','examples','*.py'),
    )
    all_files = []
    for path in paths:
        plugins = g.os_path_join(path)
        plugins = g.os_path_abspath(plugins)
        files = glob.glob(plugins)
        files = [g.os_path_abspath(f) for f in files]
        all_files.extend(files)
    all_files.sort()
    
    for fn in all_files:
        test = pluginTestCase(c,fn)
        suite.addTest(test)

    if 0:
        # Open a new window after all tests are completed.  Tests many plugins.
        lastTest = lastTestCase(c,openFlag=True)
        suite.addTest(lastTest)

    return suite
#@+node:ekr.20050120095423.13: *4* class pluginTestCase
class pluginTestCase(unittest.TestCase):

    '''A test case to test a single Leo plugin.'''

    @others
#@+node:ekr.20050120095423.14: *5* __init__
def __init__ (self,c,path):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
#@+node:ekr.20050120095423.15: *5* fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
#@+node:ekr.20050120095423.16: *5* runTest
def runTest(self):

    trace = False
    c = self.c ; path = self.path
    path,base = g.os_path_split(path)
    fn = base[:-3]
    
    ignore = (
        # Read error.
        'chinese_menu',
        # Unfinished/obsolute gui's.
        'gtkDialogs','gtkGui','ironPython','ironPythonGui',
        'swing_gui','tkGui','wxGui','temacs',
        # Tk-only.
        'ipython',
        # Imports path & win32clipboard.
        'at_view',
        # Experimental.
        'stickynotes_plus',
        # Generated by unit tests.
        'pluginsTest',
        # Imports non-standard modules.
        'interact',         # import pexpect
        'jinjarender',      # import jinga2
        'leofeeds',         # import feedparser
    )

    if fn in ignore:
        return
    
    if trace: g.trace(fn)
    
    if 1:
        # Just check the syntax.  Doesn't pollute other unit tests.
        with open(self.path,'r') as f:
            s = f.read()
        assert c.testManager.checkFileSyntax(fn,s,reraise=False,suppress=False)
    else: # Good for initial tests, but pollutes all other unit tests.
        exec('import leo.plugins.%s' % fn)
    
#@+node:ekr.20050120095423.17: *5* setUp
def setUp(self):

    g.app.unitTestDict = {}
#@+node:ekr.20050120095423.18: *5* shortDescription
def shortDescription (self):

    return "pluginTestCase: %s" % g.shortFileName(self.path)
#@+node:ekr.20050120095423.20: *4* class lastTestCase
class lastTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''

    def __init__ (self,c,openFlag):
        # Init the base class.
        unittest.TestCase.__init__(self)
        self.c = c
        self.openFlag = openFlag

    def runTest(self):
        c = self.c
        print('\n%s a new window to test more plugin logic\n' % g.choose(
            self.openFlag,'opening','open'))
        if self.openFlag:
            self.new_c = new_c = c.new() # Create the new window.
            new_c.frame.setTitle("unit test for 'new' hook")

    if 0: # Doesn't work
        def shutDown(self):
            c = self.new_c
            c.close()
#@+node:ekr.20111104214341.3835: *3* @test all plugins have top-level init method
'''Ensure all plugins have top-level init method *without* importing them.'''

import glob
import inspect

# Get a list of all plugins.
plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
plugins = g.os_path_abspath(plugins)
files = glob.glob(plugins)
files = [g.os_path_abspath(z) for z in files]
files = [z for z in files if not z.endswith('__init__.py')]
files.sort()

exclude = [
    # These are not real plugins...
    'babel_api.py',
    'babel_kill.py',
    'babel_lib.py',
    'baseNativeTree.py',
    'leocursor.py',
    'leo_cloud_server.py',
    'leo_mypy_plugin.py',
    'qtGui.py',
    'qt_big_text.py',
    'qt_commands.py',
    'qt_events.py',
    'qt_frame.py',
    'qt_idle_time.py',
    'qt_main.py',
    'qt_quickheadlines.py',
    'qt_quicksearch_sub.py',
    'qt_text.py',
    'qt_tree.py',
    'qt_quicksearch.py',
    'swing_gui.py',
]

for fn in files:
    if not g.shortFileName(fn) in exclude:
        f = open(fn,'r')
        s = f.read()
        f.close()
        ok1 = s.find('def init():') > -1
        ok2 = s.find('def init ():') > -1
        assert ok1 or ok2,'fail: %s' % (fn)
    
#@+node:ekr.20210518092129.1: *3* @test all qt plugins call g.assertUi('qt')
'''Ensure all plugins have top-level init method *without* importing them.'''

import glob
import inspect
import re

# Get a list of all plugins.
plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
plugins = g.os_path_abspath(plugins)
files = glob.glob(plugins)
files = [g.os_path_abspath(z) for z in files]
files = [z for z in files if not z.endswith('__init__.py')]
files.sort()

exclude = [
    # These are not real plugins...
    'babel_api.py',
    'babel_kill.py',
    'babel_lib.py',
    'baseNativeTree.py',
    'leocursor.py',
    'leo_cloud_server.py',
    'leo_mypy_plugin.py',
    'nested_splitter.py',
    'pyplot_backend.py',
    'qtGui.py',
    'qt_big_text.py',
    'qt_commands.py',
    'qt_events.py',
    'qt_frame.py',
    'qt_gui.py',
    'qt_idle_time.py',
    'qt_main.py',
    'qt_quickheadlines.py',
    'qt_quicksearch_sub.py',
    'qt_text.py',
    'qt_tree.py',
    'qt_quicksearch.py',
    'swing_gui.py',
    #
    # Special cases, handling Qt imports in unusual ways.
    #
    'backlink.py',  # Qt code is optional, disabled with module-level guard.
    'leoscreen.py',  # Qt imports are optional.
    'nodetags.py',  # #2031: Qt imports are optional.
    # 'free_layout.py',
]
pattern = re.compile(r'\b(QtCore|QtGui|QtWidgets)\b') # Don't search for Qt.
fails = []
for fn in files:
    if g.shortFileName(fn) in exclude:
        continue
    with open(fn, 'r') as f:
        s = f.read()
    if not re.search(pattern, s):
        continue
    if not re.search(r"g\.assertUi\(['\"]qt['\"]\)", s):
        fails.append(fn)
if fails:
    g.printObj(fails)
    assert False, f"{len(fails)} failures"
#@+node:ekr.20140217055617.4230: *3* @test c.theScriptingController.atScriptNodes
# This must be true even though @bool scriptingatscriptnodes is True in this file.
if hasattr(c,'theScriptingController'):
    # mod_scripting may be disabled when running tests externally.
    val = g.app.config.valueInMyLeoSettings('scripting-at-script-nodes')
    assert c.theScriptingController.atScriptNodes in (val, None, False), (val, c.theScriptingController.atScriptNodes)
#@+node:ekr.20100131171342.5501: *3* @test zz end of plugins unit tests
# Print does not work: it is redirected.
g.pr('\nEnd of plugins unit tests')
#@+node:ekr.20140822063016.4474: ** @test zzz force a quit
import sys
if not g.app.inBridge:
    g.app.forceShutdown()
        # Now works with curses gui.
#@-all
#@-leo
