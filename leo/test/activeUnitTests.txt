#@+leo-ver=5-thin
#@+node:edward.20160314170027.56: * @file activeUnitTests.txt
# All the following should pass when run locally (Alt-4).
#@@language python
#@+all
#@+node:ekr.20071113194858: ** Organized by file
# All the following files have problems when run with Alt-5.
#@+node:ekr.20190608143232.1: *3* commands/checkerCommands.py
#@+node:ekr.20190608071309.1: *4* @test regex for pylint
import re
import leo.commands.checkerCommands as checkerCommands
x = checkerCommands.PylintCommand(c)
pattern = re.compile(x.link_pattern)
table = (
    r'c:\test\pylint_links_test2.py:5:4: R1705: Unnecessary "else" after "return" (no-else-return)',
    r'c:\test\pylint_links_test.py:6:3: C1801: Do not use `len(SEQUENCE)` to determine if a sequence is empty (len-as-condition)',
    # A particularly good test, because it has two parenthesized expressions.
)
for message in table:
    # Windows style file names.
    m = pattern.match(message)
    assert m, message
    # Linux style file names.
    message = message.replace('\\', '/')
    m = pattern.match(message)
    assert m, message
#@+node:ekr.20100131171342.5506: *3* leoApp
#@+node:ekr.20100131171342.5507: *4* @test consistency of leoApp tables
@
language_delims_dict 
    # Keys are languages, values are 1,2 or 3-tuples of delims. 
language_extension_dict
    # Keys are languages, values are extensions.
extension_dict = {
    # Keys are extensions, values are languages.
@c

delims_d    = g.app.language_delims_dict
lang_d      = g.app.language_extension_dict
ext_d       = g.app.extension_dict

for lang in lang_d:
    ext = lang_d.get(lang)
    assert lang in delims_d,'fail 1: %s' % lang
    assert ext in ext_d,'fail 2: %s' % ext
for ext in ext_d:
    lang = ext_d.get(ext)
    assert lang in lang_d,'fail 3: %s' % lang
#@+node:ekr.20100131180007.5417: *4* @test lm.openAnyLeoFile
import zipfile
lm = g.app.loadManager

# Create a zip file for testing.
s = 'this is a test file'
testDir = g.os_path_join(g.app.loadDir,'..','test')
assert g.os_path_exists(testDir)
path = g.os_path_finalize_join(testDir,'testzip.zip')
theFile = zipfile.ZipFile(path,'w')
theFile.writestr('leo-zip-file',s)
theFile.close()

# Open the file, and use read (with no args) to get the contents.
theFile = lm.openAnyLeoFile(path)
assert theFile
s2 = theFile.read()
assert s == s2,'s:  %s\ns2: %s' % (repr(s),repr(s2))
#@+node:ekr.20100211110729.5389: *4* @test rfm.writeRecentFilesFileHelper
@first # -*- coding: utf-8 -*-
#
# On Windows, this works with or without the following line in sitecustomize.py
    # sys.setdefaultencoding('utf-8')
import os
fn ='ффф.leo'
g.app.recentFilesManager.writeRecentFilesFileHelper(fn)
assert g.os_path_exists(fn),'fail 1'
os.remove(fn)
assert not g.os_path_exists(fn),'fail 1'
#@+node:ekr.20150521123343.1: *3* leoBeautify
# These tests are now in leoAst.py.
#@+node:ekr.20111104171708.3843: *4* @test leoBeautify.CPrettyPrinter
import leo.core.leoBeautify as leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)

if 1: # test of indent.
    # import os ; os.system('cls')
    cpp.indent(p2)
if 0: # test of tokenize.
    aList = cpp.tokenize(p2.b)
    assert(p2.b == ''.join(aList))
#@+node:ekr.20111104171708.3844: *5* c tokenize test
@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos->can_break;
        }

        parser_state_tos->last_saw_nl = false;
        parser_state_tos->can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col > 0) &&
            (buf_break != NULL) &&
            ( ( (parser_state_tos->last_token == ident) &&
                (type_code != comma) &&
                (type_code != semicolon) &&
                (type_code != newline) &&
                (type_code != form_feed) &&
                (type_code != rparen) &&
                (type_code != struct_delim)) ||
              ( (parser_state_tos->last_token == rparen) &&
                (type_code != comma) &&
                (type_code != rparen) ) ) &&
            (output_line_length () > settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp > 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos->procname[0] != '\0') &&
                  parser_state_tos->in_parameter_declaration) ||
                 (parser_state_tos->classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&type_code, &force_nl, &flushed_nl, &last_else, &is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &paren_target);
            }

            if (parser_state_tos->tos > 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines > 0 && code_lines > 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            if (force_nl &&
                (type_code != semicolon) &&
                ( (type_code != lbrace) ||
                  (!parser_state_tos->in_decl && !settings.btype_2) ||
                  (parser_state_tos->in_decl && !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos->last_token == rbrace)))
            {
                if (settings.verbose && !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &paren_target);
                parser_state_tos->want_blank = false;
                force_nl = false;
            }

            parser_state_tos->in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos->want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &&
                 (type_code != cplus_comment) &&
                 !(settings.break_function_decl_args &&
                   (parser_state_tos->last_token == comma)) &&
                 !( (parser_state_tos->last_token == comma) &&
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &scase, &force_nl, &sp_sw, &flushed_nl,
                         &hd_type, &dec_ind, &last_token_ends_sp, &file_exit_value,
                         can_break, &last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            parser_state_tos->last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col > 0) && (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) && (scase || (squest <= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) && (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &&
                 (output_line_length () > settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
#@+node:ekr.20110608135658.3377: *3* leoChapters
#@+node:ekr.20110608162543.3363: *4* @test chapter-create/remove & undo
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create/remove commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    cc.selectChapterByName('aaa',chaptersNode)
    cc.removeChapterByName('aaa')
    c.undoer.undo()
    assert cc.findChapterNode('aaa')
    cc.selectChapterByName('main',collapse=True)
else:
    self.skipTest('Can not be run locally')
#@+node:ekr.20110608162543.3365: *4* @test chapter-rename & undo
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create/remove commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    try:
        cc.selectChapterByName('aaa',chaptersNode)
        cc.renameChapterByName('bbb')
        cc.selectChapterByName('bbb',chaptersNode)
        cc.renameChapterByName('aaa')
        assert cc.findChapterNode('aaa'),'after undo'
    finally:
        cc.selectChapterByName('main',collapse=True)
else:
    self.skipTest('Can not be run locally')
#@+node:ekr.20110608181936.3368: *4* @test chapter-move/clone/copy-node-to
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('move/clone/copy commands no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    chaptersNode = cc.findChaptersNode()
    assert chaptersNode,'fail 0'
    chapterNode = (
        cc.findChapterNode('aaa') or
        cc.createChapterByName('aaa',p=None))
    table = (
        ('node a',cc.moveNodeToChapterHelper),
        ('node b',cc.copyNodeToChapterHelper),
        ('node c',cc.cloneNodeToChapterHelper),
    )
    # Initialze 
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    for h,unused_f in table:
        p2 = p.insertAsLastChild()
        p2.h = h
        p2.b = '# %s' % h
    try:
        cc.selectChapterByName('aaa')
        for h,f in table:
            p2 = g.findNodeInTree(c,p,h)
            assert p2,'fail 1'
            c.selectPosition(p2) # All helpers work on c.p.
            f('aaa')
            assert g.findNodeInTree(c,chapterNode,h),(
                'fail 2', chapterNode.h, h, f.__name__)
        assert not g.findNodeInTree(c,p,'node a')
        assert g.findNodeInTree(c,p,'node b')
        assert g.findNodeInTree(c,p,'node c')
    finally:
        if 1: # Restore the tree so activeUnitTests.txt does not change.
            while p.hasChildren():
                p.firstChild().doDelete(newNode=None)
            for h,f in table:
                p3 = g.findNodeInTree(c,chapterNode,h)
                if p3: p3.doDelete()
        cc.selectChapterByName('main',collapse=True)
        c.redraw()
else:
    self.skipTest('Can not be run locally')
#@+node:ekr.20160402043006.1: *5* node a
# node a
#@+node:ekr.20160402043006.2: *5* node b
# node b
#@+node:ekr.20160402043006.3: *5* node c
# node c
#@+node:ekr.20080503132221.1: *4* @test chapter-create-from-node
# cc will be None when unit tests run dynamically.
import leo.core.leoChapters as leoChapters
new_code = getattr(leoChapters, 'new_code', True)
cc = c.chapterController
if new_code:
    self.skipTest('create-from-node no longer exist.')
elif cc and not g.app.isExternalUnitTest:
    root = p.copy()
    # Init the children
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    child = p.insertAsNthChild(0)
    # c.setHeadString(child,'child') # Force the headline to update.
    child.h = 'child'
    child.b = '# child'
    # Kill the chapter so the test will not fail if run twice.
    chapter = cc.chaptersDict.get('new-chapter')
    if chapter:
        cc.removeChapterByName('new-chapter')
    try:
        c.selectPosition(child)
        c.chapterController.createChapterByName(
            'new-chapter',child,'Create Chapter From Node')
        if 0:
            c.undoer.undo()
            c.undoer.redo()
            c.undoer.undo()
            c.undoer.redo()
            c.undoer.undo() # Don't pollute future unit tests.
        else:
            c.redraw_now() # Required.
            chapterNode = cc.findChapterNode('new-chapter')
            assert chapterNode,'fail 1: %s' % (undoType)
            chapterNode.doDelete()
            c.redraw_now()
    finally:
        cc.selectChapterByName('main',collapse=True)
        if 1: # Do this so the activeUnitTests.txt does not change.
            while root.hasChildren():
                root.firstChild().doDelete(newNode=None)
        c.redraw_now()
else:
    self.skipTest('Can not be run locally')

#@+node:ekr.20090615053403.4876: *3* leoColorizer
#@+node:ekr.20090615053403.4877: *4* @test @comment after @language plain
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4878: *5* plain code
@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
continues */

More plain text.
#@+node:ekr.20170201143435.1: *4* @test bc.scanLanguageDirectives
@language python

if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import leo.core.leoColorizer as leoColorizer
wrapper = c.frame.body.wrapper
widget = c.frame.body.widget
x = leoColorizer.JEditColorizer(c, widget, wrapper)
tables = p.firstChild()
tables_s = tables.b
child = p.firstChild().next()
assert child.h == 'test-child'
grand = child.firstChild()
<< scanLanguageDirectives test tables >>
try:
    for i, data in enumerate(language_table):
        language, child_s, grand_s = data
        child.b = child_s
        grand.b = grand_s
        got = x.scanLanguageDirectives(grand)
        assert got == language, '%s expected %r, got %r child.b %r' % (
            i, language, got, child.b)
finally:
    tables.b = tables_s
#@+node:ekr.20170201143435.2: *5* << scanLanguageDirectives test tables >>
language_table = [
    ('python', '@language rest\n@language python\n', ''),
    ('rest', '@language rest', ''),
    ('python', '@language rest\n@language python\n', ''),
]
#@+node:ekr.20170201143435.3: *5* test-child
@language rest
@language python
#@+node:ekr.20170201143435.4: *6* test-grandchild
#@+node:ekr.20170201175441.1: *4* @test bc.useSyntaxColoring
@language python

if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')
import leo.core.leoColorizer as leoColorizer
wrapper = c.frame.body.wrapper
widget = c.frame.body.widget
x = leoColorizer.JEditColorizer(c, widget, wrapper)
tables = p.firstChild()
tables_s = tables.b
child = p.firstChild().next()
assert child.h == 'test-child'
grand = child.firstChild()
<< useSyntaxColoring test tables >>
try:
    for i, data in enumerate(language_table):
        expected, child_s, grand_s = data
        child.b = child_s
        grand.b = grand_s
        got = x.useSyntaxColoring(grand)
        assert got == expected, '%s expected %r, got %r child.b %r' % (
            i, expected, got, child.b)
finally:
    tables.b = tables_s
#@+node:ekr.20170201175441.2: *5* << useSyntaxColoring test tables >>
language_table = [
    (True, '', ''),
    # Ambiguous parent.
    (True, '@color \n@nocolor\n', ''),
    (True, '@nocolor \n@color\n', ''),
    # Unambiguous parent.
    (True, '@nocolor-node', ''), # Does not apply to descendants.
    (False, '@nocolor', ''),
    (False, '@killcolor', ''),
    #
    # Note: the following tests don't matter because
    # jedit.recolor ignores the self.enabled flag.
    # As a result, *all* color directives, including @nocolor-node,
    # Apply from the directive to the next color directive.
    #
    # Unambiguous child.
    (False, '', '@killcolor\n'),
    (True, '', '@color\n'),
    # @nocolor-node rules node.
    (False, '', '@nocolor-node\n'),
    (False, '', '@color\n@nocolor-node\n'),
    # Ambiguous node: defer to ancestors.
    (True, '', '@color\n@nocolor'),
    (True, '', '@nocolor\n@color'),
]
#@+node:ekr.20170201175441.3: *5* test-child
#@+node:ekr.20170201175441.4: *6* test-grandchild
@nocolor
@color
#@+node:ekr.20090615053403.4879: *4* @test colorizer Actionscript
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4880: *5* actionscript test
@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket
#@+node:ekr.20090615053403.4881: *4* @test colorizer C
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4882: *5* c code
@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number & flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include <hpc_ram.h>
#include <rlydef.h>
#@+node:ekr.20090615053403.4883: *4* @test colorizer C#
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4884: *5* c# code
@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield
#@+node:ekr.20090615053403.4885: *4* @test colorizer css
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4886: *5* css
@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside
#@+node:ekr.20090615053403.4887: *4* @test colorizer CWEB
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4888: *5* CWEB
@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section references are _valid_ in cweb comments!
<< section ref >>
<< missing ref >>
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
<< section ref >>
<< missing ref >>

\LaTeX and \c should not be colored.
if else, while, do // C keywords.
#@+node:ekr.20090615053403.4889: *6* << section ref >>
<< section def >>=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */
#@+node:ekr.20110521073115.3486: *4* @test colorizer cython
@language python

p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20110521073115.3490: *5* cython
@language cython

by cdef cimport cpdef ctypedef enum except?
extern gil include nogil property public
readonly struct union DEF IF ELIF ELSE
                    
NULL bint char dict double float int list
long object Py_ssize_t short size_t void

try:
    pass
except Exception:
    pass

#@+node:ekr.20090615053403.4890: *4* @test colorizer elisp
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4891: *5* elisp
@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while
#@+node:ekr.20090615053403.4892: *4* @test colorizer erlang
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4893: *5* erlang
@language erlang

halt()

-module()
#@+node:ekr.20090615053403.4894: *4* @test colorizer forth
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4895: *5* forth
@language forth

\ tiny demo of Leo forth syntax colouring

: some-forth-word ( x1 x2 -- x3 ) \ blue :, black/bold some-forth-word
   label: y  \ blue label:
   asm[ s" some string" type ]asm cr
   asm[ abc ]asm
   a
   s" abc "
   s" abc"
   a
   tty" abc "
   lcd2" abc "
   until

@ test
@c

{ abc }

a b @ c

asm[ abc ]asm

.( ab ) \ a string

: foo [ .s ] ;

   [ a b c
   x y z]
;
#@+node:ekr.20090615053403.4896: *4* @test colorizer HTML string bug
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4897: *5* html
@language html

b = "cd"
d
#@+node:ekr.20090615053403.4898: *4* @test colorizer HTML1
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4899: *5* html
@language html

<HTML>
<!-- Author: Edward K. Ream, edream@tds.net -->
<HEAD>
  <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
  <TITLE> Leo's Home Page </TITLE>
  <META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages.">
  <META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE">
</HEAD>
<!-- Last Modified: May 12, 2002 -->
<BODY BGCOLOR="#fffbdc">

<H1 ALIGN=CENTER><a NAME="top"></a><IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"><IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"><a href="leo_TOC.html#top"><IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"></a> &nbsp;</H1>

<H1 ALIGN=CENTER> Leo's Home Page</H1>

<p align="center"><a href="http://www.python.org/"><img border="0" src="PythonPowered.gif" width="110" height="44"> </a> <A HREF="http://sourceforge.net/"><IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"></A>&nbsp;&nbsp;&nbsp;
<A HREF="http://sourceforge.net/project/?group_id=3458">Leo at SourceForge</A>&nbsp;&nbsp;
<a href="icons.html"><img border="0" src="LeoCodeGray.gif" width="77" height="42"></a>&nbsp;&nbsp;
<a href="icons.html"><img border="0" src="LeoProse.gif" width="81" height="42"></a>&nbsp;&nbsp;&nbsp;&nbsp;

<H3><A NAME="anchor127554"></A>Summary</H3>

<UL>
  <LI>Leo is a <i> programmer's editor</i>  and a flexible <i>browser</i> for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  <LI>Leo is an <i>outlining editor</i>. Outlines clarify the big picture while
    providing unlimited space for details.
  <LI>Leo
    is a <a HREF="http://www.literateprogramming.com/"><i>literate
    programming</i></a> tool, compatible with <A HREF="http://www.eecs.harvard.edu/~nr/noweb/">noweb</A>
    and <a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html">CWEB</a>.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  <LI>Leo is also a <i>data organizer</i>. A single Leo outline can generate complex
    data spanning many different files.&nbsp; Leo has been used to manage web sites.
  <LI>Leo is a <i> project manager</i>. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  <LI>Leo is fully <i> scriptable</i> using <A HREF="http://www.python.org/">Python</A>
  and saves its files in <A HREF="http://www.w3.org/XML/">XML</A> format.
  <LI>Leo is <i>portable</i>.&nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting <A HREF="http://www.python.org/">Python</A>
    and <a href="http://tcl.activestate.com/">Tk/tcl</a>, including Windows,
    Linux and MacOS X.&nbsp; Leo.exe runs on any Windows platform.
  <LI>Leo is <a href="http://www.opensource.org/"> <i> Open Software</i></a>, distributed under
    the <a href="http://www.python.org/doc/Copyright.html"> Python License</a>.
</UL>

<H3>More Information and downloads</H3>

<ul>
  <LI>An excellent <a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm">online
    tutorial</a> and <A HREF="http://www.jserv.com/jk_orr/xml/leo.htm">Leo resource
  page</A>, both written by <a href="http://www.jserv.com/jk_orr">Joe Orr</a>.
  <LI>My brother's <a href="SpeedReam.html">slashdot
    article about Leo</a>, the best description about why Leo is special.
  <LI><A HREF="testimonials.html#anchor104391">What people are saying about Leo</A>
  <LI><A HREF="leo_TOC.html#anchor964914">Complete users guide</A>
    and
    <A HREF="intro.html#anchor887874">tutorial introduction</A>  with
  screen shots.
  <li><a href="FAQ.html">FAQ</a> and <a href="http://sourceforge.net/forum/?group_id=3458">help and discussion
    forums</a>, preferable to <A HREF="mailto:edream@tds.net">email</A> so others may join
    in.</li>
  <li><a href="icons.html">Icons</a> for bragging about Leo.</li>
</ul>

<a href="http://sourceforge.net/project/showfiles.php?group_id=3458">Download
    Leo</a> from <A HREF="http://sourceforge.net/project/?group_id=3458">Leo's SourceForge
site</A>.

<P ALIGN=left>Leo's author is <A HREF="http://personalpages.tds.net/~edream/index.html">Edward
  K. Ream</A> email: <A HREF="mailto:edream@tds.net">edream@tds.net</A> voice: (608) 231-0766

<HR ALIGN=LEFT>

<p align="center">

<IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"><IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"><a HREF="leo_TOC.html"><IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3">

</BODY>
</HTML>
#@+node:ekr.20090615053403.4900: *4* @test colorizer HTML2
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4901: *5* html
@language html

<? xml version="1.0">
<!-- test -->
<project name="Converter" default="dist">
</project>"""
#@+node:ekr.20090615053403.4902: *4* @test colorizer Java
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4903: *5* html
@ doc part
@c

@language java /* Colored by match_leo_keyword: tag = leoKeyword. */

@whatever /* Colored by java match_following rule: tag = keyword4. */

/** A javadoc: tag = comment3 */

/** <!-- comment --> tag = comment1. */

/** @see tag = label */
#@+node:ekr.20090615053403.4904: *4* @test colorizer LaTex
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4905: *5* LaTex
@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}

The following should be colored:

\documentclass{report}

The following 2-letter words should be colored, regardless of what follows:

\(\)\{\}\@
\(abc\)abc\{abc\}abc\@abc
#@+node:ekr.20090615053403.4906: *4* @test colorizer lisp
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4907: *5* lisp
@language lisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while
#@+node:ekr.20101020123501.6005: *4* @test colorizer objective-c
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20101020123501.6006: *5* objective-c
@language objective_c

@interface Application
    -(void) init;
    -(void) showMessage;
@end

@implementation Application 
    -(id) init {
        if (self = [super init]) {
            NSLog(@"Init ok");
            return self;
        }
        return nil;
    }
    -(void) showMessage {
        NSLog(@"Hello there");
    }
@end

@"Hello there"

,@interface
, @interface
the @interface

// By the way, I have noticed that such kind of words in doxygen block
// are highlighted properly, but they are labels here, not keywords1 as in my case.
/**
@var test
@todo
*/
#@+node:ekr.20090615053403.4908: *4* @test colorizer perl
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4909: *5* perl
@language perl

# From a perl tutorial.

print 'Hello world.';		# Print a message

$a = $b;	# Assign $b to $a

@food  = ("apples", "pears", "eels");

$grub = pop(@food);	# Now $grub = "eels"

$#food

@lines = <INFO>;

#!/usr/local/bin/perl
print "Password? ";		# Ask for input
$a = <STDIN>;			# Get input
chop $a;			# Remove the newline at end
while ($a ne "fred")		# While input is wrong...
{
    print "sorry. Again? ";	# Ask again
    $a = <STDIN>;		# Get input again
    chop $a;			# Chop off newline again
}

if ($sentence =~ /under/)
{
	print "We're talking about rugby\\n";
}

$sentence =~ s/london/London/

$_ = "Capes:Geoff::Shot putter:::Big Avenue";
@personal = split(/:/);

foreach $age (values %ages)
{
	print "Somebody is $age\\n";
}

&mysubroutine;		# Call the subroutine
&mysubroutine($_);	# Call it with a parameter
&mysubroutine(1+2, $_);	# Call it with two parameters

sub inside
{
	local($a, $b);			# Make local variables
	($a, $b) = ($_[0], $_[1]);	# Assign values
	$a =~ s/ //g;			# Strip spaces from
	$b =~ s/ //g;			#   local variables
	($a =~ /$b/ || $b =~ /$a/);	# Is $b inside $a
					#   or $a inside $b?
}
#@+node:ekr.20090615053403.4910: *4* @test colorizer PHP
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4911: *5* PHP
@language php
@ doc
This is a doc part.
@c

and or
array
array()
/* Multi-line comment
*/
this is a test.
__CLASS__
<?php and or array() ?>
<?PHP and or array() ?>
#@+node:ekr.20090615053403.4912: *4* @test colorizer plsql
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4913: *5* plsql
@language plsql

"a string"
-- reserved keywords
ABORT,
abort,
ACceSS,
access,
add,
all,
allocate,
alter,
analyze,
and,
any,
archive,
archivelog,
array,
arraylen,
as,
asc,
assert,
assign,
at,
audit,
authorization,
avg,
backup,
base_table,
become,
before,
begin,
between,
binary_integer,
block,
body,
boolean,
by,
cache,
cancel,
cascade,
case,
change,
char,
char_base,
character,
check,
checkpoint,
close,
cluster,
clusters,
cobol,
colauth,
column,
columns,
comment,
commit,
compile,
compress,
connect,
constant,
constraint,
constraints,
contents,
continue,
controlfile,
count,
crash,
create,
current,
currval,
cursor,
cycle,
data_base,
database,
datafile,
date,
dba,
debugoff,
debugon,
dec,
decimal,
declare,
default,
definition,
delay,
delete,
delta,
desc,
digits,
disable,
dismount,
dispose,
distinct,
distinct,
do,
double,
drop,
drop,
dump,
each,
else,
else,
elsif,
enable,
end,
end,
entry,
escape,
events,
except,
exception,
exception_init,
exceptions,
exclusive,
exec,
execute,
exists,
exists,
exit,
explain,
extent,
externally,
false,
fetch,
fetch,
file,
float,
float,
flush,
for,
for,
force,
foreign,
form,
fortran,
found,
freelist,
freelists,
from,
from,
function,
generic,
go,
goto,
grant,
group,
groups,
having,
identified,
if,
immediate,
in,
including,
increment,
index,
indexes,
indicator,
initial,
initrans,
insert,
instance,
int,
integer,
intersect,
into,
is,
key,
language,
layer,
level,
like,
limited,
link,
lists,
lock,
logfile,
long,
loop,
manage,
manual,
max,
maxdatafiles,
maxextents,
maxinstances,
maxlogfiles,
maxloghistory,
maxlogmembers,
maxtrans,
maxvalue,
min,
minextents,
minus,
minvalue,
mlslabel,
mod,
mode,
modify,
module,
mount,
natural,
new,
new,
next,
nextval,
noarchivelog,
noaudit,
nocache,
nocompress,
nocycle,
nomaxvalue,
nominvalue,
none,
noorder,
noresetlogs,
normal,
nosort,
not,
notfound,
nowait,
null,
number,
number_base,
numeric,
of,
off,
offline,
old,
on,
online,
only,
open,
open,
optimal,
option,
or,
order,
others,
out,
own,
package,
package,
parallel,
partition,
pctfree,
pctincrease,
pctused,
plan,
pli,
positive,
pragma,
precision,
primary,
prior,
private,
private,
privileges,
procedure,
procedure,
profile,
public,
quota,
raise,
range,
raw,
read,
real,
record,
recover,
references,
referencing,
release,
remr,
rename,
resetlogs,
resource,
restricted,
return,
reuse,
reverse,
revoke,
role,
roles,
rollback,
row,
rowid,
rowlabel,
rownum,
rows,
rowtype,
run,
savepoint,
schema,
scn,
section,
segment,
select,
select,
separate,
sequence,
session,
set,
set,
share,
shared,
size,
size,
smallint,
smallint,
snapshot,
some,
sort,
space,
sql,
sqlbuf,
sqlcode,
sqlerrm,
sqlerror,
sqlstate,
start,
start,
statement,
statement_id,
statistics,
stddev,
stop,
storage,
subtype,
successful,
sum,
sum,
switch,
synonym,
sysdate,
system,
tabauth,
table,
tables,
tables,
tablespace,
task,
temporary,
terminate,
then,
thread,
time,
to,
tracing,
transaction,
trigger,
triggers,
true,
truncate,
type,
uid,
under,
union,
unique,
unlimited,
until,
update,
use,
user,
using,
validate,
values,
varchar,
varchar2,
variance,
view,
views,
when,
whenever,
where,
while,
with,
work,
write,
xor
#@+node:ekr.20090615053403.4914: *4* @test colorizer python.xml (jEdit)
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4915: *5* python.xml
@language html

<?xml version="1.0"?>

<!DOCTYPE MODE SYSTEM "xmode.dtd">
<< remarks >>

<MODE>
    <PROPS>
        <PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" />
        <PROPERTY NAME="lineComment" VALUE="#" />
    </PROPS>
    <RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE">
        << comments >>
        << literals >>
        << operators >>
        <MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE">(</MARK_PREVIOUS>
        << keywords >>
    </RULES>
</MODE>
#@+node:ekr.20090615053403.4916: *6* << remarks >>
<!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by -->
<!-- Jonathan Revusky -->

<!-- Modified 19-Jul-00 by Ivan Frohne to: -->
<!--  (a) implement 'indentOnEnter'; -->
<!--  (b) indent next line automatically after control structures followed -->
<!--	  by ':'; -->
<!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; -->
<!--  (d) add TYPE FUNCTION identified by a following '(' -->
<!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); -->
<!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and -->
<!--  (g) add all builtin functions, builtin exceptions, -->
<!--	  builtin type methods, File object methods, and special type -->
<!--	  attributes as TYPE KEYWORD3. -->
#@+node:ekr.20090615053403.4917: *6* << comments >>
<!-- Comment -->
<EOL_SPAN TYPE="COMMENT1">#</EOL_SPAN>

<!-- Triple-quotes -->
<SPAN TYPE="LITERAL2">
    <BEGIN>"""</BEGIN>
    <END>"""</END>
</SPAN>

<SPAN TYPE="LITERAL2">
    <BEGIN>'''</BEGIN>
    <END>'''</END>
</SPAN>
#@+node:ekr.20090615053403.4918: *6* << literals >>
<!-- Standard literals -->
<SPAN TYPE="LITERAL1">
    <BEGIN>"</BEGIN>
    <END>"</END>
</SPAN>

<SPAN TYPE="LITERAL1">
    <BEGIN>'</BEGIN>
    <END>'</END>
</SPAN>
#@+node:ekr.20090615053403.4919: *6* << operators >>
<SEQ TYPE="OPERATOR">=</SEQ>
<SEQ TYPE="OPERATOR">!</SEQ>
<SEQ TYPE="OPERATOR">&gt;=</SEQ>
<SEQ TYPE="OPERATOR">&lt;=</SEQ>
<SEQ TYPE="OPERATOR">+</SEQ>
<SEQ TYPE="OPERATOR">-</SEQ>
<SEQ TYPE="OPERATOR">/</SEQ>
<SEQ TYPE="OPERATOR">*</SEQ>
<SEQ TYPE="OPERATOR">&gt;</SEQ>
<SEQ TYPE="OPERATOR">&lt;</SEQ>
<SEQ TYPE="OPERATOR">%</SEQ>
<SEQ TYPE="OPERATOR">&amp;</SEQ>
<SEQ TYPE="OPERATOR">|</SEQ>
<SEQ TYPE="OPERATOR">^</SEQ>
<SEQ TYPE="OPERATOR">~</SEQ>
#@+node:ekr.20090615053403.4920: *6* << keywords >>
<KEYWORDS>
    << reserved words >>
    << builtins >>
    << exceptions >>
    << types >>
</KEYWORDS>
#@+node:ekr.20090615053403.4921: *7* << reserved words >>
<!--  Reserved Words  -->
<KEYWORD1>and</KEYWORD1>
<KEYWORD1>as</KEYWORD1>
<KEYWORD1>assert</KEYWORD1>
<KEYWORD1>break</KEYWORD1>
<KEYWORD1>class</KEYWORD1>
<KEYWORD1>continue</KEYWORD1>
<KEYWORD1>def</KEYWORD1>
<KEYWORD1>del</KEYWORD1>
<KEYWORD1>elif</KEYWORD1>
<KEYWORD1>else</KEYWORD1>
<KEYWORD1>except</KEYWORD1>
<KEYWORD1>exec</KEYWORD1>
<KEYWORD1>finally</KEYWORD1>
<KEYWORD1>for</KEYWORD1>
<KEYWORD1>from</KEYWORD1>
<KEYWORD1>global</KEYWORD1>
<KEYWORD1>if</KEYWORD1>
<KEYWORD1>import</KEYWORD1>
<KEYWORD1>in</KEYWORD1>
<KEYWORD1>is</KEYWORD1>
<KEYWORD1>lambda</KEYWORD1>
<KEYWORD1>not</KEYWORD1>
<KEYWORD1>or</KEYWORD1>
<KEYWORD1>pass</KEYWORD1>
<KEYWORD1>print</KEYWORD1>
<KEYWORD1>raise</KEYWORD1>
<KEYWORD1>return</KEYWORD1>
<KEYWORD1>try</KEYWORD1>
<KEYWORD1>while</KEYWORD1>
<KEYWORD1>yield</KEYWORD1>
#@+node:ekr.20090615053403.4922: *7* << builtins >>
<!-- builtins -->
<KEYWORD2>abs</KEYWORD2>
<KEYWORD2>apply</KEYWORD2>
<KEYWORD2>bool</KEYWORD2>
<KEYWORD2>buffer</KEYWORD2>
<KEYWORD2>callable</KEYWORD2>
<KEYWORD2>chr</KEYWORD2>
<KEYWORD2>classmethod</KEYWORD2>
<KEYWORD2>cmp</KEYWORD2>
<KEYWORD2>coerce</KEYWORD2>
<KEYWORD2>compile</KEYWORD2>
<KEYWORD2>complex</KEYWORD2>
<KEYWORD2>delattr</KEYWORD2>
<KEYWORD2>dict</KEYWORD2>
<KEYWORD2>dir</KEYWORD2>
<KEYWORD2>divmod</KEYWORD2>
<KEYWORD2>eval</KEYWORD2>
<KEYWORD2>execfile</KEYWORD2>
<KEYWORD2>file</KEYWORD2>
<KEYWORD2>filter</KEYWORD2>
<KEYWORD2>float</KEYWORD2>
<KEYWORD2>getattr</KEYWORD2>
<KEYWORD2>globals</KEYWORD2>
<KEYWORD2>hasattr</KEYWORD2>
<KEYWORD2>hash</KEYWORD2>
<KEYWORD2>hex</KEYWORD2>
<KEYWORD2>id</KEYWORD2>
<KEYWORD2>input</KEYWORD2>
<KEYWORD2>int</KEYWORD2>
<KEYWORD2>intern</KEYWORD2>
<KEYWORD2>isinstance</KEYWORD2>
<KEYWORD2>issubclass</KEYWORD2>
<KEYWORD2>iter</KEYWORD2>
<KEYWORD2>len</KEYWORD2>
<KEYWORD2>list</KEYWORD2>
<KEYWORD2>locals</KEYWORD2>
<KEYWORD2>long</KEYWORD2>
<KEYWORD2>map</KEYWORD2>
<KEYWORD2>max</KEYWORD2>
<KEYWORD2>min</KEYWORD2>
<KEYWORD2>object</KEYWORD2>
<KEYWORD2>oct</KEYWORD2>
<KEYWORD2>open</KEYWORD2>
<KEYWORD2>ord</KEYWORD2>
<KEYWORD2>pow</KEYWORD2>
<KEYWORD2>property</KEYWORD2>
<KEYWORD2>range</KEYWORD2>
<KEYWORD2>raw_input</KEYWORD2>
<KEYWORD2>reduce</KEYWORD2>
<KEYWORD2>reload</KEYWORD2>
<KEYWORD2>repr</KEYWORD2>
<KEYWORD2>round</KEYWORD2>
<KEYWORD2>setattr</KEYWORD2>
<KEYWORD2>slice</KEYWORD2>
<KEYWORD2>staticmethod</KEYWORD2>
<KEYWORD2>str</KEYWORD2>
<KEYWORD2>super</KEYWORD2>
<KEYWORD2>tuple</KEYWORD2>
<KEYWORD2>type</KEYWORD2>
<KEYWORD2>unichr</KEYWORD2>
<KEYWORD2>unicode</KEYWORD2>
<KEYWORD2>vars</KEYWORD2>
<KEYWORD2>xrange</KEYWORD2>
<KEYWORD2>zip</KEYWORD2>
#@+node:ekr.20090615053403.4923: *7* << exceptions >>
<!-- exceptions -->
<KEYWORD3>ArithmeticError</KEYWORD3>
<KEYWORD3>AssertionError</KEYWORD3>
<KEYWORD3>AttributeError</KEYWORD3>
<KEYWORD3>DeprecationWarning</KEYWORD3>
<KEYWORD3>EOFError</KEYWORD3>
<KEYWORD3>EnvironmentError</KEYWORD3>
<KEYWORD3>Exception</KEYWORD3>
<KEYWORD3>FloatingPointError</KEYWORD3>
<KEYWORD3>IOError</KEYWORD3>
<KEYWORD3>ImportError</KEYWORD3>
<KEYWORD3>IndentationError</KEYWORD3>
<KEYWORD3>IndexError</KEYWORD3>
<KEYWORD3>KeyError</KEYWORD3>
<KEYWORD3>KeyboardInterrupt</KEYWORD3>
<KEYWORD3>LookupError</KEYWORD3>
<KEYWORD3>MemoryError</KEYWORD3>
<KEYWORD3>NameError</KEYWORD3>
<KEYWORD3>NotImplemented</KEYWORD3>
<KEYWORD3>NotImplementedError</KEYWORD3>
<KEYWORD3>OSError</KEYWORD3>
<KEYWORD3>OverflowError</KEYWORD3>
<KEYWORD3>OverflowWarning</KEYWORD3>
<KEYWORD3>ReferenceError</KEYWORD3>
<KEYWORD3>RuntimeError</KEYWORD3>
<KEYWORD3>RuntimeWarning</KEYWORD3>
<KEYWORD3>StandardError</KEYWORD3>
<KEYWORD3>StopIteration</KEYWORD3>
<KEYWORD3>SyntaxError</KEYWORD3>
<KEYWORD3>SyntaxWarning</KEYWORD3>
<KEYWORD3>SystemError</KEYWORD3>
<KEYWORD3>SystemExit</KEYWORD3>
<KEYWORD3>TabError</KEYWORD3>
<KEYWORD3>TypeError</KEYWORD3>
<KEYWORD3>UnboundLocalError</KEYWORD3>
<KEYWORD3>UnicodeError</KEYWORD3>
<KEYWORD3>UserWarning</KEYWORD3>
<KEYWORD3>ValueError</KEYWORD3>
<KEYWORD3>Warning</KEYWORD3>
<KEYWORD3>WindowsError</KEYWORD3>
<KEYWORD3>ZeroDivisionError</KEYWORD3>
#@+node:ekr.20090615053403.4924: *7* << types >>
<!-- types (from types module) -->
<KEYWORD3>BufferType</KEYWORD3>
<KEYWORD3>BuiltinFunctionType</KEYWORD3>
<KEYWORD3>BuiltinMethodType</KEYWORD3>
<KEYWORD3>ClassType</KEYWORD3>
<KEYWORD3>CodeType</KEYWORD3>
<KEYWORD3>ComplexType</KEYWORD3>
<KEYWORD3>DictProxyType</KEYWORD3>
<KEYWORD3>DictType</KEYWORD3>
<KEYWORD3>DictionaryType</KEYWORD3>
<KEYWORD3>EllipsisType</KEYWORD3>
<KEYWORD3>FileType</KEYWORD3>
<KEYWORD3>FloatType</KEYWORD3>
<KEYWORD3>FrameType</KEYWORD3>
<KEYWORD3>FunctionType</KEYWORD3>
<KEYWORD3>GeneratorType</KEYWORD3>
<KEYWORD3>InstanceType</KEYWORD3>
<KEYWORD3>IntType</KEYWORD3>
<KEYWORD3>LambdaType</KEYWORD3>
<KEYWORD3>ListType</KEYWORD3>
<KEYWORD3>LongType</KEYWORD3>
<KEYWORD3>MethodType</KEYWORD3>
<KEYWORD3>ModuleType</KEYWORD3>
<KEYWORD3>NoneType</KEYWORD3>
<KEYWORD3>ObjectType</KEYWORD3>
<KEYWORD3>SliceType</KEYWORD3>
<KEYWORD3>StringType</KEYWORD3>
<KEYWORD3>StringTypes</KEYWORD3>
<KEYWORD3>TracebackType</KEYWORD3>
<KEYWORD3>TupleType</KEYWORD3>
<KEYWORD3>TypeType</KEYWORD3>
<KEYWORD3>UnboundMethodType</KEYWORD3>
<KEYWORD3>UnicodeType</KEYWORD3>
<KEYWORD3>XRangeType</KEYWORD3>

<KEYWORD3>False</KEYWORD3>
<KEYWORD3>None</KEYWORD3>
<KEYWORD3>True</KEYWORD3>

<KEYWORD3>__abs__</KEYWORD3>
<KEYWORD3>__add__</KEYWORD3>
<KEYWORD3>__all__</KEYWORD3>
<KEYWORD3>__author__</KEYWORD3>
<KEYWORD3>__bases__</KEYWORD3>
<KEYWORD3>__builtins__</KEYWORD3>
<KEYWORD3>__call__</KEYWORD3>
<KEYWORD3>__class__</KEYWORD3>
<KEYWORD3>__cmp__</KEYWORD3>
<KEYWORD3>__coerce__</KEYWORD3>
<KEYWORD3>__contains__</KEYWORD3>
<KEYWORD3>__debug__</KEYWORD3>
<KEYWORD3>__del__</KEYWORD3>
<KEYWORD3>__delattr__</KEYWORD3>
<KEYWORD3>__delitem__</KEYWORD3>
<KEYWORD3>__delslice__</KEYWORD3>
<KEYWORD3>__dict__</KEYWORD3>
<KEYWORD3>__div__</KEYWORD3>
<KEYWORD3>__divmod__</KEYWORD3>
<KEYWORD3>__doc__</KEYWORD3>
<KEYWORD3>__eq__</KEYWORD3>
<KEYWORD3>__file__</KEYWORD3>
<KEYWORD3>__float__</KEYWORD3>
<KEYWORD3>__floordiv__</KEYWORD3>
<KEYWORD3>__future__</KEYWORD3>
<KEYWORD3>__ge__</KEYWORD3>
<KEYWORD3>__getattr__</KEYWORD3>
<KEYWORD3>__getattribute__</KEYWORD3>
<KEYWORD3>__getitem__</KEYWORD3>
<KEYWORD3>__getslice__</KEYWORD3>
<KEYWORD3>__gt__</KEYWORD3>
<KEYWORD3>__hash__</KEYWORD3>
<KEYWORD3>__hex__</KEYWORD3>
<KEYWORD3>__iadd__</KEYWORD3>
<KEYWORD3>__import__</KEYWORD3>
<KEYWORD3>__imul__</KEYWORD3>
<KEYWORD3>__init__</KEYWORD3>
<KEYWORD3>__int__</KEYWORD3>
<KEYWORD3>__invert__</KEYWORD3>
<KEYWORD3>__iter__</KEYWORD3>
<KEYWORD3>__le__</KEYWORD3>
<KEYWORD3>__len__</KEYWORD3>
<KEYWORD3>__long__</KEYWORD3>
<KEYWORD3>__lshift__</KEYWORD3>
<KEYWORD3>__lt__</KEYWORD3>
<KEYWORD3>__members__</KEYWORD3>
<KEYWORD3>__metaclass__</KEYWORD3>
<KEYWORD3>__mod__</KEYWORD3>
<KEYWORD3>__mro__</KEYWORD3>
<KEYWORD3>__mul__</KEYWORD3>
<KEYWORD3>__name__</KEYWORD3>
<KEYWORD3>__ne__</KEYWORD3>
<KEYWORD3>__neg__</KEYWORD3>
<KEYWORD3>__new__</KEYWORD3>
<KEYWORD3>__nonzero__</KEYWORD3>
<KEYWORD3>__oct__</KEYWORD3>
<KEYWORD3>__or__</KEYWORD3>
<KEYWORD3>__path__</KEYWORD3>
<KEYWORD3>__pos__</KEYWORD3>
<KEYWORD3>__pow__</KEYWORD3>
<KEYWORD3>__radd__</KEYWORD3>
<KEYWORD3>__rdiv__</KEYWORD3>
<KEYWORD3>__rdivmod__</KEYWORD3>
<KEYWORD3>__reduce__</KEYWORD3>
<KEYWORD3>__repr__</KEYWORD3>
<KEYWORD3>__rfloordiv__</KEYWORD3>
<KEYWORD3>__rlshift__</KEYWORD3>
<KEYWORD3>__rmod__</KEYWORD3>
<KEYWORD3>__rmul__</KEYWORD3>
<KEYWORD3>__ror__</KEYWORD3>
<KEYWORD3>__rpow__</KEYWORD3>
<KEYWORD3>__rrshift__</KEYWORD3>
<KEYWORD3>__rsub__</KEYWORD3>
<KEYWORD3>__rtruediv__</KEYWORD3>
<KEYWORD3>__rxor__</KEYWORD3>
<KEYWORD3>__setattr__</KEYWORD3>
<KEYWORD3>__setitem__</KEYWORD3>
<KEYWORD3>__setslice__</KEYWORD3>
<KEYWORD3>__self__</KEYWORD3>
<KEYWORD3>__slots__</KEYWORD3>
<KEYWORD3>__str__</KEYWORD3>
<KEYWORD3>__sub__</KEYWORD3>
<KEYWORD3>__truediv__</KEYWORD3>
<KEYWORD3>__version__</KEYWORD3>
<KEYWORD3>__xor__</KEYWORD3>
#@+node:ekr.20090615053403.4925: *4* @test colorizer Python1
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4926: *5* python
@language python

int
float
dict
#@+node:ekr.20090615053403.4927: *4* @test colorizer Python2
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4928: *5* python
"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""

def copyTree(self,root):

    c = self
    # Create the root VNode.
    result = v = leoNodes.VNode(c)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v = leoNodes.VNode(c)
        v = v.threadNext()
    return result
#@+node:ekr.20090615053403.4929: *4* @test colorizer r
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4930: *5* r
@language r

x <- rnorm(10) 

vv <- function(z) return(z) 

def python_funct(uu): 
return uu
#@+node:ekr.20090615053403.4931: *4* @test colorizer rapidq
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4932: *5* rapidq
' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR
#@+node:ekr.20090615053403.4933: *4* @test colorizer Rebol
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4934: *5* Rebol
@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?
#@+node:ekr.20090615053403.4935: *4* @test colorizer rest
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4936: *5* rest
@language rest

@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

. Links used in this document...

.. _`Pmw`:                  http://pmw.sourceforge.net/
.. _run:                    `Running Leo`_

.. WARNING: image targets may not have upper case letters!

.. |back| image:: arrow_lt.gif
    :target: FAQ.html

.. |leo| image:: leo.gif
    :target: front.html

.. |next| image:: arrow_rt.gif
    :target: intro.html

|back| |leo| |next|

###########################
Chapter 1: Installing Leo
###########################

This chapter tells how to install and run Leo.

**Important**:

If you have *any* problems installing Leo,
please ask for help on Leo's help forum:

.. contents::

**Windows**
    If you have `associated .leo files with Leo`_ you may run Leo by double-clicking any .leo file.
    You can also use a batch file.
    Put the following .bat file in c:\\Windows::

        cd c:\prog\LeoCVS\leo
        c:\python22\python c:\prog\LeoCVS\leo\leo.py %1

-   Download the latest version of Leo from `Leo's download page`_.

-   In Windows 2K or XP, go to ``Start->Settings->Control panel``, open the ``Folder Options`` tab.

    **Warning**: When building Tcl on Linux, do **not** specify
    "--enable-threads".
    Only use Tcl with the default "threads not enabled" case.

-------------

|back| |leo| |next|
#@+node:ekr.20110529215703.3494: *4* @test colorizer scala
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20110529215703.3495: *5* scala
@language scala

/* A comment */

object HelloWorld {
    def main(args: Array[String]) {
      println("Hello, world!")
    }
  }
#@+node:ekr.20090615053403.4937: *4* @test colorizer shell
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4938: *5* shell
# New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait
#@+node:ekr.20090615053403.4939: *4* @test colorizer shellscript
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4940: *5* shellscript
@language shellscript

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait
#@+node:ekr.20090615053403.4941: *4* @test colorizer tex.xml (jEdit)
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4942: *5* tex.xml
@language html

<!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ -->

<?xml version="1.0"?>

<!DOCTYPE MODE SYSTEM "xmode.dtd">

<MODE>
    <PROPS>
        <PROPERTY NAME="lineComment" VALUE="%" />
    </PROPS>

    <RULES>
        << general rules >>
    </RULES>

    <RULES SET="MATH" DEFAULT="MARKUP">
        << math rules >>
    </RULES>
</MODE>
#@+node:ekr.20090615053403.4943: *6* << general rules >>
<!-- $$...$$ -->
<SPAN TYPE="MARKUP" DELEGATE="MATH">
    <BEGIN>$$</BEGIN>
    <END>$$</END>
</SPAN>

<!-- $...$ -->
<SPAN TYPE="MARKUP" DELEGATE="MATH">
    <BEGIN>$</BEGIN>
    <END>$</END>
</SPAN>

<!-- \[...\] (LaTeX math mode) -->
<SPAN TYPE="MARKUP" DELEGATE="MATH">
    <BEGIN>\[</BEGIN>
    <END>\]</END>
</SPAN>

<!-- some commands must be handled specially -->
<SEQ TYPE="KEYWORD1">\$</SEQ>
<SEQ TYPE="KEYWORD1">\\</SEQ>
<SEQ TYPE="KEYWORD1">\%</SEQ>

<!-- \... commands -->
<MARK_FOLLOWING TYPE="KEYWORD1">\</MARK_FOLLOWING>

<!-- comments -->
<EOL_SPAN TYPE="COMMENT1">%</EOL_SPAN>

<!-- word separators -->
<SEQ TYPE="OPERATOR">{</SEQ>
<SEQ TYPE="OPERATOR">}</SEQ>
<SEQ TYPE="OPERATOR">[</SEQ>
<SEQ TYPE="OPERATOR">]</SEQ>
#@+node:ekr.20090615053403.4944: *6* << math rules >>
<!-- some commands must be handled specially -->
<SEQ TYPE="KEYWORD3">\$</SEQ>
<SEQ TYPE="KEYWORD3">\\</SEQ>
<SEQ TYPE="KEYWORD3">\%</SEQ>

<!-- \... commands -->
<MARK_FOLLOWING TYPE="KEYWORD3">\</MARK_FOLLOWING>

<!-- word separators -->
<SEQ TYPE="KEYWORD2">)</SEQ>
<SEQ TYPE="KEYWORD2">(</SEQ>
<SEQ TYPE="KEYWORD2">{</SEQ>
<SEQ TYPE="KEYWORD2">}</SEQ>
<SEQ TYPE="KEYWORD2">[</SEQ>
<SEQ TYPE="KEYWORD2">]</SEQ>
<SEQ TYPE="KEYWORD2">=</SEQ>
<SEQ TYPE="KEYWORD2">!</SEQ>
<SEQ TYPE="KEYWORD2">+</SEQ>
<SEQ TYPE="KEYWORD2">-</SEQ>
<SEQ TYPE="KEYWORD2">/</SEQ>
<SEQ TYPE="KEYWORD2">*</SEQ>
<SEQ TYPE="KEYWORD2">&gt;</SEQ>
<SEQ TYPE="KEYWORD2">&lt;</SEQ>
<SEQ TYPE="KEYWORD2">&amp;</SEQ>
<SEQ TYPE="KEYWORD2">|</SEQ>
<SEQ TYPE="KEYWORD2">^</SEQ>
<SEQ TYPE="KEYWORD2">~</SEQ>
<SEQ TYPE="KEYWORD2">.</SEQ>
<SEQ TYPE="KEYWORD2">,</SEQ>
<SEQ TYPE="KEYWORD2">;</SEQ>
<SEQ TYPE="KEYWORD2">?</SEQ>
<SEQ TYPE="KEYWORD2">:</SEQ>
<SEQ TYPE="KEYWORD2">'</SEQ>
<SEQ TYPE="KEYWORD2">"</SEQ>
<SEQ TYPE="KEYWORD2">`</SEQ>

<!-- comments -->
<EOL_SPAN TYPE="COMMENT1">%</EOL_SPAN>
#@+node:ekr.20090615053403.4945: *4* @test colorizer wikiTest1
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4946: *5* wiki
# both color_markup & add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

print(g.app().loadDir)
#@+node:ekr.20090615053403.4947: *4* @test colorizer wikiTest2
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4948: *5* wiki
# both color_markup & add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

print(g.app().loadDir)
#@+node:ekr.20090615053403.4949: *4* @test colorizer wikiTest3
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4950: *5* wiki
# both color_markup & add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass
#@+node:ekr.20090615053403.4951: *4* @test leoColor.doNowebSecRef
<< test defined >>
#@+node:ekr.20090615053403.4952: *5* << test defined >>
pass
#@+node:ekr.20090615053403.4953: *4* @test python keywords (new colorizer)
try:
    mode = c.frame.body.colorizer.modes.get('python')
    mode.keywords['as'] = 1 # append the keyword, colorize with 'keyword1' tag.
except AttributeError:
    pass # modes only exists for new colorizer.
#@+node:ekr.20090615053403.4954: *4* @test scanColorDirectives
# This will work regardless of where this method is.
@language python

language = g.findLanguageDirectives(c,p)
assert language == 'python','got:%s' % language
#@+node:ekr.20090615053403.4955: *4* @test vbscript
p = c.p.firstChild()
c.selectPosition(p) # Sets body text.
# val = c.frame.body.colorizer.colorize(p,incremental=False)
# assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090615053403.4956: *5* vbscript
@language vbscript

if
IF
#@+node:ekr.20090615053403.4957: *4* @test zz end of leoColor tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoColor tests')
#@+node:ekr.20071113193624: *3* leoCommands
# 7 failures with Alt-5
#@+node:ekr.20110510054817.3475: *4* @test c.alert
c.alert('test of c.alert')
#@+node:ekr.20050512084850: *4* @test c.checkOutline
errors = c.checkOutline()
assert errors == 0, "Check Outline reported %d errors" % errors
#@+node:ekr.20040713070526: *5* Scripts
@language python 
dump = False 
all = False 
tm = c.testManager
if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = tm.findNodeInTree(p,"tempNode")
    c.setBodyString(temp,"")
    before = tm.findNodeInTree(p,"before")
    after = tm.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.b)
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.b == after.b,"Pretty Print Test failed"
#@+node:ekr.20040713123617: *6* tempNode
@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("Ä á Û")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
#@+node:ekr.20050726141158: *6* before
@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a==3:
        g.pr("Ä á Û")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
#@+node:ekr.20040713123828.1: *6* after
@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("Ä á Û")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
#@+node:ekr.20071113145804.10: *4* @test c.contractAllHeadlines
c.contractAllHeadlines()
p = c.rootPosition()
while p.hasNext():
    p.moveToNext()
c.selectPosition(p)
#@+node:ekr.20070611105423.1: *4* @test c.contractAllHeadlines
c.contractAllHeadlines()
#@+node:ekr.20070611105728: *4* @test c.demote: illegal clone demote
# Remove any previous children.
while p.hasChildren():
    p.firstChild().doDelete()
# Create two cloned children.
c.selectPosition(p)
c.insertHeadline()
p2 = c.p
p2.moveToFirstChildOf(p)
p2.setHeadString('aClone')
c.selectPosition(p2)
c.clone()
assert 2 == p.numberOfChildren()

# Select the first clone and demote (it should be illegal)
c.selectPosition(p2)
c.demote() # This should do nothing.
assert g.app.unitTestDict.get('checkMoveWithParentWithWarning'),'fail 1'
assert 0 == c.checkOutline(), 'fail 2'
assert 2 == p.numberOfChildren(), 'fail 3'
# Delete the children, but only if there are no errors.
while p.hasChildren():
    p.firstChild().doDelete()
#@+node:ekr.20180120142320.1: *4* @test c.expand_path_expression
import os
sep = os.sep
table = (
    ('~{{sep}}tmp{{sep}}x.py', '~%stmp%sx.py' % (sep, sep)),
)
for s, expected in table:
    if g.isWindows:
        expected = expected.replace('\\','/')
    got = c.expand_path_expression(s)
    assert got==expected,'s: %r expected: %r got: %r' % (s,expected,got)
#@+node:ekr.20111121140833.3916: *4* @test c.findMatchingBracket
w = c.frame.body.wrapper
s = w.getAllText()
i = s.find('(')
w.setInsertPoint(i)
c.findMatchingBracket(event=None)
i,j = w.getSelectionRange()
assert i < j,'i: %s j: %s' % (i,j)
#@+node:ekr.20141016101308.4747: *4* @test c.hiddenRootNode.fileIndex
assert c.hiddenRootNode.fileIndex.startswith('hidden-root-vnode-gnx'), c.hiddenRootNode.fileIndex
#@+node:ekr.20120310121839.3949: *4* @test c.hoist @chapter node
# Not valid when run externally: the chapter node will not exist.
if not g.app.isExternalUnitTest:

    p1 = g.findNodeAnywhere(c,'@chapter aaa')
    assert p1
    p2 = g.findNodeAnywhere(c,'aaa node 1')
    assert p2
    try:
        # g.es_print('**1**', c.hoistStack)
        assert not c.hoistStack, ('fail1', c.hoistStack)
        c.selectPosition(p1)
        assert c.p == p1, ('fail2', c.p, p1)
        c.hoist()
            # New in Leo 5.3: should do nothing
        assert c.p == p1, ('fail3', c.p, p1)
        # assert c.p == p2, ('fail3', c.p, p2)
        c.dehoist()
            # New in Leo 5.3: should do nothing:
        assert c.p == p1, ('fail3', c.p, p1)
        # assert c.p == p2, 'fail4\n%s\n%s' % (c.p, p2)
        assert c.hoistStack == [], ('fail5', c.hoistStack)
    finally:
        c.hoistStack = []
        c.selectPosition(p)
        c.redraw()
else:
    self.skipTest('Can not be run locally')
#@+node:ekr.20120311124038.3951: *4* @test c.hoist followed by goto-first-node
p1 = p.copy()
try:
    assert not c.hoistStack
    c.selectPosition(p1)
    assert c.p == p1
    c.hoist()
    c.goToFirstNode()
    assert not c.hoistStack
        # The hoist stack must be cleared to show the first node.
    assert c.p == c.rootPosition()
    assert c.p.isVisible(c)
finally:
    c.selectPosition(p1)
    c.redraw()
#@+node:ekr.20071113105654.1: *4* @test c.hoist with no children
c.hoist()
c.dehoist()
#@+node:ekr.20061106112522: *4* @test c.insertBodyTime
w = c.frame.body.wrapper
s = w.getAllText()

try:
    w.setInsertPoint(len(s))
    c.insertBodyTime()
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # c.recolor()

# end:
#@+node:ekr.20050512083807.1: *4* @test c.markAllAtFileNodesDirty
marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markAllAtFileNodesDirty()
    except Exception:
        g.es_exception()
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

assert ok
#@+node:ekr.20050512083822.1: *4* @test c.markSubheads
marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.markSubheads()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@+node:ekr.20050512084850.1: *5* child 1
pass
#@+node:ekr.20050512084850.2: *5* child 2
pass
#@+node:ekr.20111212142649.3971: *4* @test c.pasteOutline does not clone top node
import sys
if sys.platform.startswith('linux'):
    # There is a PyQt issue: https://bugreports.qt.io/browse/QTBUG-35600
    # The crash causes several other unit tests to fail.
    self.skipTest('Not for Linux')
else:
    c.selectPosition(p)
    c.copyOutline()
    try:
        p2 = c.pasteOutline()
        assert p2
        assert not p2.isCloned()
    finally:
        if p2: p2.doDelete()
        c.redraw(p)
#@+node:ekr.20111212142649.3972: *5* child
# child text.
#@+node:ekr.20191215093834.2: *4* @test c.pasteOutline does not clone top node
import sys
if sys.platform.startswith('linux'):
    # There is a PyQt issue: https://bugreports.qt.io/browse/QTBUG-35600
    # The crash causes several other unit tests to fail.
    self.skipTest('Not for Linux')
else:
    c.selectPosition(p)
    c.copyOutline()
    try:
        p2 = c.pasteOutline()
        assert p2
        assert not p2.isCloned()
    finally:
        if p2: p2.doDelete()
        c.redraw(p)
#@+node:ekr.20191215093834.3: *5* child
# child text.
#@+node:ekr.20080917151620.9: *4* @test c.scanAllDirectives
@language python
@comment a b c
    # @comment must follow @language
@tabwidth -4
@pagewidth 72
@encoding utf-8
@lineending crlf

d = c.scanAllDirectives(p)

table = (
    ('delims', ('a','b','c'),),
    ('encoding','utf-8'),
    ('language','python'),
    ('lineending','\r\n'),
    ('pagewidth',72),
    ('tabwidth',-4),
)

for kind,expected in table:
    got = d.get(kind)
    assert got == expected, 'kind: %s, expected %s, got %s' % (
        kind,repr(expected),repr(got))
#@+node:ekr.20100131180007.5466: *4* @test c.scanAtPathDirectives
p2 = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(p2)
path = c.scanAtPathDirectives(aList)
endpath = g.os_path_normpath('one/two')
assert path and path.endswith(endpath),'expected ending %s got %s' % (
    endpath,path)
#@+node:ekr.20100131180007.5467: *5* @path one
#@+node:ekr.20100131180007.5468: *6* @path two
#@+node:ekr.20100131180007.5469: *7* xyz
#@+node:sps.20100531034136.20110: *4* @test c.scanAtPathDirectives same name subdirs
p2 = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(p2)
path = c.scanAtPathDirectives(aList)
endpath = g.os_path_normpath('again/again')
assert path and path.endswith(endpath),'expected ending %s got %s' % (
    endpath,path)
#@+node:sps.20100531034136.20111: *5* @path again
#@+node:sps.20100531034136.20112: *6* @path again
#@+node:sps.20100531034136.20113: *7* xyz
#@+node:ekr.20040802065214: *4* @@test c.setHeadString marks descendent @thin nodes dirty
# Make sure that changing this headline marks descendant @thin nodes dirty.
h = p.h

try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.h == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    c.setHeadString(p,"changed")
    assert child.isDirty(), "setting descendant @thin nodes dirty failed."
finally:
    try:
        c.setHeadString(p,h)
        c.setHeadString(child,"bogus")
        p.clearDirty()
        child.clearDirty()
    finally: pass
#@+node:ekr.20040802065214.1: *5* bogus
test
#@+node:ekr.20050512083822.2: *4* @test c.unmarkAll
marks = [p.v for p in c.all_positions() if p.isMarked()]
try:
    ok = True
    try:
        c.unmarkAll()
    except Exception:
        ok = False
finally:
    for p in c.all_positions():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@+node:ekr.20100131180007.5465: *4* @test class StubConfig
class StubConfig(g.NullObject):
    pass

x = StubConfig()
assert not x.getBool(c,'mySetting')
assert not x.enabledPluginsFileName
#@+node:ekr.20100203103015.5353: *4* @test efc.ask
# Not a perfect test, but stil significant.
efc = g.app.externalFilesController
if not efc:
    self.skipTest('No externalFilesController')
result = efc.ask(c,p.h)
assert result in (True, False),result
#@+node:ekr.20100203103015.5355: *4* @test efc.compute_ext
@language python

efc = g.app.externalFilesController
if not efc:
    self.skipTest('No externalFilesController')
table = (
    # (None,'.py'),
    # ('','.py'),
    ('txt','.txt'),
    ('.txt','.txt'),
)
for ext,result in table:
    result2 = efc.compute_ext(c,p,ext)
    assert result==result2,'ext: %s, expected %s, got %s' % (
        repr(ext),repr(result),repr(result2))
#@+node:ekr.20100203103015.5354: *4* @test efc.compute_temp_file_path
efc = g.app.externalFilesController
if not efc:
    self.skipTest('no externalFilesController')
s = efc.compute_temp_file_path(c,p,'.py')
assert s.endswith('.py')
#@+node:ville.20090602190735.4770: *4* @test g.command decorator
_foo = 0

@g.command('my-test-command')
def mytestcommand(event):
    global _foo
    _foo = 1

try:
    c.k.simulateCommand('my-test-command')
    assert _foo == 1
    
    # bonus test: c.app.commanders()
    assert c in g.app.commanders()

except AttributeError:
    # Raised only for unit testing.
    pass
#@+node:ekr.20100203103015.5357: *4* @test g.isCallable
def spam(): pass
lam = lambda a: None
class aCallable:
    def __call__ (self):
        pass
c = aCallable()

table = (
    ('abc',False),
    (spam,True),
    (lam,True),
    (c,True)
)

for obj,val in table:
    val2 = g.isCallable(obj)
    assert val == val2,'%s, expected %s, got %s' % (
        repr(obj),val,val2)
#@+node:ekr.20071113201833: *4* @test zz end of leoCommands tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoCommands tests')
#@+node:ekr.20170712132824.1: *4* add/delete comments
#@+node:ekr.20120309155126.3949: *5* @test add comments with multiple @language directives
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'rest and python')
assert p,'not found: rest and python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n#     pass\n# after',
    ),
    (
        True,
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n    # pass\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i > -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.addComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
#@+node:ekr.20120309155126.3950: *6* rest and python
@language rest
rest text.
@language python
def spam():
    # pass
# after
#@+node:ekr.20170712135224.1: *5* @test delete comments with multiple @language directives
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'rest and python')
assert p,'not found: rest and python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language rest\nrest text.\n@language python\ndef spam():\n#     pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
    ),
    (
        True,
        '@language rest\nrest text.\n@language python\ndef spam():\n    # pass\n# after',
        '@language rest\nrest text.\n@language python\ndef spam():\n    pass\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i > -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.deleteComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
#@+node:ekr.20170712135224.2: *6* rest and python
@language rest
rest text.
@language python
def spam():
    pass
# after
#@+node:ekr.20111112171235.3854: *5* @test add html comments
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'html')
assert p,'not found: html'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language html\n<html>\ntext\n</html>\n',
        '@language html\n<html>\n<!-- text -->\n</html>\n',
    ),
    (
        True,
        '@language html\n<html>\n    text\n</html>\n',
        '@language html\n<html>\n    <!-- text -->\n</html>\n'
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('text')
        assert i > -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.addComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
#@+node:ekr.20170128023431.1: *6* @language html
@language html
#@+node:ekr.20111112171235.3855: *7* html
@language html
<html>
    <!-- text -->
</html>
#@+node:ekr.20170712132900.1: *5* @test delete html comments
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'html')
assert p,'not found: html'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        False,
        '@language html\n<html>\n<!-- text -->\n</html>\n',
        '@language html\n<html>\ntext\n</html>\n',
    ),
    (
        True,
        '@language html\n<html>\n    <!-- text -->\n</html>\n',
        '@language html\n<html>\n    text\n</html>\n',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('text')
        assert i > -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test delete-comments
        c.deleteComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
#@+node:ekr.20170712132933.1: *6* @language html
@language html
#@+node:ekr.20170712132933.2: *7* html
@language html
<html>
    text
</html>
#@+node:ekr.20170712134334.1: *5* @test add python comments
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'python')
assert p,'not found: python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        True,
        '@language python\ndef spam():\n    pass\n\n# after',
        '@language python\ndef spam():\n    # pass\n\n# after',
    ),
    (
        False,
        '@language python\ndef spam():\n    pass\n\n# after',
        '@language python\ndef spam():\n#     pass\n\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i > -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test add-comments
        c.addComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
#@+node:ekr.20170712134334.2: *6* python
@language python
def spam():
#     pass

# after
#@+node:ekr.20170712134948.1: *5* @test delete python comments
w = c.frame.body.wrapper
p = g.findNodeInTree(c,p,'python')
assert p,'not found: python'
old_indent = c.config.getBool('indent_added_comments',default=True)
table = (
    (
        True,
        '@language python\ndef spam():\n    # pass\n\n# after',
        '@language python\ndef spam():\n    pass\n\n# after',
    ),
    (
        False,
        '@language python\ndef spam():\n#     pass\n\n# after',
        '@language python\ndef spam():\n    pass\n\n# after',
    ),
)
try:
    for indent, s1, expected in table:
        # Step 1: set the setting.
        c.config.set(None, 'bool', 'indent_added_comments', indent, warn=False)
        val = c.config.getBool('indent_added_comments')
        assert indent == val, (repr(indent), repr(val))
        # Step 2: set p.b and the insert point.
        c.selectPosition(p)
        p.b = s1
        i = p.b.find('pass')
        assert i > -1,'fail1: %s' % (repr(p.b))
        w.setSelectionRange(i,i+4)
        # Step 3: test delete-comments
        c.deleteComments()
        assert p.b == expected, ('indent: %5s got:\n%r\nexpected:\n%r' % (indent, p.b, expected))
finally:
    c.config.set(p, 'bool', 'indent_added_comments', old_indent)
    val = c.config.getBool('indent_added_comments')
    assert old_indent == val, (repr(indent), repr(val))
#@+node:ekr.20170712134948.3: *6* python
@language python
def spam():
    pass

# after
#@+node:ekr.20071113194216: *3* leoConfig
# 3 failurs with Alt-5
#@+node:ekr.20111115071700.3870: *4* @test c.config.printSettings
c.config.printSettings()

#@+node:ekr.20120201101804.3907: *4* @test c.config.updateSetting with no @settings node
import leo.core.leoConfig as leoConfig
    
p = c.config.settingsRoot()
assert c
if p:
    # p will not exist when run externally.
    h = p.h
    p.h = '@@' + h
try:
    parser = leoConfig.SettingsTreeParser(c,localFlag=True)
    d1,d2 = parser.traverse()
    assert isinstance(d1,g.TypedDict),d1
    assert isinstance(d2,g.TypedDict),d2
finally:
    if p:
        p.h = h
        c.redraw()
#@+node:ekr.20111124090010.3939: *4* @test g.app.config @buttons and @commands logic
if g.app.gui.guiName() == 'browser':
    self.skipTest('browser gui')
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
if getattr(g.app, 'isBrowserTest', None):
    # Set only in test_browser_gui.py.
    self.skipTest('Browser Gui test')
d = g.app.config.unitTestDict # Always created for this unit test.
keys = ('config.doButtons-file-names','config.doCommands-file-names')
for key in keys:
    aList = d.get(key,[])
    if 'leoSettings' not in aList:
        self.skipTest('no settings') # #1345
    for base in ('leoSettings', 'unitTest'):
        for ext in ('.leo', '.db'):
            if base+ext in aList:
                break
        else:
            print('key', key, 'ext', ext, 'base', base)
            g.printObj(aList)
            assert False,'%s not in unitTestDict[%s]' % (base,key)
#@+node:ekr.20050203084930.1: *4* @test g.app.config.get
w = g.app.config.get('global_setting_for_unit_tests','int')

assert w in (None,132) # Will be None when tests run dynamically.
#@+node:ekr.20111105124216.3840: *4* @test g.app.config.set
setting = 'import_html_tags'
html_tags = ('body','head','html','table','xxx')

# When run externally, c.config.getData will return None.
existing_tags = c.config.getData(setting)
if not existing_tags:
    g.app.config.set(None,setting,'data',html_tags)
    tags = c.config.getData(setting)
    assert c.config.getData(setting) == html_tags
#@+node:ekr.20060325071703.1: *4* @test ifplatform
import sys

win32  = c.config.getBool('test_win32_setting')
darwin = c.config.getBool('test_darwin_setting')

if win32 is None and darwin is None:
    self.skipTest('settings not loaded') # #1345

if sys.platform == 'win32':
    assert(win32)
    assert(not darwin)

elif sys.platform== 'darwin':
    assert(not win32)
    assert(darwin)

#@+node:ekr.20050203001146: *4* @test local settings (c.page_width)
assert c.page_width == c.config.getInt('page_width'),c.page_width
#@+node:ekr.20071113201854: *4* @test zz end of leoConfig tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoConfig tests')
#@+node:ekr.20100131171342.5592: *3* leoDialogs
#@+node:ekr.20100131171342.5593: *4* @test ctors for all dialogs
# For some reason these don't select the dialog properly when run as a script.
# However, the main reason for the tests is to make sure the ctors don't crash.
# Also, for unit testing the value of c doesn't matter.
import leo.core.leoGui as leoGui
try:
    oldGui = g.app.gui
    guis = [g.app.gui]
    guis.append(leoGui.UnitTestGui())
    for gui in guis:
        gui.runAboutLeoDialog(c,'version','copyright','url','email')
        gui.runAskLeoIDDialog()
        gui.runAskOkDialog(c,'title','message')
        gui.runAskOkCancelNumberDialog(c,'title','message')
        gui.runAskOkCancelStringDialog(c,'title','message')
        gui.runAskYesNoDialog(c,'title','message')
        gui.runAskYesNoCancelDialog(c,'title','message')
        # gui.runCompareDialog(c) # Removed.
finally:
    g.app.gui = oldGui
#@+node:ekr.20071113192611: *3* leoEditCommands
#@+node:ekr.20210829055149.1: *4* Edit command tests: still needed
#@+node:ekr.20111104171708.3847: *5* @test c-to-python
import leo.core.leoBeautify as leoBeautify
import leo.commands.convertCommands as convertCommands
cpp = leoBeautify.CPrettyPrinter(c)
# c2p = convertCommands.C_To_Python(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# c2p.convertCodeList(aList)
# s = ''.join(aList)
#@+node:ekr.20111104171708.3848: *6* c tokenize test
@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos->can_break;
        }

        parser_state_tos->last_saw_nl = false;
        parser_state_tos->can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col > 0) &&
            (buf_break != NULL) &&
            ( ( (parser_state_tos->last_token == ident) &&
                (type_code != comma) &&
                (type_code != semicolon) &&
                (type_code != newline) &&
                (type_code != form_feed) &&
                (type_code != rparen) &&
                (type_code != struct_delim)) ||
              ( (parser_state_tos->last_token == rparen) &&
                (type_code != comma) &&
                (type_code != rparen) ) ) &&
            (output_line_length () > settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp > 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos->procname[0] != '\0') &&
                  parser_state_tos->in_parameter_declaration) ||
                 (parser_state_tos->classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&type_code, &force_nl, &flushed_nl, &last_else, &is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &paren_target);
            }

            if (parser_state_tos->tos > 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines > 0 && code_lines > 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            if (force_nl &&
                (type_code != semicolon) &&
                ( (type_code != lbrace) ||
                  (!parser_state_tos->in_decl && !settings.btype_2) ||
                  (parser_state_tos->in_decl && !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos->last_token == rbrace)))
            {
                if (settings.verbose && !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &paren_target);
                parser_state_tos->want_blank = false;
                force_nl = false;
            }

            parser_state_tos->in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos->want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &&
                 (type_code != cplus_comment) &&
                 !(settings.break_function_decl_args &&
                   (parser_state_tos->last_token == comma)) &&
                 !( (parser_state_tos->last_token == comma) &&
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &scase, &force_nl, &sp_sw, &flushed_nl,
                         &hd_type, &dec_ind, &last_token_ends_sp, &file_exit_value,
                         can_break, &last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            parser_state_tos->last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col > 0) && (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) && (scase || (squest <= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) && (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &&
                 (output_line_length () > settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
#@+node:ekr.20111006105711.3544: *5* @test clone-marked-nodes
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        target = p.copy()
        setup_test(p)
        c.cloneMarked()
        h = 'Clones of marked nodes'
        assert c.p.h == h,c.p.h
        c.undoer.undo()
        assert not g.findNodeAnywhere(c,h)
        c.undoer.redo()
        assert c.p.h == h, c.p.h
    try:
        test(p)
    finally:
        tear_down(p,'Clones of marked nodes')
#@+node:ekr.20150414144103.1: *5* @test dabbrev-completion
# main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
# i,j = g.getWord(s,4)
# word = s[i:j]
event = g.bunch(widget=w)
ac.dynamicCompletion(event)
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 1:
        c.undoer.undo(event=event)

#@+node:ekr.20150414144038.1: *5* @test dabbrev-expand
# main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
i,j = g.getWord(s,4)
word = s[i:j]
aList = ac.getDynamicList(w,word)
c.k.arg = aList[1]
event = g.bunch(char=None, stroke=None, widget=w)
ac.dynamicExpandHelper(event)
    # This *does* support undo.
s = w.getAllText()
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 0:
        c.undoer.undo()
#@+node:ekr.20111006064419.3491: *5* @test delete-marked-nodes
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        c.deleteMarked()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
        c.undoer.undo()
        n = p.numberOfChildren()
        assert n == 4,'undo: children: %s' % (n)
        c.undoer.redo()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
    try:
        test(p)
    finally:
        tear_down(p)
#@+node:ekr.20120303054735.3931: *5* @test expand-and-go-right
# Test of bug 930726: expandNodeAndGoToFirstChild only expands or only goes to first child .

p.contract()
c.expandNodeAndGoToFirstChild()
assert c.p == p.firstChild()
#@+node:ekr.20120303054735.3932: *6* child
#@+node:ekr.20070305095401: *5* @test goNext/PrevVisitedNode
p = c.p.copy()
c.selectPosition(p.threadBack())
p1 = c.p
c.goPrevVisitedNode()
p2 = c.p
c.goNextVisitedNode()
p3 = c.p
#@+node:ekr.20100212104817.5351: *5* @test help-for-command
result = c.helpCommands.getBindingsForCommand('help')
if not result:
    self.skipTest('no settings')
assert result.strip().lower()=='f1', repr(result)
#@+node:ekr.20071113145804.16: *5* @test helpForbindings
vr = c.helpCommands.helpForBindings()
if not vr:
    self.skipTest('no vr plugin')
#@+node:ekr.20071113145804.17: *5* @test helpForFindCommands
vr = c.helpCommands.helpForFindCommands()
if not vr:
    self.skipTest('no vr plugin')
#@+node:ekr.20071113145804.4: *5* @test selfInsertCommand-1
@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = '(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aÉ©BE|cz):\n'
    u = '(pdq):\n'
    w.setInsertPoint(len(s))
    for char in u:
        binding = 'Return' if char == '\n' else char
        event = g.app.gui.create_key_event(c,char=char,binding=binding,w=w)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
#@+node:ekr.20071113145804.5: *5* @test selfInsertCommand-2 (replacing tabs)
@language python
@tabwidth -4

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.app.gui.create_key_event(c, binding='Tab', char='\t', w=w)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('\n    ###abcdef\n'),'result\n%s' % (repr(result))
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor_now()
    
###abcdef
#@+node:ekr.20071007120750.6: *5* @test set-fill-prefix
# xxxx.yyyy

s = p.b
w = c.frame.body.wrapper
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
prefix = c.editCommands.fillPrefix
assert prefix == 'xxxx.yyyy',repr(prefix)
#@+node:ekr.20100212104817.5346: *5* @test sort-recent-files (new)
c.sortRecentFiles()
#@+node:ekr.20100212104817.5347: *5* @test sort-siblings (new)
child = p.firstChild()
assert child.h == 'b','fail 1'
try:
    c.selectPosition(child)
    c.sortSiblings()
    c.redraw_now()
    child = p.firstChild()
    assert child.h == 'a'
    child = child.next()
    assert child.h == 'b'
    child = child.next()
    assert child.h == 'c'
    assert not child.next()
finally:
    c.undoer.undo()
    p.contract()
    c.redraw(p)
#@+node:ekr.20100212104817.5348: *6* b
#@+node:ekr.20100212104817.5349: *6* a
#@+node:ekr.20100212104817.5350: *6* c
#@+node:ekr.20121016134831.3906: *5* @test typescript-to-python
import leo.core.leoBeautify as leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
# ts2p = c.convertCommands.TS_To_Python(c)
fn = 'typescript tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# bts2p.convertCodeList(aList)
# s = ''.join(aList)
#@+node:ekr.20121016134831.3907: *6* typescript tokenize test
@language javascript

public attemptIncrementalUpdateUnit(previousScript: Script,scriptId: string,newSourceText: ISourceText,editRange: ScriptEditRange): UpdateUnitResult
    self.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")")
    if editRange === None:
        throw Error("editRange should be valid")
    var scope1 = self.getEnclosingScopeContextIfSingleScopeEdit(previousScript,scriptId,newSourceText,editRange)
    if scope1 === None:
        return None
    var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta
    # Heuristic: if the range to reparse is too big,bail out.
    # This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups
    if newScopeLength >= newSourceText.getLength()/ 2:
        self.logger.log("  Bailing out because range of scope to reparse(" + newScopeLength + " characters)is greater than half the size of the source text")
        return None
    # Capture parsing errors so that they are part of "updateResult"
    var parseErrors: TypeScript.ErrorEntry:[] = []
    var errorCapture = function(minChar: number,charLen: number,message: string,unitIndex: number): void
        parseErrors.push(TypeScript.ErrorEntry:(unitIndex,minChar,minChar + charLen,message))
    var quickParseResult = TypeScript.quickParse(self.logger,scope1.scopeStartAST,newSourceText,scope1.scopeStartAST.minChar,scope1.scopeStartAST.minChar + newScopeLength,errorCapture)
    if quickParseResult.endLexState != TypeScript.LexState.Start:
        self.logger.log("  Bailing out because scope contains unterminated comment")
        return None
    var scriptFragment = quickParseResult.Script
    if scriptFragment.vars.members.length !== 0:
        self.logger.log("  Bailing out because new source text defines variables")
        return None
    #if(scriptFragment.scopes.members.length !== 1)
    #    logger.log("  Bailing out because new source text defines more than one scope(or none)");
    #    return null;
    #
    # This detects adding close curlies,since they have the side effect of having the parser
    # parse more members in the scope range.
    if scriptFragment.bod.members.length !== 1:
        self.logger.log("  Bailing out because new source text defines more than one scope(or none)")
        return None
    var oldScope = scope1.scopeStartAST
    var newScope = scriptFragment.bod.members[0]
    if oldScope.nodeType != newScope.nodeType:
        self.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope")
        return None
    if not (<any>oldScope).leftCurlyCount or not (<any>oldScope).rightCurlyCount:
        self.logger.log("  Bailing out because sopce doesn't have left/right curly count")
        return None
    if(<any>oldScope).leftCurlyCount !==(<any>newScope).leftCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)left curly braces")
        return None
    if(<any>oldScope).rightCurlyCount !==(<any>newScope).rightCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)right curly braces")
        return None
    if newScope.minChar !== 0:
        self.logger.log("  Bailing out because new function declaration does not start at position 0")
        return None
    if newScope.limChar !== newScopeLength:
        self.logger.log("  Bailing out because new function declaration does not end at the new end position")
        return None
    return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript,scriptFragment,oldScope,newScope,editRange,parseErrors)
#@+node:ekr.20170401123840.1: *4* goto-global-line tests
# To do: use tables as in the clean-c test.
#@+node:ekr.20170401123840.2: *5* @test c.goToScriptLineNumber
child = g.findNodeInChildren(c, p, 'syntax-error')
assert child, 'no child'
try:
    c.goToScriptLineNumber(1, child)
finally:
    p.contract()
    c.selectPosition(p)
    c.redraw()
#@+node:ekr.20170401123840.3: *6* syntax-error
@language python
def spam:
    pass
#@+node:ekr.20170401123840.4: *5* @test find_file_line: @auto-md
import sys
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
if not sys.platform.startswith('win'):
    self.skipTest('Requires Windows')
trace = False
h = '@auto unittest/at-auto-md-line-number-test.md'
root = g.findNodeAnywhere(c, h)
assert root
s = c.gotoCommands.get_external_file_with_sentinels(root)
if trace:
    print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
for n in range(20):
    p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
    if found:
        if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
    else:
        if trace: print('not found: %s' % (n+1))
        assert n == 8, n
        break
#@+node:ekr.20170401123840.5: *5* @test find_file_line: @auto-org
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-org unittest/at-auto-org-line-number-test.org'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
#@+node:ekr.20170401123840.6: *5* @test find_file_line: @auto-otl
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-otl unittest/at-auto-otl-line-number-test.otl'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 5, n
            break
#@+node:ekr.20170401123840.7: *5* @test find_file_line: @auto-py
import sys
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    root = p.parent().parent()
    # h = '@auto unittest/at-auto-line-number-test.py'
    h = '@auto unittest/at-auto-unit-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(25):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 12, n
            if trace: print('not found: %s' % (n+1))
            break
else:
    self.skipTest('Skip on Linux')
#@+node:ekr.20170401123840.9: *5* @test find_file_line: @clean-c
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    stripped_lines = [z for z in lines if not z.startswith('//@')]
    if trace:
        # g.printList(stripped_lines)
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(lines)]))
    table = (
        # n is the 1-based offset of the *stripped* lines.
        # Directives do not appear in @clean files.
        # (1,     '@language c'),
        # (2,     '@tabwidth -4'),
        (3,     '// before @others // line 1'),
        # (4,     '@others'),
        # spam node.
        (1,     'def spam(): // line 2'),
        (2,     '    pass'),
        # eggs node.
        (1,    'def eggs(): // line 4'),
        (2,    '    pass'),
        # resume top node.
        (5,    '// last line: line 6'),
    )
    for n, data in enumerate(table):
        offset, line = data
        p, offset2, found = c.gotoCommands.find_file_line(n+1, p=target)
        assert offset == offset2, 'expected offset %s, got %s %r' % (
            offset, offset2, p and p.h)
    p, offset, found = c.gotoCommands.find_file_line(15, p=target)
    assert not found
#@+node:ekr.20170401123840.10: *5* @test find_file_line: @clean-python
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
#@+node:ekr.20170401123840.11: *5* @test find_file_line: @file-c
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
#@+node:ekr.20170401123840.12: *5* @test find_file_line: @file-python
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
#@+node:ekr.20170401123840.13: *5* @test find_file_line: @nosent-python
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@nosent unittest/at-nosent-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtNoSentFileNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
#@+node:ekr.20170401123840.14: *5* @test find_gnx @file
# Not valid for external tests: uses @<file> node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    gnx = target.v.fileIndex
    assert gnx
    found = c.gotoCommands.find_gnx(root, gnx, h)
    assert found, 'not found'
#@+node:ekr.20170401123840.15: *5* @test goto_show_results not found
c.gotoCommands.success(lines=['a', 'b'], n=3, n2=3, p=p)
c.gotoCommands.fail(lines=['a', 'b'], n=3, root=p)

#@+node:ekr.20061104172236.1: *4* Function tests
#@+node:ekr.20150430053825.1: *5* @test abbrevCommands.next_place
ac = c.abbrevCommands
assert ac
if c.abbrev_place_start is None or c.abbrev_place_end is None:
    self.skipTest('no abbreviation settings') # #1345.
child = g.findNodeInTree(c,p,'child')
assert child
old_b = child.b
try:
    i,j,val = 0,0,child.b
    # ac.make_script_substitutions(i,j,val)
    # ac.find_place_holder(child,True)
    new_s,i,j = ac.next_place(child.b,offset=0)
    assert i == 34 and j == 40,(i,j)
    new_s2,i,j = ac.next_place(new_s,offset=40)
    assert i == 54 and j == 58,(i,j)
finally:
    child.b = old_b
#@+node:ekr.20150430061225.1: *6* child
def spam ():
    """None - Return <|return|>
    """

    <|code|>
#@+node:ekr.20100902074747.5970: *5* @test addAbbrevHelper
f = c.abbrevCommands.addAbbrevHelper
d = c.abbrevCommands.abbrevs

# New in Leo 4.10: whitespace (blank,tab,newline) *is* significant in definitions.
table = (
    ('ut1','ut1=aa','aa'),
    # ('ut2','ut2 =bb','bb'),
    ('ut3','ut3=cc=dd','cc=dd'),
    ('ut4','ut4= ee',' ee'),
    ('ut5','ut5= ff = gg',' ff = gg'),
    ('ut6','ut6= hh==ii',' hh==ii'),
    ('ut7','ut7=j=k','j=k'),
    ('ut8','ut8=l==m','l==m'),
    ('@ut1','@ut1=@a','@a'),
)

for name,s,expected in table:
    for s2,kind in ((s,'(no nl)'),(s+'\n','(nl)')):
        f(s2,tag='unit-test')
        result,tag = d.get(name,(None,None),)
        assert result==expected, '%s <%s> expected <%s>, got <%s>' % (
            kind,s,expected,result)
#@+node:ekr.20061104172236.3: *5* @test capitalizeHelper
# TARGETWORD

w = c.frame.body.wrapper

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType='X')
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
#@+node:ekr.20100131180007.5453: *5* @test dynamicExpandHelper
# A totally wimpy test.
# And it somehow prints a newline to the console.
if 0:
    c.abbrevCommands.dynamicExpandHelper(event=None,prefix='',aList=[],w=None)
#@+node:ekr.20061104172236.5: *5* @test extendHelper
ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
#@+node:ekr.20080408094623.1: *5* @test findWord
# start
# targetWord

e = c.editCommands
k = c.k
w = c.frame.body.wrapper
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
e.w = w
e.oneLineFlag = False
e.findWord1(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 10, got %s' % (i)
#@+node:ekr.20061104172236.2: *5* @test findWordInLine
# targetWord
e = c.editCommands
k = c.k
w = c.frame.body.wrapper
for val in (True,False):
    k.arg = 't' # 'targetWord'
    w.setInsertPoint(0)
    e.w = w
    e.oneLineFlag = val
    f = e.findWord1(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got %s' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

#@+node:ekr.20071113145804.15: *5* @test helpForMinibuffer
vr = c.helpCommands.helpForMinibuffer()
if not vr:
    self.skipTest('no vr plugin')
#@+node:ekr.20061104172236.6: *5* @test moveToHelper
ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
#@+node:ekr.20061110094226: *5* @test moveUpOrDownHelper
ec = c.editCommands ; w = c.frame.body.wrapper

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
#@+node:ekr.20061104172236.7: *5* @test scrollHelper
ec = c.editCommands
w = c.frame.body.wrapper

for direction in ('up','down'):
    for distance in ('line','page','half-page'):
        event = g.app.gui.create_key_event(c,w=w)
        ec.scrollHelper(event,direction,distance)
#@+node:ekr.20061104172236.4: *5* @test setMoveCol
w = c.frame.body.wrapper
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
#@+node:ekr.20100204165850.5371: *4* Toggle commands
# These tests will be important when revising config code.
#@+node:ekr.20100119102849.5108: *5* @test toggle-extend-mode
# backward-find-character and find-character
# can't be tested this way because they require k.getarg.
# They pass hand tests.

<< define table >>

w = c.frame.body.wrapper
child = g.findNodeInChildren(c,p,'work')
assert child
c.selectPosition(child)

for commandName in table:
    # Put the cursor in the middle of the middle line
    # so all cursor moves will actually do something.
    w.setInsertPoint(15) # for move-past-close
    try:
        c.editCommands.extendMode = True
        c.keyHandler.simulateCommand(commandName)
        i,j = w.getSelectionRange()
        assert i != j,'i == j: %s %s' % (i,commandName)
    finally:
        c.editCommands.extendMode = False

#@+node:ekr.20100119102849.5109: *6* << define table >>
# Cursor movement commands affected by extend mode.
# The x-extend-selection commands are not so affected.
table = (
    'back-to-indentation',
    'back-to-home',
    'back-char',
    'back-page',
    'back-paragraph',
    'back-sentence',
    'back-word',
    'beginning-of-buffer',
    'beginning-of-line',
    'end-of-buffer',
    'end-of-line',
    'forward-char',
    'forward-page',
    'forward-paragraph',
    'forward-sentence',
    'forward-end-word',
    'forward-word',
    'move-past-close',
    'next-line',
    'previous-line',
)
#@+node:ekr.20100119102849.5110: *6* work
line 1.
line 2(xxx).
line 3.
#@+node:ekr.20100204165850.5373: *5* @test most toggle commands
if g.app.inBridge:
    self.skipTest('in bridge')
k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands
# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]
# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]
if not g.app.isExternalUnitTest:
    table.extend(table2)
for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(obj,ivar,val1)
#@+node:ekr.20051107115231: *4*  Typing
# These are mysteriously fragile tests, so they go first
#@+node:ekr.20060208072415: *5* @test Delete key sticks in body
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocus()
    w = c.frame.body.wrapper
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    if 1:
        c.k.simulateCommand('delete-char')
    else:
        # This fails unless Delete is bound to delete-char
        g.app.gui.event_generate(c,'Delete','Delete',w) # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 0:
        c.setBodyString(p,'')
        c.redraw(p)
#@+node:ekr.20051125170139: *5* @test Delete key sticks in headline
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
#@+node:ekr.20051120110335: *5* @test insert-node can be undone and redone
u = c.undoer
assert u
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)
#@+node:ekr.20130923090601.4178: *5* @test insert-node-before node can be undone and redone
u = c.undoer
assert u
c.insertHeadlineBefore()
assert u.undoMenuLabel == 'Undo Insert Node Before',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node Before',repr(u.undoMenuLabel)
#@+node:ekr.20051125155134: *5* @test inserting a new node draws the screen exactly once
n = c.frame.tree.redrawCount
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
try:
    n2 = c.frame.tree.redrawCount
    if g.app.isExternalUnitTest:
        self.skipTest('Can not be run externally')
    else:
        assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()
#@+node:ekr.20051107115231.18: *5* @test paste and undo in headline - at end
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
frame = c.frame
tree = frame.tree
canvas = tree.canvas
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w, 'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste, 'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, f"oops3 expected {h} got: {p.h}"
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
#@+node:ekr.20051107115231.20: *5* @test paste and undo in headline - with selection
import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w, 'Null w'
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('1.1','1.2')
        if g.app.gui.guiName() == 'curses':
            c.frame.pasteText(event=g.Bunch(widget=w))
        else:
            stroke = k.getStrokeForCommandName('paste-text')
            if stroke is None:
                self.skipTest('no binding for paste-text') # #1345
            k.manufactureKeyPressForCommandName(w,'paste-text')
            g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h[0] + paste + h[2:]
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, 'head mismatch'
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
#@+node:ekr.20051107115231.16: *5* @test paste at end of headline
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste,'Expected: %s, got %s' % (
        h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
#@+node:ekr.20060208072331: *5* @test paste from menu into headline sticks
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
event = g.app.gui.create_key_event(c,w=w)
c.frame.pasteText(event)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
#@+node:ekr.20051107115231.14: *5* @test return ends editing of headline
h = '@test return ends editing of headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
g.app.gui.event_generate(c,'\n','Return',w)
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'
#@+node:ekr.20051107115231.28: *5* @test selecting new node retains paste in headline
if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
#@+node:ekr.20051107115231.21: *5* @test selecting new node retains typing in headline
if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses gui')

k = c.k
if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        # char, shortcut.
        g.app.gui.event_generate(c,'X','Shift+X',w)
        g.app.gui.event_generate(c,'Y','Shift+Y',w)
        g.app.gui.event_generate(c,'Z','Shift+Z',w)
        g.app.gui.event_generate(c,'\n','Return',w)
        expected = h + 'XYZ'
        assert p.h == expected, f"oops 1: expected {expected!r} got {p.h!r}"
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, f"oops 2: expected {h!r} got {p.h!r}"
    finally:
        if 1:
            c.setHeadString(p, h) # Essential
            c.redraw(p)
#@+node:ekr.20051107115231.17: *5* @test typing and undo in headline - at end
import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
if g.app.gui.guiName() == 'curses':
    # This could be adapted, but not now.
    self.skipTest('Not for curses gui')
k = c.k
if k.defaultUnboundKeyAction != 'insert':
    self.skipTest('defaultUnboundKeyAction != insert')
if not k.getStrokeForCommandName('undo'):
    self.skipTest('no settings')

frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make the node visible.
w = c.edit_widget(p)
try:
    assert w, 'oops1'
    wName = g.app.gui.widget_name(w)
    assert wName.startswith('head'),'w.name:%s' % wName
    w.setSelectionRange('end','end')
    g.app.gui.event_generate(c,'X','Shift+X',w)
    g.app.gui.event_generate(c,'Y','Shift+Y',w)
    g.app.gui.event_generate(c,'Z','Shift+Z',w)
    g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + 'XYZ',(
        'oops2: expected: %s, got: %s' % (
            h + 'XYZ',p.h))
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
            c.undoer.undoMenuLabel)
    k.manufactureKeyPressForCommandName(w,'undo')
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
    assert p.h == h,'oops5 got: %s, expected: %s' % (
        p.h,h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
#@+node:ekr.20051109091731: *5* @test typing in non-empty body text does not redraw the screen
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
c.bodyWantsFocus()
n = c.frame.tree.redrawCount
try:
    w = c.frame.body.wrapper
    g.app.gui.event_generate(c,'a','a',w)
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
#@+node:ekr.20051120115046: *5* @test undoing insert node restores previous node's body text
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')
#@+node:ekr.20060131102450: *5* @test zz print end of typing tests
# Print does not work: it is redirected.
g.pr('\nEnd of typing tests')
#@+node:ekr.20070306091949: *4* @test zz end of leoEditCommands tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoEditCommands tests.')
#@+node:ekr.20061001114637: *3* leoFileCommands
# 3 failures with Alt-5
#@+node:ekr.20080806072412.1: *4* @test fc.resolveArchivedPosition
child1 = p.firstChild()
child2 = p.firstChild().next()
grandChild1 = child2.firstChild()
grandChild2 = grandChild1.next()
greatGrandChild11 = grandChild1.firstChild()
greatGrandChild12 = greatGrandChild11.next()
greatGrandChild21 = grandChild2.firstChild()
greatGrandChild22 = greatGrandChild21.next()
root_v = p.v

table = (
    # Errors.
    (None,'-1'),
    (None,'1'),
    (None,'0.2'),
    (None,'0.0.0'),
    (None,'0.1.2'),
    # Valid.
    (root_v,'0'),
    (child1.v,'0.0'),
    (child2.v,'0.1'),
    (grandChild1.v,'0.1.0'),
    (greatGrandChild11.v,'0.1.0.0'),
    (greatGrandChild12.v,'0.1.0.1'),
    (grandChild2.v,'0.1.1'),
    (greatGrandChild21.v,'0.1.1.0'),
    (greatGrandChild22.v,'0.1.1.1'),
)

for v,archivedPosition in table:
    v2 = c.fileCommands.resolveArchivedPosition(archivedPosition,root_v)
    assert v == v2,'got %s, expected %s' % (v2,v)
#@+node:ekr.20080806072412.2: *5* first child
#@+node:ekr.20080806072412.3: *5* second child
#@+node:ekr.20080806072412.4: *6* grandChild1
#@+node:ekr.20080806080425.1: *7* greatGrandChild11
#@+node:ekr.20080806080425.2: *7* greatGrandChild12
#@+node:ekr.20080806072412.5: *6* grandChild 2
#@+node:ekr.20080806080425.3: *7* greatGrandChild21
#@+node:ekr.20080806080425.4: *7* greatGrandChild22
#@+node:ekr.20080805105541.1: *4* @test p.archivedPosition
val = p.archivedPosition(root_p=p)
assert val == [0],'expected %s, got %s' % ([0],val)

i = 0
for z in p.parent().children_iter():
    val = z.archivedPosition(root_p=p.parent())
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.firstChild().next().children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,1,i],'expected %s, got %s'%([0,1,i],val)
    i += 1
#@+node:ekr.20080805122315.1: *5* first child
#@+node:ekr.20080805122315.2: *5* second child
#@+node:ekr.20080805122315.3: *6* grandChild
#@+node:ekr.20080805122315.4: *6* grandChild 2
#@+node:ekr.20080805104144.1: *4* @test putDescendentVnodeUas
fc = c.fileCommands
child = p.firstChild()
grandChild = child.firstChild()
child.v.unknownAttributes = {'unit_test_child':'abcd'}
grandChild.v.unknownAttributes = {'unit_test_grandchild':'wxyz'}
try:
    s = fc.putDescendentVnodeUas (p)
    if 0: # This test is too flaky to be useful.
        expected = ' descendentVnodeUnknownAttributes=\
        7d7100285803000000302e3071017d7102580f000000756e6974\
        5f746573745f6368696c64710358040000006162636471047358\
        05000000302e302e3071057d71065814000000756e69745f7465\
        73745f6772616e646368696c64710758040000007778797a710873752e"'
        assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    del child.v.unknownAttributes
    del grandChild.v.unknownAttributes
#@+node:ekr.20080805104144.2: *5* child
#@+node:ekr.20080805104144.3: *6* grandChild
#@+node:ekr.20061001114236: *4* @test putUa
fc = c.fileCommands # self is a dummy
p.v.unknownAttributes = {'unit_test': 'abcd'}
s = fc.putUnknownAttributes (p.v)
expected = ' unit_test="58040000006162636471002e"'
assert s == expected, '\nexpected: %s\ngot:      %s' % (repr(expected),repr(s))
#@+node:ekr.20051107115231.9: *4* @test Select a node when file is first loaded
c.redraw(p) # To make node visible

c2 = c.new()
p2 = c2.p

try:
    # This fails, but it is possible to edit the headline.
    # assert c2.edit_widget(p2),'c2.edit_widget(p2) failed: %s' % repr(p2)
    assert p2,'p2 failed: %s' % repr(p2)
    # assert c.edit_widget(p),'c.edit_widget(p) failed: %s' % repr(p)
finally:
    ### c2.setChanged(False)
    c2.clearChanged()
    c2.close()
#@+node:ekr.20090507084947.5152: *4* @test t.fileIndex remains the same
if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:
    # new_gnxs:
    assert p.v.fileIndex == 'ekr.20090507084947.5152',p.v.fileIndex
    # old gnxs:
    # assert p.v.fileIndex == ('ekr', '20090507084947', 5152)
#@+node:ekr.20071113202045: *4* @test zz end of leoFile tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoFileCommands tests.')
#@+node:ekr.20071113193527: *3* leoFind
# 4 failures with Alt-5
#@+node:ekr.20060130151716.3: *4* @test minibuffer find commands
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
table = (
    're-search-forward',
    're-search-backward',
    'search-forward',
    'search-backward',
    'word-search-forward',
    'word-search-backward',
)

for command in table:
    # This is not a full test.  We must use keyboardQuit here!
    c.k.simulateCommand(command)
    c.k.keyboardQuit(None)
#@+node:ekr.20190603184713.1: *4* @test replace-all: plain search
fc = c.findCommands

plain_table = (
    # s         find    change  count   result
    ('aA',      'a',    'C',    1,      'CA'),
    ('Aa',      'A',    'C',    1,      'Ca'),
    ('Aba',     'b',    'C',    1,      'ACa'),
)
for s, find, change, count, result in plain_table:
    fc.ignore_case = False
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_plain(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603192140.1: *4* @test replace-all: plain search: ignore case
fc = c.findCommands

plain_table = (
    # s         find    change  count   result
    ('aA',      'a',    'C',    2,      'CC'),
    ('AbBa',    'b',    'C',    2,      'ACCa'),
)
for s, find, change, count, result in plain_table:
    fc.ignore_case = True
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_plain(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603193938.1: *4* @test replace-all: regex search
fc = c.findCommands
regex_table = (
    # s                 find        change  count   result
    ('a ba aa a ab a',  r'\b\w+\b', 'C',    6,      'C C C C C C'),
    ('a AA aa aab ab a',r'\baa\b',  'C',    1,      'a AA C aab ab a'),
    # Multi-line
    ('aaa AA\naa aab',  r'\baa\b',  'C',    1,      'aaa AA\nC aab'),
)
for s, find, change, count, result in regex_table:
    fc.ignore_case = False
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_regex(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603193204.1: *4* @test replace-all: word search
fc = c.findCommands

word_table = (
    # s                 find    change  count   result
    ('a ba aa a ab a',  'a',    'C',    3,      'C ba aa C ab C'),
    ('a ba aa a ab a',  'aa',   'C',    1,      'a ba C a ab a'),
)
for s, find, change, count, result in word_table:
    fc.ignore_case = False
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_word(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20190603193214.1: *4* @test replace-all: word search: ignore case
fc = c.findCommands

word_table = (
    # s                 find    change  count   result
    ('a ba aa A ab a',  'a',    'C',    3,      'C ba aa C ab C'),
    ('a ba aa AA ab a', 'aa',   'C',    2,      'a ba C C ab a'),
)
for s, find, change, count, result in word_table:
    fc.ignore_case = True
    fc.find_text = find
    fc.change_text = change
    count2, result2 = fc._change_all_word(s)
    assert result == result2, 'expected result: %r: got: %r' % (result, result2)
    assert count == count2, 'expected count:  %r: got: %r' % (count, count2)
# print('pass')
#@+node:ekr.20060130151716.2: *4* @test set find mode commands
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
table = (
    'set-find-everywhere',
    'set-find-node-only',
    'set-find-suboutline-only',
)
# show-find-tab-options     = Ctrl-o
# show-find-options         = o
for command in table:
    c.k.simulateCommand(command)
#@+node:ekr.20060130151716.4: *4* @test show-find-options
c.k.simulateCommand('show-find-options')
#@+node:ekr.20060130151716.1: *4* @test toggle find options commands
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
table = (
    # 'toggle-find-clone-find-all-option',
    'toggle-find-ignore-case-option',
    'toggle-find-in-body-option',
    'toggle-find-in-headline-option',
    'toggle-find-mark-changes-option',
    'toggle-find-mark-finds-option',
    'toggle-find-regex-option',
    # 'toggle-find-reverse-option',
    'toggle-find-word-option',
    # 'toggle-find-wrap-around-option',
)
for command in table:
    c.k.simulateCommand(command)
    c.k.simulateCommand(command)
#@+node:ekr.20190608143418.1: *4* New leoFind Tests
#@+node:ekr.20190608144111.1: *5* @test leoFind.LeoFind clean init
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)
table = (
    # 'batch',  # 'wrap', 
    'ignore_case', 'node_only', 'pattern_match', 
    'search_headline', 'search_body', 'suboutline_only',
    'mark_changes', 'mark_finds', 'whole_word',
   
)
for ivar in table:
    assert getattr(x, ivar) is None, ivar
assert x.reverse is False
#@+node:ekr.20190608143502.1: *5* @test find._inner_search_regex
import re
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)

def test(table, table_name, back, nocase):
    for pattern, s, expected in table:
        flags = re.IGNORECASE if nocase else 0
        x.re_obj = re.compile(pattern, flags)
        pos, new_pos = x._inner_search_regex(s, 0, len(s),
            pattern, backwards=back, nocase=nocase)
        got = s[pos:new_pos]
        assert expected==got, (
            '\n   table: %s'
            '\n pattern: %r'
            '\n       s: %r'
            '\nexpected: %r'
            '\n     got: %r' % (table_name, pattern, s, expected, got)
        )

plain_table = (
    # pattern   s       expected
    (r'.',      'A',    'A'),
    (r'A',      'xAy',  'A'),
)
nocase_table = (
    # pattern   s       expected
    (r'.',      'A',    'A'),
    (r'.',      'a',    'a'),
    (r'A',      'xay',  'a'),
    (r'a',      'xAy',  'A'),
)
back_table = (
    # pattern   s           expected
    (r'a.b',    'a1b a2b',  'a2b'),
)
test(plain_table,  'plain_table',  back=False, nocase=False)
test(nocase_table, 'nocase_table', back=False, nocase=True)
test(back_table,   'back_table',   back=True,  nocase=False)
#@+node:ekr.20190608143502.2: *5* @test find._inner_search_backward
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)

def test(table, table_name, nocase, word):
    test_n = 0
    for pattern, s, i, j, expected, expected_i, expected_j in table:
        test_n += 1
        if j == -1: j = len(s)
        got_i, got_j = x._inner_search_backward(s, i, j,
            pattern, nocase=nocase, word=word)
        got = s[got_i: got_j]
        assert expected==got and got_i == expected_i and got_j == expected_j, (
            '\n     table: %s'
            '\n    i test: %s'
            '\n   pattern: %r'
            '\n         s: %r'
            '\n  expected: %r'
            '\n       got: %r'
            '\nexpected i: %s'
            '\n     got i: %s'
            '\nexpected j: %s'
            '\n     got j: %s'
            % (table_name, test_n, pattern, s, expected, got, expected_i, got_i, expected_j, got_j))

plain_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',      'abaca',     0, -1,  'a',      4,          5),
    ('A',      'Abcde',     0, -1,  'A',      0,          1),
)
nocase_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  'a',      5,          6),
    ('A',       'Abcdca',   0, -1,  'a',      5,          6),
)
word_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  '',      -1,          -1),
    ('A',       'AA A AB',  0, -1,  'A',      3,          4),
)
test(plain_table,  'plain_table',  nocase=False, word=False)
test(nocase_table, 'nocase_table', nocase=True,  word=False)
test(word_table,   'word_table',   nocase=False, word=True)
#@+node:ekr.20190608143502.3: *5* @test find._inner_search_plain
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)

def test(table, table_name, nocase, word):
    test_n = 0
    for pattern, s, i, j, expected, expected_i, expected_j in table:
        test_n += 1
        if j == -1: j = len(s)
        got_i, got_j = x._inner_search_plain(s, i, j, pattern,
            nocase=nocase, word=word)
        got = s[got_i: got_j]
        assert expected==got and got_i == expected_i and got_j == expected_j, (
            '\n     table: %s'
            '\n    i test: %s'
            '\n   pattern: %r'
            '\n         s: %r'
            '\n  expected: %r'
            '\n       got: %r'
            '\nexpected i: %s'
            '\n     got i: %s'
            '\nexpected j: %s'
            '\n     got j: %s'
            % (table_name, test_n, pattern, s, expected, got, expected_i, got_i, expected_j, got_j))

plain_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',      'baca',     0, -1,   'a',      1,          2),
    ('A',      'bAcde',     0, -1,  'A',      1,          2),
)
nocase_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  'a',      0,          1),
    ('A',       'abcdca',   0, -1,  'a',      0,          1),
)
word_table = (
    # pattern   s           i,  j   expected, expected_i, expected_j
    ('a',       'abaAca',   0, -1,  '',      -1,          -1),
    ('A',       'AA A AAB', 0, -1,  'A',      3,          4),
)
test(plain_table,  'plain_table',  nocase=False, word=False)
test(nocase_table, 'nocase_table', nocase=True,  word=False)
test(word_table,   'word_table',   nocase=False, word=True)
#@+node:ekr.20190608143503.1: *5* @test find.replace_back_slashes
import leo.core.leoFind as leoFind
x = leoFind.LeoFind(c)
table = (
    ('\\\\', '\\'),
    ('\\n', '\n'),
    ('\\t', '\t'),
)
for s, expected in table:
    got = x.replace_back_slashes(s)
    assert expected==got, (
        '\n         s: %r'
        '\n  expected: %r'
        '\n       got: %r'
        % (s, expected, got))
#@+node:ekr.20071113202153: *4* @test zz end of leoFind tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoFind tests.')
#@+node:ekr.20071113194424: *3* leoFrame
# 3 failures with Alt-5
#@+node:ekr.20061106201509.6: *4* @test c.frame.body.getInsertLines
# line 1
# line 2
# line 3

w = c.frame.body.wrapper
index = 11 # in the second line.
w.setInsertPoint(index)
before,ins,after = c.frame.body.getInsertLines()
assert before == '# line 1\n','Got %s' % repr(before)
assert ins    == '# line 2\n','Got %s' % repr(ins)
assert after.startswith('# line 3\n'),'line3'
assert after.endswith('# end.\n'),'end'

# end.
#@+node:ekr.20061106201509.7: *4* @test c.frame.body.getSelectionAreas
# line 1
# line 2
# line 3

w = c.frame.body.wrapper
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
#@+node:ekr.20071113145804.32: *4* @test c.frame.body.getSelectionAreas & test
# line 1
# line 2
# line 3

w = c.frame.body.wrapper
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
#@+node:ekr.20111121152019.3929: *4* @test c.frame.body.updateEditors
'''updateEditors was crashing due to calling setSelectionRange(ins=i).
The proper keyword argument is insert=i.
'''

c.frame.body.updateEditors()
#@+node:ekr.20111107065530.3833: *4* @test c.frame.resize-to-screen
# The actual code contains the unit test.
# This test will have effect only when run locally.

if not g.app.gui.guiName().startswith('qt'):
    self.skipTest('Requires Qt')

d = g.app.unitTestDict
tag = 'resize-to-screen'
assert not d.get(tag)
c.frame.resizeToScreen()
assert d.get(tag) is True
#@+node:ekr.20100131180007.5359: *4* @test c.frame.tree.OnIconDoubleClick
c.frame.tree.OnIconDoubleClick(p)
#@+node:ekr.20071113202153.1: *4* @test zz end of leoFrame tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoFrame tests.')
#@+node:ekr.20071113194033.3: *3* leoGlobals
# No failures with Alt-5 but warnings about no tnode lists.
#@+node:ekr.20100131180007.5398: *4* @test g.adjustTripleString
if 0: # The following must be indented.

    s = '''\
    a
      b

c
    d'''

    s2 = '    a\n      b\n\nc\n    d'

    result = g.adjustTripleString(s,c.tab_width)
    # print(c.tab_width)
    # print(result)
    # print('=====')
    # print(s2)
    assert result == s2,repr(result)
#@+node:ekr.20110510054817.3476: *4* @test g.alert
g.alert(c,'test of g.alert')
#@+node:ekr.20060921115303: *4* @test g.checkVersion
# for condition in ('<','<=','>','>='):

for v1,condition,v2 in (
    ('8.4.12','>','8.4.3'),
    ('1','==','1.0'),
    ('2','>','1'),
    ('1.2','>','1'),
    ('2','>','1.2.3'),
    ('1.2.3','<','2'),
    ('1','<','1.1'),
):
    assert g.CheckVersion(v1,v2,condition=condition,trace=False)
#@+node:ekr.20071113143844.9: *4* @test g.CheckVersionToInt
assert g.CheckVersionToInt('12') == 12,'fail 1'
assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
assert g.CheckVersionToInt('b2') == 0, 'fail 3'
#@+node:ekr.20100131180007.5428: *4* @test g.comment_delims_from_extension
# New in Leo 4.6, set_delims_from_language returns '' instead of None.
table = (
    ('.c',      ('//','/*','*/')),
    ('.html',   ('', '<!--', '-->')),
    ('.py',     ('#','','')),
    ('.xxx',    ('','','')),
)

for ext, expected in table:
    result = g.comment_delims_from_extension(ext)
    assert result==expected,'ext %s expected %s, got %s' % (
        ext,expected,result)
#@+node:ekr.20071113145804.26: *4* @test g.convertPythonIndexToRowCol
s1 = 'abc\n\np\nxy'
table1 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too many.
    (10,(3,2)), # Two too many.
)
s2 = 'abc\n\np\nxy\n'
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One too many.
    (11,(4,0)), # Two too many.
)
s3 = 'ab' # Test special case.  This was the cause of off-by-one problems.
table3 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)), # One too many.
    (3,(0,3)), # Two too many.
)

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        row,col = g.convertPythonIndexToRowCol(s,i)
        assert row == result[0], 'i: %d, expected row %d, got %d' % (i,result[0],row)
        assert col == result[1], 'i: %d, expected col %d, got %d' % (i,result[1],col)
#@+node:ekr.20071113145804.27: *4* @test g.convertRowColToPythonIndex
s1 = 'abc\n\np\nxy'
s2 = 'abc\n\np\nxy\n'
table1 = (
    (0,(-1,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too large.
)
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One two many.
)
for s,table in ((s1,table1),(s2,table2)):
    for i,data in table:
        row,col = data
        result = g.convertRowColToPythonIndex(s,row,col)
        assert i == result, 'row: %d, col: %d, expected: %d, got: %s' % (row,col,i,result)
#@+node:ekr.20071113145804.21: *4* @test g.create_temp_file
theFile = None
try:
    theFile,fn = g.create_temp_file()
    assert theFile
    assert isinstance(fn, str)
finally:
    if theFile:
        theFile.close()
#@+node:ekr.20100131180007.5403: *4* @test g.ensureLeadingNewlines
s = ' \n \n\t\naa bc'
s2 = 'aa bc'

for i in range(3):
    result = g.ensureLeadingNewlines(s,i)
    val = ('\n' * i) + s2
    assert result == val, 'expected %s, got %s' % (
        repr(val),repr(result))
#@+node:ekr.20100131180007.5404: *4* @test g.ensureTrailingNewlines
s = 'aa bc \n \n\t\n'
s2 = 'aa bc'

for i in range(3):
    result = g.ensureTrailingNewlines(s,i)
    val = s2 + ('\n' * i)
    assert result == val, 'expected %s, got %s' % (
        repr(val),repr(result))
#@+node:ekr.20140702101937.4245: *4* @test g.find_word
table = (
    ('abc a bc x','bc',0,6),
    ('abc a bc x','bc',1,6),
    ('abc a x','bc',0,-1),
)
for s,word,i,expected in table:
    actual = g.find_word(s,word,i)
    assert actual == expected
#@+node:ekr.20180128105733.1: *4* @test g.findNode*
trace = False
skipped = 0
p0 = p.copy()
p2 = g.findNodeAnywhere(c,'@test g.findNode*')
assert p2 and p2.v == p.v, ('1', repr(p2), repr(p))
p2 = g.findNodeAnywhere(c,'@test g.findNode',exact=False)
assert p2 and p2.v == p.v, ('2', repr(p2), repr(p))
#
parent = p0.parent()
if parent: # Will fail for a top-level clone
    p2 = g.findNodeInChildren(c,parent,'@test g.findNode*')
    assert p2 and p2.v == p.v, ('3', repr(p2), repr(p))
    p2 = g.findNodeInChildren(c,parent,'@test g.findNode',exact=False)
    assert p2 and p2.v == p.v, ('4', repr(p2), repr(p))
else:
    skipped += 1
#
parent = p0.parent()
if parent: # Will fail for a top-level clone
    p2 = g.findNodeInTree(c,parent,'@test g.findNode*')
    assert p2 and p2.v == p.v, ('5', repr(p2), repr(p))
    p2 = g.findNodeInTree(c,parent,'@test g.findNode',exact=False)
    assert p2 and p2.v == p.v, ('6', repr(p2), repr(p))
else:
    skipped += 1
#
p1 = g.findTopLevelNode(c,'Active Unit Tests')
if p1:
    p2 = g.findTopLevelNode(c,'Active Unit Test',exact=False)
    assert p2 and p2.v == p1.v, ('7', repr(p2), repr(p1))
    p2 = g.findNodeInTree(c,p1,'@test g.findNode*')
    assert p2 and p2.v == p.v, ('8', repr(p2), repr(p))
    p2 = g.findNodeInTree(c,p1,'@test g.findNode',exact=False)
    assert p2 and p2.v == p.v, ('9', repr(p2), repr(p))
else:
    skipped += 1
if trace and skipped:
    print('%s: skipped %s sub-tests' % (p0.h, skipped))
#@+node:ekr.20100131180007.5455: *4* @test g.fullPath
p2 = p.firstChild().firstChild()
path = g.fullPath(c,p2,simulate=True)
end = g.os_path_normpath('abc/xyz')
assert path.endswith(end),repr(path)
#@+node:ekr.20100131180007.5456: *5* @path abc
#@+node:ekr.20100131180007.5457: *6* xyz
#@+node:ekr.20071113090055.5: *4* @test g.get_directives_dict
# This will work regardless of where this method is.
@language python
@tabwidth -4
# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.
@pagewidth 120

d = c.atFileCommands.scanAllDirectives(p)
assert d.get('language') == 'python'
assert d.get('tabwidth') == -4
# assert d.get('path').endswith('xyzzy')
assert d.get('pagewidth') == 120
#@+node:ekr.20100131180007.5434: *4* @test g.get_directives_dict 2
@language python
@comment a b c
    # @comment must follow @language.
@tabwidth -8
@pagewidth 72
@encoding utf-8
# @path: anError # @path ends with ':'.

# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.

d = g.get_directives_dict(p)

# assert d.get('_p') == p # Never used, and a bad idea.
assert d.get('language') == 'python'
assert d.get('tabwidth') == '-8'
assert d.get('pagewidth') == '72'
assert d.get('encoding') == 'utf-8'
assert d.get('comment') == 'a b c'
assert not d.get('path'),d.get('path')
# assert d.get('path').endswith('xyzzy')
#@+node:ekr.20111018163546.3690: *4* @test g.getDocString
s1 = 'no docstring'
s2 = '''
# comment
"""docstring2."""
'''
s3 = '''
"""docstring3."""
\'\'\'docstring2.\'\'\'
'''

table = (
    (s1,''),
    (s2,'docstring2.'),
    (s3,'docstring3.'),
)

for s,result in table:
    s2 = g.getDocString(s)
    assert s2 == result,'Expected %s, got %s' % (repr(result),repr(s2))
#@+node:ekr.20061104172236.18: *4* @test g.getLine
s = 'a\ncd\n\ne'

for i,result in (
    (-1,(0,2)), # One too few.
    (0,(0,2)),(1,(0,2)),
    (2,(2,5)),(3,(2,5)),(4,(2,5)),
    (5,(5,6)),
    (6,(6,7)),
    (7,(6,7)), # One too many.
):
    j,k = g.getLine(s,i)
    assert (j,k) == result, 'i: %d, expected %d,%d, got %d,%d' % (i,result[0],result[1],j,k)
#@+node:ekr.20071113145804.28: *4* @test g.getScript strips crlf
script = g.getScript(c,p) # This will get the text of this node.
assert script.find('\r\n') == -1, repr(script)
#@+node:ekr.20061104172236.11: *4* @test g.getWord
s = 'abc xy_z5 pdq'
i,j = g.getWord(s,5)
assert s[i:j] == 'xy_z5','got %s' % s[i:j]
#@+node:ekr.20110612064437.3310: *4* @test g.guessExternalEditor
val = g.guessExternalEditor(c)
assert val,'no val' # This can be different on different platforms.
#@+node:ekr.20120307133953.3947: *4* @test g.handleUrl
import sys
if sys.platform.startswith('win'):
    file_, http, unl1 = 'file://', 'http://', 'unl:' + '//'
    fn1 = 'LeoDocs.leo#'
    fn2 = 'doc/LeoDocs.leo#'
    unl2 = '@settings-->Plugins-->wikiview plugin'
    unl3 = '@settings-->Plugins-->wikiview%20plugin'
    table = (
        (http + 'writemonkey.com/index.php', ['browser']),
        (file_ + 'x.py',        ['os_startfile']),
        (file_ + fn1,           ['g.recursiveUNLSearch']),
        (file_ + fn2,           ['g.recursiveUNLSearch']),
        (unl1 + fn1 + unl2,     ['g.recursiveUNLSearch']),
        (unl1 + fn1 + unl3,     ['g.recursiveUNLSearch']),
        (unl1 + '#' + unl2,     ['g.recursiveUNLSearch']),
        (unl1 + '#' + unl3,     ['g.recursiveUNLSearch']),
        (unl1 + unl2,           ['g.recursiveUNLSearch']),
        (unl1 + unl3,           ['g.recursiveUNLSearch']),
    )
    d = g.app.unitTestDict
    for url,aList in table:
        d = g.app.unitTestDict = {}
        g.handleUrl(c=c,p=c.p,url=url)
        for kind in aList:
            assert d.get(kind), 'kind: %r\nurl: %r\n%s' % (
                kind,url,g.dictToString(d))
#@+node:ekr.20141208130803.11: *4* @test g.import_module
assert g.import_module('leo.core.leoAst')
    # Top-level .py file.
#@+node:ekr.20170122164330.1: *4* @test g.isDirective
# Do not try to reload g.
table = (
    (True, '@language python\n'),
    (True, '@tabwidth -4 #test\n'),
    (True, '@others\n'),
    (True, '    @others\n'),
    (True, '@encoding\n'),
    (False, '@encoding.setter\n'),
    (False, '@encoding("abc")\n'),
    (False, 'encoding = "abc"\n'),
)
for expected, s in table:
    result = g.isDirective(s)
    assert expected == bool(result), (expected, bool(result), repr(s))
#@+node:ekr.20170601070526.1: *4* @test g.match_word
table = (
    (True, 0, 'a', 'a'),
    (False, 0, 'a', 'b'),
    (True, 0, 'a', 'a b'),
    (False, 1, 'a', 'aa b'), # Tests bug fixed 2017/06/01.
    (False, 1, 'a', '_a b'),
    (False, 0, 'a', 'aw b'),
    (False, 0, 'a', 'a_'),
    (True, 2, 'a', 'b a c'),
    (False, 0, 'a', 'b a c'),
)
for data in table:
    expected, i, word, line = data
    got = g.match_word(line + '\n', i, word)
    assert expected == got, (expected, i, word, line)
# print('done')
#@+node:ekr.20111104112332.3953: *4* @test g.os_path_finalize_join with thumb drive
import os

path1 = r'C:\Python32\Lib\site-packages\leo-editor\leo\core'
path2 = r'\N:Home\PTC_Creo\Creo.wmv'
path3 = r'N:\Home\PTC_Creo\Creo.wmv'

path12 = os.path.join(path1,path2)
path13 = os.path.join(path1,path3)

if 0:
    print(path12,g.os.path.abspath(path12))
    print(path13,g.os.path.abspath(path13))
#@+node:ekr.20071113145804.19: *4* @test g.pdb
# This test causes segmentation fault on Linux
# vitalije: 27-03-2020
self.skipTest("causes seg-fault on Linux")
import sys

# Not a good unit test; it probably will never fail.
def aFunction(): pass
assert type(g.pdb)==type(aFunction), 'wrong type for g.pdb: %s' % type(g.pdb)

class myStdout:
    def write(self,s):
        pass # g.es('From pdb:',s)

class myStdin:
    def readline (self):
        return 'c' # Return 'c' (continue) for all requests for input.

def restore():
    sys.stdout,sys.stdin = sys.__stdout__,sys.__stdin__

try:
    sys.stdin = myStdin() # Essential
    sys.stdout=myStdout() # Optional
    g.pdb()
    restore()
    # assert False,'test of reraising'
except Exception:
    restore()
    raise
#@+node:ekr.20100131180007.5396: *4* @test g.removeBlankLines
for s,expected in (
    ('a\nb', 'a\nb'),
    ('\n  \n\nb\n', 'b\n'),
    (' \t \n\n  \n c\n\t\n', ' c\n'),
):
    result = g.removeBlankLines(s)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
#@+node:ekr.20071113145804.29: *4* @test g.removeExtraLws
self.skipTest('g.removeExtraLws no longer exists')
for s,expected in (
    (' a\n b\n c', 'a\nb\nc'),
    (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
):
    result = g.removeExtraLws(s,c.tab_width)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
#@+node:ekr.20100131180007.5395: *4* @test g.removeLeadingBlankLines
for s,expected in (
    ('a\nb', 'a\nb'),
    ('\n  \nb\n', 'b\n'),
    (' \t \n\n\n c', ' c'),
):
    result = g.removeLeadingBlankLines(s)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
#@+node:ekr.20100131180007.5402: *4* @test g.removeTrailing
s = 'aa bc \n \n\t\n'
table = (
    ('\t\n ','aa bc'),
    ('abc\t\n ',''),
    ('c\t\n ','aa b'),
)

for arg,val in table:
    result = g.removeTrailing(s,arg)
    assert result == val, 'expected %s, got %s' % (val,result)
#@+node:ekr.20150328120706.1: *4* @test g.sanitize_filename
table = (
    ('A25&()','A'),         # Non-alpha characters.
    ('B\tc','B c'),         # Tabs.
    ('"AB"',"'AB'"),        # Double quotes.
    ('\\/:|<>*:.','_'),     # Special characters.
    ('_____________','_'),  # Combining underscores.
    ('A' * 200,'A' * 128),  # Maximum length.
    ('abc.','abc_'),        # Trailing dots.
)
for s,expected in table:
    got = g.sanitize_filename(s)
    assert got==expected,'s: %r expected: %r got: %r' % (s,expected,got)
#@+node:ekr.20080917151620.13: *4* @test g.scanAtHeaderDirectives header
@header

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
#@+node:ekr.20100131180007.5435: *4* @test g.scanAtHeaderDirectives header
@header

c,p = g.getTestVars()
aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
#@+node:ekr.20080917151620.14: *4* @test g.scanAtHeaderDirectives noheader
@noheader

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
#@+node:ekr.20080917151620.15: *4* @test g.scanAtLineendingDirectives cr
@lineending cr

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\r'
#@+node:ekr.20080917151620.16: *4* @test g.scanAtLineendingDirectives crlf
@lineending crlf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)
assert s == '\r\n', repr(s)

#@+node:ekr.20080917151620.17: *4* @test g.scanAtLineendingDirectives lf
@lineending lf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
#@+node:ekr.20080917151620.18: *4* @test g.scanAtLineendingDirectives nl
@lineending nl

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
#@+node:ekr.20080917151620.19: *4* @test g.scanAtLineendingDirectives platform
@lineending platform

import sys

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

if sys.platform.startswith('win'):
    assert s == '\r\n'
else:
    assert s == '\n'
#@+node:ekr.20100131180007.5442: *4* @test g.scanAtPagewidthDirectives -40
@pagewidth -40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

# The @pagewidth directive in the parent should control.
# Depending on how this test is run, the result could be 80 or None.
assert n in (None,80),repr(n)
#@+node:ekr.20080917151620.21: *4* @test g.scanAtPagewidthDirectives 40
@pagewidth 40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

assert n == 40
#@+node:ekr.20080917151620.22: *4* @test g.scanAtPathDirectives ../test/unittest/at-path-test1.py
aList = g.get_directives_dict_list(p.firstChild())
s = c.scanAtPathDirectives(aList)
end = g.os_path_normpath(r'leo/test')

assert s.endswith(end),repr(s)
#@+node:ekr.20120228145505.4834: *5* @thin ../test/unittest/at-path-test1.py
@language python
# unittest/at-path-test1.py 
#@+node:ekr.20080917151620.27: *4* @test g.scanAtPathDirectives @path ../test @path unittest @thin at-path-test3.py
greatGrandChild = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(greatGrandChild)
s = c.scanAtPathDirectives(aList)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)
#@+node:ekr.20080917151620.28: *5* @path ../test
#@+node:ekr.20080917151620.29: *6* @path unittest
#@+node:ekr.20120228145505.4838: *7* @thin at-path-test3.py
@language python
# unittest/at-path-test3.py 
#@+node:ekr.20080917151620.24: *4* @test g.scanAtPathDirectives @path ../test/unittest @thin at-path-test2.py
grandChild = p.firstChild().firstChild()
aList = g.get_directives_dict_list(grandChild)
s = c.scanAtPathDirectives(aList)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)
#@+node:ekr.20080917151620.25: *5* @path ../test/unittest
#@+node:ekr.20120228145505.4841: *6* @thin at-path-test2.py
@language python
# unittest/at-path-test2.py
#@+node:ekr.20080917151620.31: *4* @test g.scanAtTabwidthDirectives +6
@tabwidth 6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == 6,repr(n)
#@+node:ekr.20080917151620.32: *4* @test g.scanAtTabwidthDirectives -6
@tabwidth -6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == -6
#@+node:ekr.20080917151620.33: *4* @test g.scanAtWrapDirectives nowrap
@nowrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is False,repr(s)
#@+node:ekr.20080917151620.34: *4* @test g.scanAtWrapDirectives wrap (with @wrap)
@wrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is True,repr(s)
#@+node:ekr.20080917151620.35: *4* @test g.scanAtWrapDirectives wrap (without @nowrap)
aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is None,repr(s)
#@+node:ekr.20100131180007.5426: *4* @test g.set_delims_from_language
# New in Leo 4.6, set_delims_from_language returns '' instead of None.
table = (
    ('c',       ('//','/*','*/')),
    ('python',  ('#','','')),
    ('xxxyyy',  ('','','')),
)

for language, expected in table:
    result = g.set_delims_from_language(language)
    assert result==expected,'language %s expected %s, got %s' % (
        language,expected,result)
#@+node:ekr.20100131180007.5425: *4* @test g.set_delims_from_string
# New in Leo 4.6, set_delims_from_string returns '' instead of None.
table = (
    ('c','@comment // /* */',   ('//','/*','*/')),
    ('c','// /* */',            ('//','/*','*/')),
    ('python','@comment #',     ('#','','')),
    ('python','#',              ('#','','')),
    ('xxxyyy','@comment a b c', ('a','b','c')),
    ('xxxyyy','a b c',          ('a','b','c')),
)

for language,s,expected in table:
    result = g.set_delims_from_string(s)
    assert result==expected,'language %s expected %s, got %s' % (
        language,expected,result)
#@+node:ekr.20100131180007.5421: *4* @@@@test g.setDefaultDirectory
c,p = g.getTestVars()

# result,error = g.setDefaultDirectory(c,p,importing=False)
# assert error == ''
# assert result == c.openDirectory,result

result = g.setDefaultDirectory(c,p,importing=False)
assert result == c.openDirectory,result
#@+node:sps.20100609234650.16094: *4* @test g.skip_blank_lines
end = g.skip_blank_lines("",0)
assert end == 0, "expected 0, got %d" % end
end = g.skip_blank_lines(" ",0)
assert end == 0, "expected 0, got %d" % end
end = g.skip_blank_lines("\n",0)
assert end == 1, "expected 1, got %d" % end
end = g.skip_blank_lines(" \n",0)
assert end == 2, "expected 1, got %d" % end
end = g.skip_blank_lines("\n\na\n",0)
assert end == 2, "expected 2, got %d" % end
end = g.skip_blank_lines("\n\n a\n",0)
assert end == 2, "expected 2, got %d" % end
#@+node:ekr.20061104172236.15: *4* @test g.skip_line
s = 'a\n\nc'

for i,result in (
    (-1,2), # One too few.
    (0,2),(1,2),
    (2,3),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
#@+node:ekr.20061104172236.16: *4* @test g.skip_to_end_of_line
s = 'a\n\nc'

for i,result in (
    (-1,1), # One too few.
    (0,1),(1,1),
    (2,2),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_to_end_of_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
#@+node:ekr.20061104172236.17: *4* @test g.skip_to_start_of_line
s1 = 'a\n\nc'
table1 = (
    (-1,0), # One too few.
    (0,0),(1,0),
    (2,2),
    (3,3),
    (4,4), # One too many.
)
s2 = 'a\n'
table2 = ((1,0),(2,2)) # A special case at end.

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        j = g.skip_to_start_of_line(s,i)
        assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
#@+node:ekr.20150610130646.1: *4* @test g.splitLongFileName
table = (
    r'abcd/xy\pdqabc/aaa.py',
)
for s in table:
    g.splitLongFileName(s,limit=3)
    
#@+node:ekr.20100131180007.5427: *4* @test g.stripPathCruft
table =  (
    (None,None), # Retain empty paths for warnings.
    ('',''),
    (g.app.loadDir,g.app.loadDir),
    ('<abc>','abc'),
    ('"abc"','abc'),
    ("'abc'",'abc'),
)

for path,expected in table:
    result = g.stripPathCruft(path)
    assert result == expected
#@+node:ekr.20100131180007.5429: *4* @test g.warnOnReadOnlyFile
import os,stat

fc = c.fileCommands
path = g.os_path_finalize_join(g.app.loadDir,'..','test','test-read-only.txt')
if os.path.exists(path):
    os.chmod(path, stat.S_IREAD)
    fc.warnOnReadOnlyFiles(path)
    assert fc.read_only
else:
    fc.warnOnReadOnlyFiles(path)
#@+node:ekr.20050208135429: *4* @test pre-definition of g in scripts
for ivar in ('c','g','p'):
    assert ivar in dir()
#@+node:ekr.20071113202153.2: *4* @test zz end of leoGlobals tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoGlobals tests.')
#@+node:ekr.20100131171342.5604: *3* leoKeys
#@+node:ekr.20100131171342.5608: *4* @test g.KeyStroke
table = [
    # Gang of four, unmodified)
    ('bksp', 'BackSpace'),
    ('backspace', 'BackSpace'),
    ('backtab', 'Tab'),
    ('linefeed', '\n'),
    ('\r', '\n'),
    ('return', '\n'),
    ('tab', 'Tab'),
    # Gang of four, with shift mod.
    ('Shift-bksp', 'Shift+BackSpace'),
    ('Shift-backspace', 'Shift+BackSpace'),
    ('Shift-backtab', 'Shift+Tab'),
    ('Shift-linefeed', 'Shift+Return'),
    ('Shift-\r', 'Shift+Return'),
    ('Shift-return', 'Shift+Return'),
    ('Shift-tab', 'Shift+Tab'),
    # Gang of four, with Alt mod.
    ('Alt-bksp', 'Alt+BackSpace'),
    ('Alt-backspace', 'Alt+BackSpace'),
    ('Alt-backtab', 'Alt+Tab'),
    ('Alt-linefeed', 'Alt+Return'),
    ('Alt-\r', 'Alt+Return'),
    ('Alt-return', 'Alt+Return'),
    ('Alt-tab', 'Alt+Tab'),
    #
    # #912: tilde.
    ('~', '~'),
    ('Shift-~', '~'),
    #
    # Alpha
    ('1', '1'),
    ('a','a'),
    ('A','A'),
    ('Alt-a','Alt+a'),
    ('Alt-A','Alt+a'),
    ('Alt-Shift-a','Alt+Shift+a'),
    # We can no longer ignore the shift.
    # ('Alt-Shift++','Alt+plus'), # Ignore the shift.
    ('Shift-a','A'),
    ('Shift-A','A'),
    ('RtArrow','Right'),
    ('Shift-RtArrow','Shift+Right'),
    ('PageUp','Prior'),
    ('Prior','Prior'),
    ('Shift-PageUp','Shift+Prior'),
    ('PageDn','Next'),
    ('Next','Next'),
    ('Shift-Next','Shift+Next'),
    ('Alt-=','Alt+='),
    ('Alt-+','Alt++'),
    ('Alt--','Alt+-'),
    ('Ctrl-RtArrow','Ctrl+Right'),
    ('Control-Right','Ctrl+Right'),
]
for setting, result in table:
    stroke = g.KeyStroke(binding=setting)
    val = stroke.s
    assert val==result,'For %r, expected %r, Got %r' % (setting, result,val)
#@+node:ekr.20180527141026.1: *4* @test g.KeyStroke (printable characters)
import string
# Unshifted.
for ch in string.printable:
    stroke = g.KeyStroke(binding=ch)
    assert stroke.s in string.printable, (repr(ch), repr(stroke.s))
    if ch == '\r':
        assert stroke.s == '\n', (repr(ch), repr(stroke.s))
    else:
        assert stroke.s == ch, (repr(ch), repr(stroke.s))
# Shifted.
for ch in string.digits + string.ascii_letters:
    stroke = g.KeyStroke(binding='Shift-'+ch)
    assert stroke.s in string.printable, (repr(ch), repr(stroke.s))
#@+node:ekr.20110509104953.3474: *4* @test k.get_leo_completions
table = (
    ( 50,'c.'),
    (  3,'p.ins'),
    ( 17,'g.print'),
)
g.pr
ac = c.k.autoCompleter
ac.w = c.frame.body.wrapper
for expected,prefix in table:
    aList = ac.get_leo_completions(prefix)
    assert len(aList) >= expected,'len(aList): %s, prefix: %s' % (len(aList),prefix)
#@+node:ekr.20100131171342.5605: *4* @test k.isPlainKey
import string
k = c.k
for ch in (string.printable):
    assert k.isPlainKey(ch), 'not plain: %s' % (repr(ch))
if 0:
    # The NullGui class knows nothing about these characters,
    # so these tests now fail.
    # Happily, there is a continuous unit test in k.checkKeyEvent.
    special = (
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )
    for ch in special:
        assert not k.isPlainKey(ch), 'is plain: %s' % (ch)
#@+node:ekr.20100212110954.5359: *4* @test k.print-bindings
lines = c.k.printBindings()
# assert lines[0].strip().endswith('Alt+Ctrl+Shift')
#@+node:ekr.20100131171342.5607: *4* @test k.registerCommand
k = c.k ; p = c.p
w = c.edit_widget(p)
commandName = 'test-registerCommand'

def callback (event=None,c=c): # Must have an event param to pass later unit test.
    g.app.unitTestDict[commandName] = True

# Test 1
g.app.unitTestDict[commandName] = False
# k.registerCommand(commandName,callback,pane='all',shortcut='Alt-Ctrl-Shift-z',verbose=True)
k.registerCommand(commandName,callback)
k.simulateCommand(commandName)
assert g.app.unitTestDict.get(commandName)

if 0: # Test 2
    g.app.unitTestDict[commandName] = False
    k.manufactureKeyPressForCommandName(w,commandName)
    assert g.app.unitTestDict.get(commandName)
#@+node:ekr.20100131171342.5609: *4* @test zz end of leoKeys tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoKeys tests.')
#@+node:ekr.20140712142620.4458: *3* leoPersistence tests (do not clone)
#@+node:ekr.20140712142620.4503: *4* @test p.sort_key
aList = [p.copy() for p in c.all_positions()]
aList2 = sorted(reversed(aList),key=p.sort_key)
i = 0
for p in aList2:
    p2 = aList[i]
    i += 1
    assert p == p2,'\n%s:%s\n%s:%s' % (
        p.sort_key(p),p.h,p2.sort_key(p2),p2.h)
#@+node:ekr.20140712142620.4550: *4* @test pd.find_at_...
# Also a test of find_at_views_node, find_at_organizers_node and find_at_clones_node.
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    try:
        persistence = pd.find_at_persistence_node()
        assert persistence
        persistence.deleteAllChildren()
        root.h = '@auto root' # Make root look like an @auto node.
        assert pd.find_at_data_node(root)
        assert pd.find_at_gnxs_node(root)
    finally:
        root.h = 'root' # Make sure root is *not* an @auto node.
        # views.deleteAllChildren()
        c.selectPosition(p)
        c.redraw()
#@+node:ekr.20140712142620.4551: *5* root
#@+node:ekr.20140712142620.4552: *6* aClass
class aClass:
    @others
#@+node:ekr.20140712142620.4556: *7* clone
#@+node:ekr.20140712142620.4556: *5* clone
#@+node:ekr.20140712142620.4538: *4* @test pd.find_at_persistence_node
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    h = '@persistence'
    p1 = pd.find_at_persistence_node()
    assert p1
    p2 = pd.has_at_persistence_node()
    assert p1 == p2,(p1,p2)
#@+node:ekr.20140712142620.4539: *4* @test pd.find_position_for_relative_unl
pd = c.persistenceController
parent = p.copy()
node1 = p.firstChild()
node2 = node1.next()
node3 = node2.next()
assert node1 and node2 and node3
child11 = node1.firstChild()
child12 = child11.next()
assert child11 and child12
child21 = node2.firstChild()
child22 = child21.next()
assert child21 and child22
node3_child1 = node3.firstChild()
assert node3_child1
node3_child1_child21 = node3_child1.firstChild()
assert node3_child1_child21
table = (
    ('node1',node1),
    ('',parent), # This special case is important.
    ('node1-->child11',child11),
    ('node1-->child12',child12),
    ('node2',node2),
    ('node2-->child21',child21),
    ('node2-->child22',child22),
    # Partial matches.
    ### ('node3-->child1-->child21',node3_child1_child21),
    ### ('child1-->child21',node3_child1_child21),
    ### ('xxx-->child21',node3_child1_child21),
        # This is ambiguous.
    # No matches.
    ('nodex',None),
    ('node1-->childx',None),
    ('node3-->childx',None),
)
for unl,expected in table:
    got = pd.find_position_for_relative_unl(parent,unl)
    assert got == expected,'unl: %s expected: %s got: %s' % (
        unl,expected and expected.h,got and got.h)
#@+node:ekr.20140712142620.4540: *5* node1
#@+node:ekr.20140712142620.4541: *6* child11
#@+node:ekr.20140712142620.4542: *6* child12
#@+node:ekr.20140712142620.4543: *5* node2
#@+node:ekr.20140712142620.4544: *6* child21
#@+node:ekr.20140712142620.4545: *6* child22
#@+node:ekr.20140715080507.4340: *5* node3
#@+node:ekr.20140715080507.4341: *6* node3_child1
#@+node:ekr.20140715080507.4339: *7* child21
#@+node:ekr.20140712142620.4546: *4* @test pd.find_representative_node
if g.app.isExternalUnitTest:
    # There will not be a proper cloned node in the copy of these tests.
    self.skipTest('Can not be run externally')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    root.h = '@auto root'
    try:
        clone = root.next()
        assert clone and clone.h == 'clone'
        inner_clone = root.firstChild()
        assert inner_clone
        assert clone.v == inner_clone.v
        rep = pd.find_representative_node(root,inner_clone)
        # Careful: cloning this test can cause problems.
        oops = '\n  rep: %s\nparent:%s\nclone: %s\nparent:%s\ninner: %s\nparent: %s' % (
            rep,rep.parent(),clone,clone.parent(),inner_clone,inner_clone.parent())
        if g.app.isExternalUnitTest:
            pass
        else:
            assert rep == clone,(repr(rep),repr(clone))
    finally:
        root.h = 'root' # root must not be an @auto node.
        c.redraw()
#@+node:ekr.20140712142620.4547: *5* root
#@+node:ekr.20140712142620.4549: *6* clone
#@+node:ekr.20140712142620.4549: *5* clone
#@+node:ekr.20140712142620.4557: *4* @test pd.has_..._node
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    # Test pd.has_at_auto_view_node, pd.has_at_clones_node and pd.has_at_organizers_node.
    pd = c.persistenceController
    persistence = g.findNodeAnywhere(c,'@persistence')
    assert persistence
    assert pd.has_at_persistence_node()
    persistence.deleteAllChildren()
    assert persistence
    root = g.findNodeInTree(c,p,'root')
    assert root
    # The representative of clone_test node must appear outside of root's tree.
    clone_test = g.findNodeInTree(c,p,'clone-test')
    if g.app.isExternalUnitTest:
        # There will not be a proper node in the copied tree.
        self.skipTest('Can not be run externally')
    else:
        assert clone_test
        assert clone_test.v == root.next().v,(clone_test.v,root.next().v)
        try:
            root.h = '@auto root' # Make root look like an @auto node.
            pd.update_before_write_foreign_file(root)
            data = g.findNodeInTree(c,persistence,'@data:@auto root')
            assert data
            data2 = pd.has_at_data_node(root)
            assert data2
            assert data == data2,(data,data2)
            gnxs = g.findNodeInTree(c,persistence,'@gnxs')
            assert gnxs
            gnxs2 = pd.has_at_gnxs_node(root)
            assert gnxs2
            assert gnxs == gnxs2,(gnxs,gnxs2)
        finally:
            root.h = 'root' # Make the root *not* an @auto node.
            c.redraw()
#@+node:ekr.20140712142620.4558: *5* root
@others
#@+node:ekr.20140712142620.4559: *6* aClass
class aClass:
    @others
#@+node:ekr.20140712142620.4563: *7* clone-test
def clone_test():
    pass
#@+node:ekr.20140712142620.4561: *7* organizer node
#@+node:ekr.20140712142620.4562: *8* child2
def spam():
    pass
#@+node:ekr.20140712142620.4563: *5* clone-test
def clone_test():
    pass
#@+node:ekr.20140712142620.4507: *4* @test pd.restore_gnxs
pd = c.persistenceController
gnxs = g.findNodeInTree(c,p,'@gnxs')
root = g.findNodeInTree(c,p,'root')
node1 = g.findNodeInTree(c,p,'node1')
assert gnxs and root and node1
root.deleteAllChildren()
new_node1 = root.insertAsLastChild()
new_node1.h = 'node1'
gnxs.b = 'gnx: %s\nunl: %s\n' % (node1.v.gnx,'node1')
try:
    pd.restore_gnxs(gnxs,root)
    # Important: p._relinkAsCloneOf leaves new_node1 unchanged,
    # but new_node1 should not be used.
finally:
    c.redraw()
#@+node:ekr.20140712142620.4508: *5* @gnxs
gnx: ekr.20140923080452.6565
unl: node1
#@+node:ekr.20140923080452.6565: *5* node1
#@+node:ekr.20140712142620.4510: *5* root
#@+node:ekr.20140923080452.6565: *6* node1
#@+node:ekr.20140712142620.4574: *4* @test pd.unl
pd = c.persistenceController
unl = pd.unl(p)
expected = p.h if g.app.isExternalUnitTest else '-->'+p.h
assert unl.endswith(expected),repr(unl)
#@+node:ekr.20140712142620.4575: *4* @test pd.update_before_write_foreign_file
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    root = g.findNodeInTree(c,p,'root')
    assert root
    persistence = pd.find_at_persistence_node()
    assert persistence
    persistence.deleteAllChildren()
    try:
        root.h = '@auto root' # Make root look like an @auto node.
        pd.update_before_write_foreign_file(root)
        data = g.findNodeAnywhere(c,'@data:@auto root')
        assert data
        gnxs = g.findNodeInTree(c,data,'@gnxs')
        assert gnxs
    finally:
        root.h = 'root' # Make root *not* an @auto node.
        # persistence.deleteAllChildren()
        c.redraw()
#@+node:ekr.20140712142620.4576: *5* root
#@+node:ekr.20140712142620.4577: *6* aClass
class aClass:
    @others
#@+node:ekr.20140712142620.4582: *7* clone
#@+node:ekr.20140712142620.4579: *6* organizer node
#@+node:ekr.20140712142620.4580: *7* child1
#@+node:ekr.20140712142620.4581: *7* child2
def spam():
    pass
#@+node:ekr.20140712142620.4582: *5* clone
#@+node:ekr.20150216111306.25: *4* @test delete all children of @persistence node
import sys
if sys.platform.startswith('linux'):
    self.skipTest('linux test')
else:
    pd = c.persistenceController
    persistence = g.findNodeAnywhere(c,'@persistence')
    assert persistence
    assert pd.has_at_persistence_node()
    persistence.deleteAllChildren()
    assert persistence
#@+node:ekr.20100131171342.5610: *3* leoPlugins
#@+node:ekr.20100131171342.5611: *4* @test getHandlersForTag
pc = g.app.pluginsController

aList1 = pc.getHandlersForTag('select1')
aList2 = pc.getHandlersForOneTag('select1')

assert type(aList1) == type([])
assert type(aList2) == type([])
assert aList1 == aList2
#@+node:ekr.20100909082308.5990: *4* @test regularizeName
pc = g.app.pluginsController

table = (
    ('x',               'x'),
    ('foo.bar',         'foo.bar'),
    ('x.py',            'leo.plugins.x'),
    ('leo.plugins.x',   'leo.plugins.x')    
)

for fn,expected in table:
    result = pc.regularizeName(fn)
    assert result==expected,'expected %s, got %s' % (
        expected,result)
    # Make sure that calling regularizeName twice is benign.
    result2 = pc.regularizeName(result)
    assert result2==result
#@+node:ekr.20100131171342.5612: *3* leoTest
#@+node:ekr.20111102122424.3975: *4* @test all unit tests have access to sources
if g.app.gui.guiName() == 'browser':
    self.skipTest('browser gui')
if c.shortFileName() == 'dynamicUnitTest.leo':
    setting = 'c.write-script-file'
    assert c.write_script_file,'fail 1: %s should be hard set' % (setting)
else:
    setting = "c.config.getBool('write-script-file')"
    assert c.write_script_file,'fail 2: check %s' % (setting)
#@+node:ekr.20111105221757.3833: *4* @test TM.findAllUnitTestNodes
p1 = p.copy()

def found(p,result):
    return any([p.v == p2.v for p2 in result])

table = (('all',True,False),('marked',False,True))
try:
    p.setMarked()
    assert p.isMarked(),p
    for kind,all,marked in table:
        result = c.testManager.findAllUnitTestNodes(all,marked)
        assert found(p,result),(kind,len(result))
    assert p == p1,(p,p1)
finally:
    p1.clearMarked()
#@+node:ekr.20100131171342.5613: *4* @test unit testing with embedded class
def sendEmail(self):
    pass # g.trace('self2',self)

class test:
    pass

X = test()
sendEmail(X)
#@+node:ekr.20071113193729: *3* leoUndo
#@+node:ekr.20040712101754.37: *4* @suite Edit body tests
# Create unit tests in g.app.scriptDict["suite"]

suite = c.testManager.makeEditBodySuite(p)

# g.app.scriptDict['suite'] = suite
#@+node:ekr.20040712101754.38: *5* editBodyTests
@language plain
@

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:

- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
#@+node:ekr.20060127120604: *6* tempNode
#@+node:ekr.20050417202713: *6* addComments
#@+node:ekr.20050417202713.1: *7* before
@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@+node:ekr.20050417202713.2: *7* after
@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
#@+node:ekr.20050417202713.3: *7* selection
5.0
7.8
#@+node:ekr.20050417204940: *6* convertAllBlanks
#@+node:ekr.20050417204940.1: *7* before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417204940.2: *7* after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417204940.3: *7* selection
1.0
6.5
#@+node:ekr.20050417205012: *6* convertAllTabs
#@+node:ekr.20050417205012.1: *7* before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417205012.2: *7* after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417205012.3: *7* selection
1.0
6.5
#@+node:ekr.20050417203114: *6* convertBlanks
#@+node:ekr.20050417203310: *7* before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417203310.1: *7* after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417203336: *7* selection
1.0
6.5
#@+node:ekr.20050417203114.1: *6* convertTabs
#@+node:ekr.20050417204834: *7* before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20050417204830: *7* after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20050417204901: *7* selection
1.0
6.5
#@+node:ekr.20040712101754.49: *6* dedentBody
#@+node:ekr.20040712101754.50: *7* before
line 1
    line 2
    line 3
line 4
#@+node:ekr.20040712101754.51: *7* after
line 1
line 2
line 3
line 4
#@+node:ekr.20040712101754.52: *7* selection
2.0
3.5
#@+node:ekr.20050417202817: *6* deleteComments
# created by new add-comments
#@+node:ekr.20050417202817.1: *7* before
@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    pass
#@+node:ekr.20050417202817.2: *7* after
@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@+node:ekr.20050417202817.3: *7* selection
5.0
7.8
#@+node:ekr.20111112211307.3910: *6* deleteComments
# created by old and new add-comments.
#@+node:ekr.20111112211307.3911: *7* before
@language python

def deleteCommentTest():

#     if 1:
#         a = 2
#         b = 3

    # if 1:
        # a = 2
        # b = 3

    pass
#@+node:ekr.20111112211307.3912: *7* after
@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    if 1:
        a = 2
        b = 3

    pass
#@+node:ekr.20111112211307.3913: *7* selection
5.0
12.8
#@+node:ekr.20050417201845: *6* extract test1
#@+node:ekr.20050417201845.1: *7* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050417201845.2: *7* after
before
    << section >>
after
#@+node:ekr.20050417201845.3: *8* << section >>
sec line 1
    sec line 2 indented
sec line 3
#@+node:ekr.20050417201845.4: *7* selection
2.0
5.10
#@+node:ekr.20050518070540: *6* extract test2
#@+node:ekr.20050518070540.1: *7* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518070545: *7* after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518070540.4: *7* selection
2.0
2.16
#@+node:ekr.20050518070927: *6* extract test3
#@+node:ekr.20050518070927.1: *7* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518070927.2: *7* after
before
    << section >>
after
#@+node:ekr.20050518070927.3: *8* << section >>
sec line 1
    sec line 2 indented
sec line 3
#@+node:ekr.20050518070927.4: *7* selection
2.0
5.10
#@+node:ekr.20050518071251: *6* extract test4
#@+node:ekr.20050518071251.1: *7* before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518071258: *7* after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@+node:ekr.20050518071251.4: *7* selection
2.0
2.16
#@+node:ekr.20190210103111.1: *6* line_to_headline test1
#@+node:ekr.20190210103111.2: *7* before
before
headline
after
#@+node:ekr.20190210103111.3: *7* after
before
after
#@+node:ekr.20190210103111.4: *8* headline
#@+node:ekr.20190210103111.5: *7* selection
2.0
2.0
#@+node:ekr.20201018144248.1: *4* @test restore marked bits
# Test of #1694.
u, w = c.undoer, c.frame.body.wrapper
oldText = p.b
newText = p.b + '\n#changed'
try:
    for marked in (True, False):
        c.undoer.clearUndoState()  # Required.
        p.setMarked() if marked else p.clearMarked()
        oldMarked = p.isMarked()
        w.setAllText(newText)  # For the new assert in w.updateAfterTyping.
        u.setUndoTypingParams(p,
            undo_type = 'typing',
            oldText = oldText,
            newText = newText,
        )
        u.undo()
        assert p.b == oldText, repr(p.b)
        assert p.isMarked() == oldMarked, ('fail 1', p.isMarked(), oldMarked)
        u.redo()
        assert p.b == newText, repr(p.b)
        assert p.isMarked() == oldMarked, ('fail 2', p.isMarked(), oldMarked)
finally:
    p.b = oldText
    p.clearMarked()
#@+node:ekr.20190923170025.1: *4* @test undo editHeadline
# Brian Theado.
c.undoer.clearUndoState()
assert [p.h for p in p.subtree()] == ['node 1', 'node 2', 'node 3']

# Select 'node 1' and modify the headline as if a user did it
node1 = p.copy().moveToFirstChild()
c.selectPosition(node1)
c.editHeadline()
w = c.frame.tree.edit_widget(node1)
w.insert('1.0', 'changed - ')
c.endEditing()
assert [p.h for p in p.subtree()] == ['changed - node 1', 'node 2', 'node 3']

# Move the selection and undo the headline change
c.selectPosition(node1.copy().moveToNext())
c.undoer.undo()

# The undo should restore the 'node 1' headline string
assert [p.h for p in p.subtree()] == ['node 1', 'node 2', 'node 3']

# The undo should select the edited headline.
assert c.p == node1, f"c.p: {c.p.h}, node1: {node1.h}"
#@+node:ekr.20190923170025.2: *5* node 1
#@+node:ekr.20190923170025.3: *5* node 2
#@+node:ekr.20190923170025.4: *5* node 3
#@+node:bpt.20190825074247.1: *4* @test undo/redoGroup
# This test exposed a bug with redoGroup c.undoer.bead index off-by-one
# The first c.pasteOutline() is there to setup the test cases, but it also serves
# an important hidden purpose of adding undo state to the undo stack. Due
# to the wrap-around nature of python index = -1, the original redoGroup code
# worked fine when the undo group is the first one on the undo stack.
# There are several commands which use undoGroup. The convertAllBlanks
# was arbitrarily chosen to expose the bug.
c.undoer.clearUndoState()
original = p.copy().moveToFirstChild()
c.selectPosition(original)
c.copyOutline()
# Do and undo
c.pasteOutline()
do_and_undo = original.copy().moveToNext()
do_and_undo.h = "do and undo"
c.convertAllBlanks()
c.undoer.undo()
assert original.b == do_and_undo.b, "Undo should restore to original"
# Do
c.pasteOutline()
do = do_and_undo.copy().moveToNext()
do.h = "do"
c.convertAllBlanks()
# Do, undo, redo
c.pasteOutline()
do_undo_redo = do.copy().moveToNext()
do_undo_redo.h = "do, undo, redo"
c.convertAllBlanks()
c.undoer.undo()
c.undoer.redo()
assert do.b == do_undo_redo.b, "Redo should do the operation again"
#@+node:bpt.20190825074316.1: *5* original
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20210518075231.6: *5* do and undo
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20210518075231.7: *5* do
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20210518075231.8: *5* do, undo, redo
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20201018151721.1: *5* do and undo
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20201018151721.2: *5* do
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20201018151721.3: *5* do, undo, redo
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20191219051337.3: *5* do and undo
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20191219051337.4: *5* do
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20191219051337.5: *5* do, undo, redo
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20191219045732.6: *5* do and undo
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20191219045732.7: *5* do
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20191219045732.8: *5* do, undo, redo
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20191106202329.2: *5* do and undo
@tabwidth -4

line 1
    line 2
      line 3
line4
#@+node:ekr.20191106202329.3: *5* do
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20191106202329.4: *5* do, undo, redo
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@+node:ekr.20071113202510: *4* @test zz end of leoUndo tests
# Print does not work: it is redirected.
g.pr('\nEnd of leoUndo tests.')
#@+node:ekr.20140802074328.4471: *3* leoVim.py
#@+node:ekr.20140802074328.4472: *4* @test vc.on_same_line
vc = c.vimCommands
s = '''
abc
xyz
pdq
'''
table = (
    ('ab','y',False),
    ('a','c',True),
    ('x','\np',True),
    ('\nx','z',False),
)
for a,b,expected in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.on_same_line(s,i1,i2)
    assert result == expected,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
#@+node:ekr.20140802074328.4473: *4* @test vc.to_bol
vc = c.vimCommands
s = '''
abc
xyz
'''
table = (
    ('a','a'),
    ('a','b'),
    ('a','\nx')
)
for a,b,in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.to_bol(s,i2)
    assert result == i1,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
#@+node:ekr.20140802074328.4474: *4* @test vc.to_eol
vc = c.vimCommands
s = '''
abc
xyz
'''
table = (
    ('a','\nx'),
    ('b','\nx'),
    ('c','\nx'),
    ('\nx','\nx'),
)
for a,b,in table:
    i1,i2 = s.find(a),s.find(b)
    result = vc.to_eol(s,i1)
    assert result == i2,'%s expected: %s got: %s' % (
        s[i1:i2],expected,got)
#@+node:ekr.20050120095423: *3* Plugins
# Do this last.
#@+node:ekr.20110610082755.3362: *4*  qt gui
#@+node:ekr.20100131171342.5503: *5* @test c.vnode2position
for p in c.all_positions():
    p2 = c.vnode2position(p.v)
    # print(p2.level(), p2.headString())
    # We can *not* assert that p == p2, only that
    # p2.v == p.v and c.positionExists(p2)
    assert p2
    assert p2.v == p.v,'p2.v: %s, p.v: %s' % (p2.v,v)
    assert c.positionExists(p2),'does not exist: %s' % p2
#@+node:ekr.20100131171342.5504: *5* @test position2Item
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses')
        # All "item" logic is for Qt only.

tree = c.frame.tree
# position2item does not exist when running unit tests dynamically.
if hasattr(tree,'position2item'):
    c.redraw()
    p = c.rootPosition()
    while p:
        item = tree.position2item(p)
        v = tree.item2vnode(item)
        if v: # New test needed with per-clone expansions.
            assert v == p.v, 'item2: %s, p.v: %s' % (item,p.v)
        p.moveToVisNext(c)
#@+node:ekr.20050120095423.11: *4* @suite import or test syntax of all plugins
'''Imports all plugins or just tests their syntax,
epending on a switch in PluginTestCase.runTest.'''

import glob
import sys
import unittest

@others

suite = makePluginsTestSuite(c)

# g.app.scriptDict['suite'] = suite
#@+node:ekr.20050120095423.12: *5* makePluginsTestSuite
def makePluginsTestSuite(c):

    '''Create a plugin test for .py file in the plugins directory'''

    # Create the suite.
    suite = unittest.makeSuite(unittest.TestCase)

    # Add a test case for every plugin.
    paths = (
        g.os_path_join(g.app.loadDir,'..','plugins','*.py'),
        g.os_path_join(g.app.loadDir,'..','plugins','examples','*.py'),
    )
    all_files = []
    for path in paths:
        plugins = g.os_path_join(path)
        plugins = g.os_path_abspath(plugins)
        files = glob.glob(plugins)
        files = [g.os_path_abspath(f) for f in files]
        all_files.extend(files)
    all_files.sort()
    
    for fn in all_files:
        test = pluginTestCase(c,fn)
        suite.addTest(test)

    if 0:
        # Open a new window after all tests are completed.  Tests many plugins.
        lastTest = lastTestCase(c,openFlag=True)
        suite.addTest(lastTest)

    return suite
#@+node:ekr.20050120095423.13: *5* class pluginTestCase
class pluginTestCase(unittest.TestCase):

    '''A test case to test a single Leo plugin.'''

    @others
#@+node:ekr.20050120095423.14: *6* __init__
def __init__ (self,c,path):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
#@+node:ekr.20050120095423.15: *6* fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
#@+node:ekr.20050120095423.16: *6* runTest
def runTest(self):

    trace = False
    c = self.c ; path = self.path
    path,base = g.os_path_split(path)
    fn = base[:-3]
    
    ignore = (
        # Read error.
        'chinese_menu',
        # Unfinished/obsolute gui's.
        'gtkDialogs','gtkGui','ironPython','ironPythonGui',
        'swing_gui','tkGui','wxGui','temacs',
        # Tk-only.
        'ipython',
        # Imports path & win32clipboard.
        'at_view',
        # Experimental.
        'stickynotes_plus',
        # Generated by unit tests.
        'pluginsTest',
        # Imports non-standard modules.
        'interact',         # import pexpect
        'jinjarender',      # import jinga2
        'leofeeds',         # import feedparser
    )

    if fn in ignore:
        return
    
    if trace: g.trace(fn)
    
    if 1:
        # Just check the syntax.  Doesn't pollute other unit tests.
        with open(self.path,'r') as f:
            s = f.read()
        assert c.testManager.checkFileSyntax(fn,s,reraise=False,suppress=False)
    else: # Good for initial tests, but pollutes all other unit tests.
        exec('import leo.plugins.%s' % fn)
    
#@+node:ekr.20050120095423.17: *6* setUp
def setUp(self):

    g.app.unitTestDict = {}
#@+node:ekr.20050120095423.18: *6* shortDescription
def shortDescription (self):

    return "pluginTestCase: %s" % g.shortFileName(self.path)
#@+node:ekr.20050120095423.20: *5* class lastTestCase
class lastTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''

    def __init__ (self,c,openFlag):
        # Init the base class.
        unittest.TestCase.__init__(self)
        self.c = c
        self.openFlag = openFlag

    def runTest(self):
        c = self.c
        print('\n%s a new window to test more plugin logic\n' % g.choose(
            self.openFlag,'opening','open'))
        if self.openFlag:
            self.new_c = new_c = c.new() # Create the new window.
            new_c.frame.setTitle("unit test for 'new' hook")

    if 0: # Doesn't work
        def shutDown(self):
            c = self.new_c
            c.close()
#@+node:ekr.20111104214341.3835: *4* @test all plugins have top-level init method
'''Ensure all plugins have top-level init method *without* importing them.'''

import glob
import inspect

# Get a list of all plugins.
plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
plugins = g.os_path_abspath(plugins)
files = glob.glob(plugins)
files = [g.os_path_abspath(z) for z in files]
files = [z for z in files if not z.endswith('__init__.py')]
files.sort()

exclude = [
    # These are not real plugins...
    'babel_api.py',
    'babel_kill.py',
    'babel_lib.py',
    'baseNativeTree.py',
    'leocursor.py',
    'leo_cloud_server.py',
    'leo_mypy_plugin.py',
    'qtGui.py',
    'qt_big_text.py',
    'qt_commands.py',
    'qt_events.py',
    'qt_frame.py',
    'qt_idle_time.py',
    'qt_main.py',
    'qt_quickheadlines.py',
    'qt_quicksearch_sub.py',
    'qt_text.py',
    'qt_tree.py',
    'qt_quicksearch.py',
    'swing_gui.py',
]

for fn in files:
    if not g.shortFileName(fn) in exclude:
        f = open(fn,'r')
        s = f.read()
        f.close()
        ok1 = s.find('def init():') > -1
        ok2 = s.find('def init ():') > -1
        assert ok1 or ok2,'fail: %s' % (fn)
    
#@+node:ekr.20210518092129.1: *4* @test all qt plugins call g.assertUi('qt')
'''Ensure all plugins have top-level init method *without* importing them.'''

import glob
import inspect
import re

# Get a list of all plugins.
plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
plugins = g.os_path_abspath(plugins)
files = glob.glob(plugins)
files = [g.os_path_abspath(z) for z in files]
files = [z for z in files if not z.endswith('__init__.py')]
files.sort()

exclude = [
    # These are not real plugins...
    'babel_api.py',
    'babel_kill.py',
    'babel_lib.py',
    'baseNativeTree.py',
    'leocursor.py',
    'leo_cloud_server.py',
    'leo_mypy_plugin.py',
    'nested_splitter.py',
    'pyplot_backend.py',
    'qtGui.py',
    'qt_big_text.py',
    'qt_commands.py',
    'qt_events.py',
    'qt_frame.py',
    'qt_gui.py',
    'qt_idle_time.py',
    'qt_main.py',
    'qt_quickheadlines.py',
    'qt_quicksearch_sub.py',
    'qt_text.py',
    'qt_tree.py',
    'qt_quicksearch.py',
    'swing_gui.py',
    #
    # Special cases, handling Qt imports in unusual ways.
    #
    'backlink.py',  # Qt code is optional, disabled with module-level guard.
    'leoscreen.py',  # Qt imports are optional.
    'nodetags.py',  # #2031: Qt imports are optional.
    # 'free_layout.py',
]
pattern = re.compile(r'\b(QtCore|QtGui|QtWidgets)\b') # Don't search for Qt.
fails = []
for fn in files:
    if g.shortFileName(fn) in exclude:
        continue
    with open(fn, 'r') as f:
        s = f.read()
    if not re.search(pattern, s):
        continue
    if not re.search(r"g\.assertUi\(['\"]qt['\"]\)", s):
        fails.append(fn)
if fails:
    g.printObj(fails)
    assert False, f"{len(fails)} failures"
#@+node:ekr.20140217055617.4230: *4* @test c.theScriptingController.atScriptNodes
# This must be true even though @bool scriptingatscriptnodes is True in this file.
if hasattr(c,'theScriptingController'):
    # mod_scripting may be disabled when running tests externally.
    val = g.app.config.valueInMyLeoSettings('scripting-at-script-nodes')
    assert c.theScriptingController.atScriptNodes in (val, None, False), (val, c.theScriptingController.atScriptNodes)
#@+node:ekr.20100131171342.5501: *4* @test zz end of plugins unit tests
# Print does not work: it is redirected.
g.pr('\nEnd of plugins unit tests')
#@+node:ekr.20081111150402.11: ** @test zz end of all tests
# Print does not work: it is redirected.
g.pr('\nall unit tests done',color='blue')
#@+node:ekr.20140822063016.4474: ** @test zzz force a quit
import sys
if not g.app.inBridge:
    g.app.forceShutdown()
        # Now works with curses gui.
#@-all
#@-leo
