<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="http://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20180311131353.1"><vh>Personal test file</vh></v>
<v t="ekr.20230622114548.1"><vh>@settings</vh>
<v t="ekr.20230623064935.1"><vh>@data history-list</vh></v>
<v t="ekr.20230622114556.1"><vh>@button copy-test</vh></v>
</v>
<v t="ekr.20180311131424.1"><vh>Recent</vh>
<v t="ekr.20180311131403.1"><vh>@jupyter</vh></v>
<v t="ekr.20180311210803.1"><vh>re latex button</vh>
<v t="ekr.20180311195905.1"><vh>@@button Create LaTeX</vh></v>
<v t="ekr.20180311200239.1"><vh>@@clean c:\test\latex_test.tex</vh>
<v t="ekr.20180311200312.1"><vh>level 1</vh>
<v t="ekr.20180311200318.1"><vh>level 2</vh></v>
</v>
</v>
</v>
<v t="ekr.20180312050315.1"><vh>print cwd</vh></v>
</v>
<v t="ekr.20180311212134.1"><vh>Coloring tests</vh>
<v t="ekr.20180311131449.1"><vh>Syntax coloring template</vh></v>
<v t="ekr.20180311212134.2"><vh>g.es test</vh></v>
<v t="ekr.20180311212134.3"><vh>g.error/note/warning test</vh></v>
</v>
<v t="ekr.20180319044254.1"><vh>Viewrendered examples</vh>
<v t="ekr.20180319044254.2"><vh>Python code</vh></v>
<v t="ekr.20180319044254.3"><vh>@graphics-script</vh></v>
<v t="ekr.20180319044254.4"><vh>@html display Leo tree (cool)</vh></v>
<v t="ekr.20180319044254.5"><vh>@html Leo's home page</vh></v>
<v t="ekr.20180319044254.6"><vh>@image LeoSplash</vh></v>
<v t="ekr.20180319044254.7"><vh>@image splash screen</vh></v>
<v t="ekr.20180319044254.8"><vh>@movie Gayane Ballet (Local file)</vh></v>
<v t="ekr.20180319044254.9"><vh>@movie Gayane Ballet (Url)</vh></v>
<v t="ekr.20180319044254.10"><vh>@movie Sample video (Local file)</vh></v>
<v t="ekr.20180319044254.11"><vh>@movie Sample video (Url)</vh></v>
<v t="ekr.20180319044254.12"><vh>@networkx my network</vh></v>
<v t="ekr.20180319044254.13"><vh>@pyplot matplotlib animate_decay</vh>
<v t="ekr.20180319044254.14"><vh>data_gen</vh></v>
<v t="ekr.20180319044254.15"><vh>init</vh></v>
<v t="ekr.20180319044254.16"><vh>run</vh></v>
</v>
<v t="ekr.20180319044254.17"><vh>@pyplot basic_example</vh>
<v t="ekr.20180319044254.18"><vh>Figure 1</vh></v>
<v t="ekr.20180319044254.19"><vh>Figure 2</vh></v>
</v>
<v t="ekr.20180319044254.20"><vh>@pyplot barchar_demo</vh></v>
<v t="ekr.20180319044254.21"><vh>@svg bubbles sources</vh></v>
<v t="ekr.20180319044254.22"><vh>@svg bubbles.svg</vh></v>
<v t="ekr.20180319044254.23"><vh>@url Leo's home page (md default)</vh></v>
<v t="ekr.20180319044254.24"><vh>@url Leo's home page (md explicit)</vh></v>
<v t="ekr.20180319044254.25"><vh>@url Leo's home page (rST default)</vh></v>
<v t="ekr.20180319044254.26"><vh>@url Leo's home page (rST explicit)</vh></v>
<v t="ekr.20180319044254.27"><vh>@url weather (md default)</vh></v>
<v t="ekr.20180319044254.28"><vh>@url weather (rst default)</vh></v>
<v t="ekr.20180319044254.29"><vh>docstring test</vh></v>
<v t="ekr.20180319044254.30"><vh>markdown test (including url)</vh></v>
<v t="ekr.20180319044254.31"><vh>rst test (including url)</vh></v>
</v>
<v t="ekr.20230622112641.1"><vh>--- tests of UNL</vh></v>
<v t="ekr.20140723122936.18139"><vh>@file ../plugins/importers/__init__.py</vh></v>
<v t="ekr.20230622112535.1"><vh>@clean ../plugins/leo_babel/__init__.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>###@file ../core/leoGlobals.py</vh>
<v t="ekr.20050208101229"><vh>&lt;&lt; leoGlobals imports &gt;&gt;</vh></v>
<v t="ekr.20220824084642.1"><vh>&lt;&lt; leoGlobals annotations &gt;&gt;</vh></v>
<v t="EKR.20040610094819"><vh>&lt;&lt; define g.globalDirectiveList &gt;&gt;</vh></v>
<v t="ekr.20150510103918.1"><vh>&lt;&lt; define global decorator dicts &gt;&gt; (leoGlobals.py)</vh></v>
<v t="ekr.20220412193109.1"><vh>&lt;&lt; define global error regexes &gt;&gt; (leoGlobals.py)</vh></v>
<v t="ekr.20150508165324.1"><vh>&lt;&lt; define g.Decorators &gt;&gt;</vh>
<v t="ekr.20150510104148.1"><vh>g.check_cmd_instance_dict</vh></v>
<v t="ville.20090521164644.5924"><vh>g.command (decorator)</vh></v>
<v t="ekr.20171124070654.1"><vh>g.command_alias</vh></v>
<v t="ekr.20171123095526.1"><vh>g.commander_command (decorator)</vh></v>
<v t="ekr.20150508164812.1"><vh>g.ivars2instance</vh></v>
<v t="ekr.20150508134046.1"><vh>g.new_cmd_decorator (decorator)</vh></v>
</v>
<v t="ekr.20200810093517.1"><vh>&lt;&lt; define regex's &gt;&gt; (leoGlobals.py)</vh></v>
<v t="ekr.20201211182722.1"><vh>g.Backup</vh>
<v t="ekr.20201211182659.1"><vh>g.standard_timestamp</vh></v>
<v t="ekr.20201211183100.1"><vh>g.get_backup_directory</vh></v>
</v>
<v t="ekr.20140711071454.17644"><vh>g.Classes &amp; class accessors</vh>
<v t="ekr.20120123115816.10209"><vh>class g.BindingInfo &amp; isBindingInfo</vh>
<v t="ekr.20120129040823.10254"><vh>bi.__init__</vh></v>
<v t="ekr.20120203153754.10031"><vh>bi.__hash__</vh></v>
<v t="ekr.20120125045244.10188"><vh>bi.__repr__ &amp; ___str_&amp; dump</vh></v>
<v t="ekr.20120129040823.10226"><vh>bi.isModeBinding</vh></v>
</v>
<v t="ekr.20031218072017.3098"><vh>class g.Bunch (Python Cookbook)</vh></v>
<v t="ekr.20120219154958.10492"><vh>class g.EmergencyDialog</vh>
<v t="ekr.20120219154958.10493"><vh>emergencyDialog.__init__</vh></v>
<v t="ekr.20120219154958.10494"><vh>emergencyDialog.createButtons</vh></v>
<v t="ekr.20120219154958.10495"><vh>emergencyDialog.createTopFrame</vh></v>
<v t="ekr.20120219154958.10496"><vh>emergencyDialog.okButton</vh></v>
<v t="ekr.20120219154958.10497"><vh>emergencyDialog.onKey</vh></v>
<v t="ekr.20120219154958.10498"><vh>emergencyDialog.run</vh></v>
</v>
<v t="ekr.20120123143207.10223"><vh>class g.GeneralSetting</vh></v>
<v t="ekr.20120201164453.10090"><vh>class g.KeyStroke &amp; isStroke/OrNone</vh>
<v t="ekr.20180414195401.2"><vh> ks.__init__</vh></v>
<v t="ekr.20120203053243.10117"><vh>ks.__eq__, etc</vh></v>
<v t="ekr.20120203053243.10118"><vh>ks.__hash__</vh></v>
<v t="ekr.20120204061120.10067"><vh>ks.__repr___ &amp; __str__</vh></v>
<v t="ekr.20180417160703.1"><vh>ks.dump</vh></v>
<v t="ekr.20180415082249.1"><vh>ks.finalize_binding</vh></v>
<v t="ekr.20180415083926.1"><vh>ks.finalize_char &amp; helper</vh>
<v t="ekr.20180502104829.1"><vh>ks.strip_shift</vh></v>
</v>
<v t="ekr.20120203053243.10124"><vh>ks.find, lower &amp; startswith</vh></v>
<v t="ekr.20180415081209.2"><vh>ks.find_mods</vh></v>
<v t="ekr.20180417101435.1"><vh>ks.isAltCtl</vh></v>
<v t="ekr.20120203053243.10121"><vh>ks.isFKey</vh></v>
<v t="ekr.20180417102341.1"><vh>ks.isPlainKey (does not handle alt-ctrl chars)</vh></v>
<v t="ekr.20180511092713.1"><vh>ks.isNumPadKey, ks.isPlainNumPad &amp; ks.removeNumPadModifier</vh></v>
<v t="ekr.20180419170934.1"><vh>ks.prettyPrint</vh></v>
<v t="ekr.20180415124853.1"><vh>ks.strip_mods</vh></v>
<v t="ekr.20120203053243.10125"><vh>ks.toGuiChar</vh></v>
<v t="ekr.20180417100834.1"><vh>ks.toInsertableChar</vh></v>
</v>
<v t="ekr.20160119093947.1"><vh>class g.MatchBrackets</vh>
<v t="ekr.20160119104510.1"><vh>mb.ctor</vh></v>
<v t="ekr.20160121164723.1"><vh>mb.bi-directional helpers</vh>
<v t="ekr.20160121112812.1"><vh>mb.is_regex</vh></v>
<v t="ekr.20160121112536.1"><vh>mb.scan_regex</vh></v>
<v t="ekr.20160121112303.1"><vh>mb.scan_string</vh></v>
</v>
<v t="tbrown.20180226113621.1"><vh>mb.expand_range</vh></v>
<v t="ekr.20061113221414"><vh>mb.find_matching_bracket</vh></v>
<v t="ekr.20160121164556.1"><vh>mb.scan &amp; helpers</vh>
<v t="ekr.20160119090634.1"><vh>mb.scan_comment</vh></v>
<v t="ekr.20160119101851.1"><vh>mb.starts_comment</vh></v>
</v>
<v t="ekr.20160119230141.1"><vh>mb.scan_back &amp; helpers</vh>
<v t="ekr.20160119230141.2"><vh>mb.back_scan_comment</vh></v>
<v t="ekr.20160119230141.4"><vh>mb.ends_comment</vh></v>
</v>
<v t="ekr.20160119104148.1"><vh>mb.oops</vh></v>
<v t="ekr.20160119094053.1"><vh>mb.run</vh></v>
</v>
<v t="ekr.20230616134732.1"><vh>class g.OptionsUtils</vh>
<v t="ekr.20230615034937.1"><vh>OptionsUtils.check_options</vh></v>
<v t="ekr.20230615062610.1"><vh>OptionsUtils.compute_valid_options</vh></v>
<v t="ekr.20230615084117.1"><vh>OptionsUtils.find_complex_option</vh></v>
<v t="ekr.20230616075049.1"><vh>OptionsUtils.option_error</vh></v>
</v>
<v t="EKR.20040612114220.4"><vh>class g.ReadLinesClass</vh></v>
<v t="ekr.20031218072017.3121"><vh>class g.RedirectClass &amp; convenience functions</vh>
<v t="ekr.20031218072017.1656"><vh>&lt;&lt; RedirectClass methods &gt;&gt;</vh>
<v t="ekr.20041012082437"><vh>RedirectClass.__init__</vh></v>
<v t="ekr.20041012082437.1"><vh>isRedirected</vh></v>
<v t="ekr.20041012082437.2"><vh>flush</vh></v>
<v t="ekr.20041012091252"><vh>rawPrint</vh></v>
<v t="ekr.20041012082437.3"><vh>redirect</vh></v>
<v t="ekr.20041012082437.4"><vh>undirect</vh></v>
<v t="ekr.20041012082437.5"><vh>write</vh></v>
</v>
<v t="ekr.20031218072017.3122"><vh>&lt;&lt; define convenience methods for redirecting streams &gt;&gt;</vh>
<v t="ekr.20041012090942"><vh>redirectStderr &amp; redirectStdout</vh></v>
<v t="ekr.20041012090942.1"><vh>restoreStderr &amp; restoreStdout</vh></v>
<v t="ekr.20041012090942.2"><vh>stdErrIsRedirected &amp; stdOutIsRedirected</vh></v>
<v t="ekr.20041012090942.3"><vh>rawPrint</vh></v>
</v>
</v>
<v t="ekr.20120129181245.10220"><vh>class g.SettingsDict(dict)</vh>
<v t="ekr.20120223062418.10422"><vh>td.copy</vh></v>
<v t="ekr.20190904052828.1"><vh>td.add_to_list</vh></v>
<v t="ekr.20190903181030.1"><vh>td.get_setting &amp; get_string_setting</vh></v>
<v t="ekr.20190904103552.1"><vh>td.name &amp; setName</vh></v>
</v>
<v t="ekr.20121128031949.12605"><vh>class g.SherlockTracer</vh>
<v t="ekr.20121128031949.12602"><vh>sherlock.__init__</vh></v>
<v t="ekr.20140326100337.16844"><vh>sherlock.__call__</vh></v>
<v t="ekr.20140326100337.16846"><vh>sherlock.bad_pattern</vh></v>
<v t="ekr.20140326100337.16847"><vh>sherlock.check_pattern</vh></v>
<v t="ekr.20121128031949.12609"><vh>sherlock.dispatch</vh></v>
<v t="ekr.20121128031949.12603"><vh>sherlock.do_call &amp; helper</vh>
<v t="ekr.20130111185820.10194"><vh>sherlock.get_args</vh></v>
</v>
<v t="ekr.20140402060647.16845"><vh>sherlock.do_line (not used)</vh></v>
<v t="ekr.20130109154743.10172"><vh>sherlock.do_return &amp; helper</vh>
<v t="ekr.20220605141445.1"><vh>sherlock.put_ret</vh></v>
</v>
<v t="ekr.20121128111829.12185"><vh>sherlock.fn_is_enabled</vh></v>
<v t="ekr.20130112093655.10195"><vh>sherlock.get_full_name</vh></v>
<v t="ekr.20121128111829.12183"><vh>sherlock.is_enabled</vh></v>
<v t="ekr.20121128111829.12182"><vh>sherlock.print_stats</vh></v>
<v t="ekr.20121128031949.12614"><vh>sherlock.run</vh></v>
<v t="ekr.20140322090829.16834"><vh>sherlock.push &amp; pop</vh></v>
<v t="ekr.20140326100337.16845"><vh>sherlock.set_patterns</vh></v>
<v t="ekr.20140322090829.16831"><vh>sherlock.show</vh></v>
<v t="ekr.20121128093229.12616"><vh>sherlock.stop</vh></v>
</v>
<v t="ekr.20191013145307.1"><vh>class g.TkIDDialog (EmergencyDialog)</vh>
<v t="ekr.20191013145710.1"><vh>leo_id_dialog.onKey</vh></v>
<v t="ekr.20191013145757.1"><vh>leo_id_dialog.createTopFrame</vh></v>
<v t="ekr.20191013150158.1"><vh>leo_id_dialog.okButton</vh></v>
</v>
<v t="ekr.20080531075119.1"><vh>class g.Tracer</vh>
<v t="ekr.20080531075119.2"><vh> __init__ (Tracer)</vh></v>
<v t="ekr.20080531075119.3"><vh>computeName</vh></v>
<v t="ekr.20080531075119.4"><vh>report</vh></v>
<v t="ekr.20080531075119.5"><vh>stop</vh></v>
<v t="ekr.20080531075119.6"><vh>tracer</vh></v>
<v t="ekr.20080531075119.7"><vh>updateStats</vh></v>
</v>
<v t="ekr.20031219074948.1"><vh>class g.Tracing/NullObject &amp; helpers</vh>
<v t="ekr.20190330062625.1"><vh>g.null_object_print_attr</vh>
<v t="ekr.20190330072026.1"><vh>&lt;&lt; define suppression lists &gt;&gt;</vh></v>
</v>
<v t="ekr.20190330072832.1"><vh>g.null_object_print</vh></v>
</v>
<v t="ville.20090827174345.9963"><vh>class g.UiTypeException &amp; g.assertui</vh></v>
<v t="ekr.20200219071828.1"><vh>class TestLeoGlobals (leoGlobals.py)</vh>
<v t="ekr.20200219071958.1"><vh>TestLeoGlobals.test_comment_delims_from_extension</vh></v>
<v t="ekr.20200219072957.1"><vh>TestLeoGlobals.test_is_sentinel</vh></v>
</v>
<v t="ekr.20140904112935.18526"><vh>g.isTextWrapper &amp; isTextWidget</vh></v>
</v>
<v t="ekr.20140711071454.17649"><vh>g.Debugging, GC, Stats &amp; Timing</vh>
<v t="ekr.20031218072017.3104"><vh>g.Debugging</vh>
<v t="ekr.20180415144534.1"><vh>g.assert_is</vh></v>
<v t="ekr.20180420081530.1"><vh>g._assert</vh></v>
<v t="ekr.20051023083258"><vh>g.callers, caller,  _callerName, callers_list</vh>
<v t="ekr.20230128025911.1"><vh>g.callers</vh></v>
<v t="ekr.20230128030346.1"><vh>g.callers_list</vh></v>
<v t="ekr.20031218072017.3107"><vh>g._callerName</vh></v>
<v t="ekr.20180328170441.1"><vh>g.caller</vh></v>
</v>
<v t="ekr.20031218072017.3109"><vh>g.dump</vh></v>
<v t="ekr.20210904114446.1"><vh>g.dump_tree &amp; g.tree_to_string</vh></v>
<v t="ekr.20150227102835.8"><vh>g.dump_encoded_string</vh></v>
<v t="ekr.20031218072017.1317"><vh>g.file/module/plugin_date</vh></v>
<v t="ekr.20031218072017.3127"><vh>g.get_line &amp; get_line__after</vh></v>
<v t="ekr.20080729142651.1"><vh>g.getIvarsDict and checkUnchangedIvars</vh></v>
<v t="ekr.20031218072017.3128"><vh>g.pause</vh></v>
<v t="ekr.20041105091148"><vh>g.pdb</vh></v>
<v t="ekr.20050819064157"><vh>g.objToString &amp; aliases</vh></v>
<v t="ekr.20120912153732.10597"><vh>g.wait</vh></v>
<v t="ekr.20171023140544.1"><vh>g.printObj &amp; aliases</vh></v>
</v>
<v t="ekr.20031218072017.1588"><vh>g.Garbage Collection</vh>
<v t="ekr.20031218072017.1589"><vh>g.clearAllIvars</vh></v>
<v t="ekr.20060127162818"><vh>g.enable_gc_debug</vh></v>
<v t="ekr.20031218072017.1592"><vh>g.printGc</vh></v>
<v t="ekr.20060127164729.1"><vh>g.printGcObjects</vh></v>
<v t="ekr.20031218072017.1593"><vh>g.printGcRefs</vh></v>
<v t="ekr.20060205043324.1"><vh>g.printGcSummary</vh></v>
</v>
<v t="ekr.20180528151850.1"><vh>g.printTimes</vh></v>
<v t="ekr.20031218072017.3133"><vh>g.Statistics</vh>
<v t="ekr.20031218072017.3134"><vh>g.clearStats</vh></v>
<v t="ekr.20031218072017.3135"><vh>g.printStats</vh></v>
<v t="ekr.20031218072017.3136"><vh>g.stat</vh></v>
</v>
<v t="ekr.20031218072017.3137"><vh>g.Timing</vh></v>
</v>
<v t="ekr.20031218072017.1380"><vh>g.Directives</vh>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20170201150505.1"><vh>g.findAllValidLanguageDirectives</vh></v>
<v t="ekr.20090214075058.8"><vh>g.findAtTabWidthDirectives (must be fast)</vh></v>
<v t="ekr.20170127142001.5"><vh>g.findFirstAtLanguageDirective</vh></v>
<v t="ekr.20090214075058.6"><vh>g.findLanguageDirectives (must be fast)</vh></v>
<v t="ekr.20031218072017.1385"><vh>g.findReference</vh></v>
<v t="ekr.20090214075058.9"><vh>g.get_directives_dict (must be fast)</vh></v>
<v t="ekr.20080827175609.1"><vh>g.get_directives_dict_list (must be fast)</vh></v>
<v t="ekr.20111010082822.15545"><vh>g.getLanguageFromAncestorAtFileNode</vh></v>
<v t="ekr.20150325075144.1"><vh>g.getLanguageFromPosition</vh></v>
<v t="ekr.20031218072017.1386"><vh>g.getOutputNewline</vh></v>
<v t="ekr.20200521075143.1"><vh>g.inAtNosearch</vh></v>
<v t="ekr.20131230090121.16528"><vh>g.isDirective</vh></v>
<v t="ekr.20200810074755.1"><vh>g.isValidLanguage</vh></v>
<v t="ekr.20080827175609.52"><vh>g.scanAtCommentAndLanguageDirectives</vh></v>
<v t="ekr.20080827175609.32"><vh>g.scanAtEncodingDirectives</vh></v>
<v t="ekr.20080827175609.53"><vh>g.scanAtHeaderDirectives</vh></v>
<v t="ekr.20080827175609.33"><vh>g.scanAtLineendingDirectives</vh></v>
<v t="ekr.20080827175609.34"><vh>g.scanAtPagewidthDirectives</vh></v>
<v t="ekr.20101022172109.6108"><vh>g.scanAtPathDirectives</vh></v>
<v t="ekr.20080827175609.37"><vh>g.scanAtTabwidthDirectives</vh></v>
<v t="ekr.20080831084419.4"><vh>g.scanAtWrapDirectives</vh></v>
<v t="ekr.20040715155607"><vh>g.scanForAtIgnore</vh></v>
<v t="ekr.20040712084911.1"><vh>g.scanForAtLanguage</vh></v>
<v t="ekr.20041123094807"><vh>g.scanForAtSettings</vh></v>
<v t="ekr.20031218072017.1382"><vh>g.set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>g.set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>g.set_language</vh></v>
<v t="ekr.20071109165315"><vh>g.stripPathCruft</vh></v>
<v t="ekr.20090214075058.10"><vh>g.update_directives_pat</vh></v>
</v>
<v t="ekr.20031218072017.3116"><vh>g.Files &amp; Directories</vh>
<v t="ekr.20080606074139.2"><vh>g.chdir</vh></v>
<v t="ekr.20120222084734.10287"><vh>g.compute...Dir</vh></v>
<v t="ekr.20031218072017.3103"><vh>g.computeWindowTitle</vh></v>
<v t="ekr.20031218072017.3117"><vh>g.create_temp_file</vh></v>
<v t="ekr.20210307060731.1"><vh>g.createHiddenCommander</vh></v>
<v t="vitalije.20170714085545.1"><vh>g.defaultLeoFileExtension</vh></v>
<v t="ekr.20031218072017.3118"><vh>g.ensure_extension</vh></v>
<v t="ekr.20150403150655.1"><vh>g.fullPath (deprecated)</vh></v>
<v t="ekr.20190327192721.1"><vh>g.get_files_in_directory</vh></v>
<v t="ekr.20031218072017.1264"><vh>g.getBaseDirectory</vh></v>
<v t="ekr.20170223093758.1"><vh>g.getEncodingAt</vh></v>
<v t="ville.20090701144325.14942"><vh>g.guessExternalEditor</vh></v>
<v t="ekr.20160330204014.1"><vh>g.init_dialog_folder</vh></v>
<v t="ekr.20100329071036.5744"><vh>g.is_binary_file/external_file/string</vh></v>
<v t="EKR.20040504154039"><vh>g.is_sentinel</vh></v>
<v t="ekr.20031218072017.3119"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20071114113736"><vh>g.makePathRelativeTo</vh></v>
<v t="ekr.20090520055433.5945"><vh>g.openWithFileName</vh></v>
<v t="ekr.20150306035851.7"><vh>g.readFileIntoEncodedString</vh></v>
<v t="ekr.20100125073206.8710"><vh>g.readFileIntoString</vh></v>
<v t="ekr.20160504062833.1"><vh>g.readFileToUnicodeString</vh></v>
<v t="ekr.20031218072017.3120"><vh>g.readlineForceUnixNewline</vh></v>
<v t="ekr.20031218072017.3124"><vh>g.sanitize_filename</vh></v>
<v t="ekr.20060328150113"><vh>g.setGlobalOpenDir</vh></v>
<v t="ekr.20031218072017.3125"><vh>g.shortFileName &amp; shortFilename</vh></v>
<v t="ekr.20150610125813.1"><vh>g.splitLongFileName</vh></v>
<v t="ekr.20190114061452.26"><vh>g.writeFile</vh></v>
<v t="ekr.20230113043029.1"><vh>g.write_file_if_changed</vh></v>
</v>
<v t="ekr.20031218072017.3151"><vh>g.Finding &amp; Scanning</vh>
<v t="ekr.20140602083643.17659"><vh>g.find_word</vh></v>
<v t="ekr.20211029090118.1"><vh>g.findAncestorVnodeByPredicate</vh></v>
<v t="ekr.20170220103251.1"><vh>g.findRootsWithPredicate</vh></v>
<v t="ekr.20031218072017.3156"><vh>g.scanError</vh></v>
<v t="ekr.20031218072017.3157"><vh>g.scanf</vh></v>
<v t="ekr.20031218072017.3158"><vh>g.Scanners: calling scanError</vh>
<v t="ekr.20031218072017.3159"><vh>g.skip_block_comment</vh></v>
<v t="ekr.20031218072017.3160"><vh>g.skip_braces</vh></v>
<v t="ekr.20031218072017.3162"><vh>g.skip_parens</vh></v>
<v t="ekr.20031218072017.3163"><vh>g.skip_pascal_begin_end</vh></v>
<v t="ekr.20031218072017.3164"><vh>g.skip_pascal_block_comment</vh></v>
<v t="ekr.20031218072017.3165"><vh>g.skip_pascal_string</vh></v>
<v t="ekr.20031218072017.3166"><vh>g.skip_heredoc_string</vh></v>
<v t="ekr.20031218072017.3167"><vh>g.skip_pp_directive</vh></v>
<v t="ekr.20031218072017.3168"><vh>g.skip_pp_if</vh></v>
<v t="ekr.20031218072017.3169"><vh>g.skip_pp_part</vh></v>
<v t="ekr.20031218072017.3171"><vh>g.skip_to_semicolon</vh></v>
<v t="ekr.20031218072017.3172"><vh>g.skip_typedef</vh></v>
</v>
<v t="ekr.20201127143342.1"><vh>g.see_more_lines</vh></v>
<v t="ekr.20031218072017.3195"><vh>g.splitLines</vh></v>
<v t="ekr.20031218072017.3173"><vh>Scanners: no error messages</vh>
<v t="ekr.20031218072017.3174"><vh>g.escaped</vh></v>
<v t="ekr.20031218072017.3175"><vh>g.find_line_start</vh></v>
<v t="ekr.20031218072017.3176"><vh>g.find_on_line</vh></v>
<v t="ekr.20031218072017.3179"><vh>g.is_special</vh></v>
<v t="ekr.20031218072017.3177"><vh>g.is_c_id</vh></v>
<v t="ekr.20031218072017.3178"><vh>g.is_nl</vh></v>
<v t="ekr.20031218072017.3180"><vh>g.is_ws &amp; is_ws_or_nl</vh></v>
<v t="ekr.20031218072017.3181"><vh>g.match</vh></v>
<v t="ekr.20031218072017.3182"><vh>g.match_c_word</vh></v>
<v t="ekr.20031218072017.3183"><vh>g.match_ignoring_case</vh></v>
<v t="ekr.20031218072017.3184"><vh>g.match_word &amp; g.match_words</vh></v>
<v t="ekr.20031218072017.3185"><vh>g.skip_blank_lines</vh></v>
<v t="ekr.20031218072017.3186"><vh>g.skip_c_id</vh></v>
<v t="ekr.20040705195048"><vh>g.skip_id</vh></v>
<v t="ekr.20031218072017.3187"><vh>g.skip_line, skip_to_start/end_of_line</vh></v>
<v t="ekr.20031218072017.3188"><vh>g.skip_long</vh></v>
<v t="ekr.20031218072017.3190"><vh>g.skip_nl</vh></v>
<v t="ekr.20031218072017.3191"><vh>g.skip_non_ws</vh></v>
<v t="ekr.20031218072017.3192"><vh>g.skip_pascal_braces</vh></v>
<v t="ekr.20031218072017.3170"><vh>g.skip_python_string</vh></v>
<v t="ekr.20031218072017.2369"><vh>g.skip_string</vh></v>
<v t="ekr.20031218072017.3193"><vh>g.skip_to_char</vh></v>
<v t="ekr.20031218072017.3194"><vh>g.skip_ws, skip_ws_and_nl</vh></v>
</v>
</v>
<v t="ekr.20170414034616.1"><vh>g.Git</vh>
<v t="ekr.20180325025502.1"><vh>g.backupGitIssues</vh></v>
<v t="ekr.20170616102324.1"><vh>g.execGitCommand</vh></v>
<v t="ekr.20180126043905.1"><vh>g.getGitIssues</vh>
<v t="ekr.20180126044602.1"><vh>class GitIssueController</vh>
<v t="ekr.20180325023336.1"><vh>git.backup_issues</vh></v>
<v t="ekr.20180325024334.1"><vh>git.get_all_issues</vh></v>
<v t="ekr.20180126044850.1"><vh>git.get_issues</vh></v>
<v t="ekr.20180126043719.3"><vh>git.get_one_issue</vh></v>
<v t="ekr.20180126043719.4"><vh>git.get_one_page</vh></v>
<v t="ekr.20180127092201.1"><vh>git.print_header</vh></v>
</v>
</v>
<v t="ekr.20190428173354.1"><vh>g.getGitVersion</vh></v>
<v t="ekr.20170414034616.2"><vh>g.gitBranchName</vh></v>
<v t="ekr.20170414034616.4"><vh>g.gitCommitNumber</vh></v>
<v t="ekr.20200724132432.1"><vh>g.gitInfoForFile</vh></v>
<v t="ekr.20200724133754.1"><vh>g.gitInfoForOutline</vh></v>
<v t="maphew.20171112205129.1"><vh>g.gitDescribe</vh></v>
<v t="ekr.20170414034616.6"><vh>g.gitHeadPath</vh></v>
<v t="ekr.20170414034616.3"><vh>g.gitInfo</vh></v>
</v>
<v t="ekr.20031218072017.3139"><vh>g.Hooks &amp; Plugins</vh>
<v t="ekr.20101028131948.5860"><vh>g.act_on_node</vh></v>
<v t="ville.20120502221057.7500"><vh>g.childrenModifiedSet, g.contentModifiedSet</vh></v>
<v t="ekr.20031218072017.1596"><vh>g.doHook</vh></v>
<v t="ekr.20100910075900.5950"><vh>g.Wrappers for g.app.pluginController methods</vh>
<v t="ekr.20100910075900.5951"><vh>g.Loading &amp; registration</vh></v>
<v t="ekr.20100910075900.5952"><vh>g.Information</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1315"><vh>g.Idle time functions</vh>
<v t="EKR.20040602125018.1"><vh>g.disableIdleTimeHook</vh></v>
<v t="EKR.20040602125018"><vh>g.enableIdleTimeHook</vh></v>
<v t="ekr.20140825042850.18410"><vh>g.IdleTime</vh></v>
<v t="ekr.20161027205025.1"><vh>g.idleTimeHookHandler (stub)</vh></v>
</v>
<v t="ekr.20041219095213"><vh>g.Importing</vh>
<v t="ekr.20040917061619"><vh>g.cantImport</vh></v>
<v t="ekr.20191220044128.1"><vh>g.import_module</vh></v>
</v>
<v t="ekr.20140711071454.17650"><vh>g.Indices, Strings, Unicode &amp; Whitespace</vh>
<v t="ekr.20140711071454.17647"><vh>g.Indices</vh>
<v t="ekr.20050314140957"><vh>g.convertPythonIndexToRowCol</vh></v>
<v t="ekr.20050315071727"><vh>g.convertRowColToPythonIndex</vh></v>
<v t="ekr.20061031102333.2"><vh>g.getWord &amp; getLine</vh></v>
<v t="ekr.20111114151846.9847"><vh>g.toPythonIndex</vh></v>
</v>
<v t="ekr.20140526144610.17601"><vh>g.Strings</vh>
<v t="ekr.20190503145501.1"><vh>g.isascii</vh></v>
<v t="ekr.20031218072017.3106"><vh>g.angleBrackets &amp; virtual_event_name</vh></v>
<v t="ekr.20090516135452.5777"><vh>g.ensureLeading/TrailingNewlines</vh></v>
<v t="ekr.20050920084036.4"><vh>g.longestCommonPrefix &amp; g.itemsMatchingPrefixInList</vh></v>
<v t="ekr.20090516135452.5776"><vh>g.removeLeading/Trailing</vh></v>
<v t="ekr.20060410112600"><vh>g.stripBrackets</vh></v>
<v t="ekr.20170317101100.1"><vh>g.unCamel</vh></v>
</v>
<v t="ekr.20031218072017.1498"><vh>g.Unicode</vh>
<v t="ekr.20190505052756.1"><vh>g.checkUnicode</vh></v>
<v t="ekr.20100125073206.8709"><vh>g.getPythonEncodingFromString</vh></v>
<v t="ekr.20031218072017.1500"><vh>g.isValidEncoding</vh></v>
<v t="ekr.20061006152327"><vh>g.isWordChar &amp; g.isWordChar1</vh></v>
<v t="ekr.20130910044521.11304"><vh>g.stripBOM</vh></v>
<v t="ekr.20050208093800"><vh>g.toEncodedString</vh></v>
<v t="ekr.20050208093800.1"><vh>g.toUnicode</vh></v>
</v>
<v t="ekr.20031218072017.3197"><vh>g.Whitespace</vh>
<v t="ekr.20031218072017.3198"><vh>g.computeLeadingWhitespace</vh></v>
<v t="ekr.20120605172139.10263"><vh>g.computeLeadingWhitespaceWidth</vh></v>
<v t="ekr.20031218072017.3199"><vh>g.computeWidth</vh></v>
<v t="ekr.20110727091744.15083"><vh>g.wrap_lines (newer)</vh>
<v t="ekr.20110727091744.15084"><vh>&lt;&lt; place blank and word on the present line &gt;&gt;</vh></v>
<v t="ekr.20110727091744.15085"><vh>&lt;&lt; place word on a new line &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3200"><vh>g.get_leading_ws</vh></v>
<v t="ekr.20031218072017.3201"><vh>g.optimizeLeadingWhitespace</vh></v>
<v t="ekr.20040723093558"><vh>g.regularizeTrailingNewlines</vh></v>
<v t="ekr.20091229090857.11698"><vh>g.removeBlankLines</vh></v>
<v t="ekr.20091229075924.6235"><vh>g.removeLeadingBlankLines</vh></v>
<v t="ekr.20031218072017.3202"><vh>g.removeLeadingWhitespace</vh></v>
<v t="ekr.20031218072017.3203"><vh>g.removeTrailingWs</vh></v>
<v t="ekr.20031218072017.3204"><vh>g.skip_leading_ws</vh></v>
<v t="ekr.20031218072017.3205"><vh>g.skip_leading_ws_with_indent</vh></v>
<v t="ekr.20040723093558.1"><vh>g.stripBlankLines</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3108"><vh>g.Logging &amp; Printing</vh>
<v t="ekr.20080821073134.2"><vh>g.doKeywordArgs</vh></v>
<v t="ekr.20031218072017.1474"><vh>g.enl, ecnl &amp; ecnls</vh></v>
<v t="ekr.20100914094836.5892"><vh>g.error, g.note, g.warning, g.red, g.blue</vh></v>
<v t="ekr.20070626132332"><vh>g.es</vh></v>
<v t="ekr.20060917120951"><vh>g.es_dump</vh></v>
<v t="ekr.20031218072017.3110"><vh>g.es_error &amp; es_print_error</vh></v>
<v t="ekr.20031218072017.3111"><vh>g.es_event_exception</vh></v>
<v t="ekr.20031218072017.3112"><vh>g.es_exception</vh></v>
<v t="ekr.20061015090538"><vh>g.es_exception_type</vh></v>
<v t="ekr.20050707064040"><vh>g.es_print</vh></v>
<v t="ekr.20050707065530"><vh>g.es_trace</vh></v>
<v t="ekr.20220820050145.1"><vh>g.function_name</vh></v>
<v t="ekr.20230129093329.1"><vh>g.get_ctor_name</vh></v>
<v t="ekr.20040731204831"><vh>g.getLastTracebackFileAndLineNumber</vh></v>
<v t="ekr.20150621095017.1"><vh>g.goto_last_exception</vh></v>
<v t="ekr.20100126062623.6240"><vh>g.internalError</vh></v>
<v t="ekr.20150127060254.5"><vh>g.log_to_file</vh></v>
<v t="ekr.20080710101653.1"><vh>g.pr</vh></v>
<v t="ekr.20060221083356"><vh>g.prettyPrintType</vh></v>
<v t="ekr.20111107181638.9741"><vh>g.print_exception</vh></v>
<v t="ekr.20031218072017.3113"><vh>g.printBindings</vh></v>
<v t="ekr.20070510074941"><vh>g.printEntireTree</vh></v>
<v t="ekr.20031218072017.3114"><vh>g.printGlobals</vh></v>
<v t="ekr.20031218072017.3115"><vh>g.printLeoModules</vh></v>
<v t="ekr.20041122153823"><vh>g.printStack</vh></v>
<v t="ekr.20031218072017.2317"><vh>g.trace</vh></v>
<v t="ekr.20080220111323"><vh>g.translateArgs</vh></v>
<v t="ekr.20060810095921"><vh>g.translateString &amp; tr</vh></v>
</v>
<v t="EKR.20040612114220"><vh>g.Miscellaneous</vh>
<v t="ekr.20120928142052.10116"><vh>g.actualColor</vh></v>
<v t="ekr.20060921100435"><vh>g.CheckVersion &amp; helpers</vh>
<v t="ekr.20070120123930"><vh>g.CheckVersionToInt</vh></v>
</v>
<v t="ekr.20111103205308.9657"><vh>g.cls</vh></v>
<v t="ekr.20131114124839.16665"><vh>g.createScratchCommander</vh></v>
<v t="ekr.20031218072017.3126"><vh>g.funcToMethod (Python Cookbook)</vh></v>
<v t="ekr.20060913090832.1"><vh>g.init_zodb</vh></v>
<v t="ekr.20170206080908.1"><vh>g.input_</vh></v>
<v t="ekr.20110609125359.16493"><vh>g.isMacOS</vh></v>
<v t="ekr.20181027133311.1"><vh>g.issueSecurityWarning</vh></v>
<v t="ekr.20031218072017.3144"><vh>g.makeDict (Python Cookbook)</vh></v>
<v t="ekr.20140528065727.17963"><vh>g.pep8_class_name</vh></v>
<v t="ekr.20160417174224.1"><vh>g.plural</vh></v>
<v t="ekr.20160331194701.1"><vh>g.truncate</vh></v>
<v t="ekr.20031218072017.3150"><vh>g.windows</vh></v>
</v>
<v t="ekr.20031218072017.2145"><vh>g.os_path_ Wrappers</vh>
<v t="ekr.20230410134119.1"><vh>g.finalize</vh></v>
<v t="ekr.20230410133838.1"><vh>g.finalize_join</vh></v>
<v t="ekr.20180314120442.1"><vh>g.glob_glob</vh></v>
<v t="ekr.20031218072017.2146"><vh>g.os_path_abspath</vh></v>
<v t="ekr.20031218072017.2147"><vh>g.os_path_basename</vh></v>
<v t="ekr.20031218072017.2148"><vh>g.os_path_dirname</vh></v>
<v t="ekr.20230418102243.1"><vh>g.os_path_expanduser</vh></v>
<v t="ekr.20031218072017.2149"><vh>g.os_path_exists</vh></v>
<v t="ekr.20031218072017.2150"><vh>g.os_path_getmtime</vh></v>
<v t="ekr.20080729142651.2"><vh>g.os_path_getsize</vh></v>
<v t="ekr.20031218072017.2151"><vh>g.os_path_isabs</vh></v>
<v t="ekr.20031218072017.2152"><vh>g.os_path_isdir</vh></v>
<v t="ekr.20031218072017.2153"><vh>g.os_path_isfile</vh></v>
<v t="ekr.20031218072017.2154"><vh>g.os_path_join</vh></v>
<v t="ekr.20031218072017.2156"><vh>g.os_path_normcase</vh></v>
<v t="ekr.20031218072017.2157"><vh>g.os_path_normpath</vh></v>
<v t="ekr.20180314081254.1"><vh>g.os_path_normslashes</vh></v>
<v t="ekr.20080605064555.2"><vh>g.os_path_realpath</vh></v>
<v t="ekr.20031218072017.2158"><vh>g.os_path_split</vh></v>
<v t="ekr.20031218072017.2159"><vh>g.os_path_splitext</vh></v>
<v t="ekr.20090829140232.6036"><vh>g.os_startfile</vh>
<v t="bob.20170516112250.1"><vh>stderr2log()</vh></v>
<v t="bob.20170516112304.1"><vh>itPoll()</vh></v>
</v>
</v>
<v t="ekr.20111115155710.9859"><vh>g.Parsing &amp; Tokenizing</vh>
<v t="ekr.20031218072017.822"><vh>g.createTopologyList</vh></v>
<v t="ekr.20111017204736.15898"><vh>g.getDocString</vh></v>
<v t="ekr.20111017211256.15905"><vh>g.getDocStringForFunction</vh></v>
<v t="ekr.20111115155710.9814"><vh>g.python_tokenize (not used)</vh></v>
</v>
<v t="ekr.20040327103735.2"><vh>g.Scripting</vh>
<v t="ekr.20161223090721.1"><vh>g.exec_file</vh></v>
<v t="ekr.20131016032805.16721"><vh>g.execute_shell_commands</vh></v>
<v t="ekr.20180217113719.1"><vh>g.execute_shell_commands_with_options &amp; helpers</vh>
<v t="ekr.20180217152624.1"><vh>g.computeBaseDir</vh></v>
<v t="ekr.20180217153459.1"><vh>g.computeCommands</vh></v>
</v>
<v t="ekr.20050503112513.7"><vh>g.executeFile</vh></v>
<v t="ekr.20040321065415"><vh>g.find*Node*</vh>
<v t="ekr.20210303123423.3"><vh>g.findNodeAnywhere</vh></v>
<v t="ekr.20210303123525.1"><vh>g.findNodeByPath</vh></v>
<v t="ekr.20210303123423.1"><vh>g.findNodeInChildren</vh></v>
<v t="ekr.20210303123423.2"><vh>g.findNodeInTree</vh></v>
<v t="ekr.20210303123423.4"><vh>g.findTopLevelNode</vh></v>
</v>
<v t="EKR.20040614071102.1"><vh>g.getScript &amp; helpers</vh>
<v t="ekr.20170228082641.1"><vh>g.composeScript</vh></v>
<v t="ekr.20170123074946.1"><vh>g.extractExecutableString</vh></v>
</v>
<v t="ekr.20060624085200"><vh>g.handleScriptException</vh>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
<v t="ekr.20140209065845.16767"><vh>g.insertCodingLine</vh></v>
</v>
<v t="ekr.20070524083513"><vh>g.Unit Tests</vh>
<v t="ekr.20210901071523.1"><vh>g.run_coverage_tests</vh></v>
<v t="ekr.20210901065224.1"><vh>g.run_unit_tests</vh></v>
</v>
<v t="ekr.20120311151914.9916"><vh>g.Urls &amp; UNLs</vh>
<v t="ekr.20230624100622.1"><vh>&lt;&lt; About clickable links &gt;&gt;</vh></v>
<v t="ekr.20120320053907.9776"><vh>g.computeFileUrl</vh></v>
<v t="ekr.20190608090856.1"><vh>g.es_clickable_link (not used)</vh></v>
<v t="ekr.20230624015529.1"><vh>g.findGNX</vh></v>
<v t="ekr.20120311151914.9917"><vh>g.getUrlFromNode</vh></v>
<v t="ekr.20170221063527.1"><vh>g.handleUnl</vh></v>
<v t="tbrown.20090219095555.63"><vh>g.handleUrl &amp; helpers</vh>
<v t="ekr.20170226054459.1"><vh>g.handleUrlHelper</vh></v>
<v t="ekr.20170226060816.1"><vh>g.traceUrl</vh></v>
</v>
<v t="ekr.20120311151914.9918"><vh>g.isValidUrl</vh></v>
<v t="ekr.20120315062642.9744"><vh>g.openUrl</vh></v>
<v t="ekr.20110605121601.18135"><vh>g.openUrlOnClick (open-url-under-cursor)</vh>
<v t="ekr.20170216091704.1"><vh>g.openUrlHelper (changed)</vh>
<v t="tom.20220328141455.1"><vh>&lt;&lt; look for section ref &gt;&gt;</vh></v>
<v t="tom.20220328141544.1"><vh>&lt;&lt; look for url  &gt;&gt;</vh></v>
<v t="ekr.20220704211851.1"><vh>&lt;&lt; look for unl &gt;&gt;</vh></v>
<v t="tom.20220328142302.1"><vh>&lt;&lt; look for gnx &gt;&gt;</vh></v>
<v t="tom.20230130102836.1"><vh>&lt;&lt; look for filename or import &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20170226093349.1"><vh>g.unquoteUrl</vh></v>
</v>
</v>
<v t="ekr.20230622112649.1"><vh>Error messages (copy to log)</vh></v>
<v t="ekr.20230626113050.1"><vh>Test outline: copy root to new outline</vh>
<v t="ekr.20230626113103.1"><vh>root</vh>
<v t="ekr.20230626113114.1"><vh>child 1</vh>
<v t="ekr.20230626113118.1"><vh>grandchild 1</vh></v>
</v>
</v>
</v>
<v t="ekr.20230625084119.1"><vh>Legacy UNLs: in this file</vh></v>
<v t="ekr.20230628090119.1"><vh>Legacy UNLs: other files</vh></v>
<v t="ekr.20230623141357.1"><vh>URLs and UNLs: </vh></v>
<v t="ekr.20230627150454.1"><vh>New UNLs with file parts</vh></v>
</vnodes>
<tnodes>
<t tx="EKR.20040504150046.4">def comment_delims_from_extension(filename: str) -&gt; tuple[str, str, str]:
    """
    Return the comment delims corresponding to the filename's extension.
    """
    if filename.startswith('.'):
        root, ext = None, filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    g.trace(
        f"unknown extension: {ext!r}, "
        f"filename: {filename!r}, "
        f"root: {root!r}")
    return '', '', ''
</t>
<t tx="EKR.20040504154039">def is_sentinel(line: str, delims: Sequence) -&gt; bool:
    """
    Return True if line starts with a sentinel comment.

    Leo 6.7.2: Support blackened sentinels.
    """
    delim1, delim2, delim3 = delims
    # Defensive code. Make *sure* delim has no trailing space.
    if delim1:
        delim1 = delim1.rstrip()
    line = line.lstrip()
    if delim1:
        sentinel1 = delim1 + '@'
        sentinel2 = delim1 + ' @'
        return line.startswith((sentinel1, sentinel2))
    if delim2 and delim3:
        sentinel1 = delim2 + '@'
        sentinel2 = delim2 + ' @'
        if sentinel1 in line:
            i = line.find(sentinel1)
            j = line.find(delim3)
            return 0 == i &lt; j
        if sentinel2 in line:
            i = line.find(sentinel2)
            j = line.find(delim3)
            return 0 == i &lt; j
    g.error(f"is_sentinel: can not happen. delims: {repr(delims)}")
    return False
</t>
<t tx="EKR.20040602125018">def enableIdleTimeHook(*args: Any, **keys: Any) -&gt; None:
    """Enable idle-time processing."""
    g.app.idle_time_hooks_enabled = True
</t>
<t tx="EKR.20040602125018.1">def disableIdleTimeHook() -&gt; None:
    """Disable the global idle-time hook."""
    g.app.idle_time_hooks_enabled = False
</t>
<t tx="EKR.20040610094819"># Visible externally so plugins may add to the list of directives.
# The atFile write logic uses this, but not the atFile read logic.
globalDirectiveList = [
    # Order does not matter.
    'all',
    'beautify',
    'colorcache', 'code', 'color', 'comment', 'c',
    'delims', 'doc',
    'encoding',
    # 'end_raw',  # #2276.
    'first', 'header', 'ignore',
    'killbeautify', 'killcolor',
    'language', 'last', 'lineending',
    'markup',
    'nobeautify',
    'nocolor-node', 'nocolor', 'noheader', 'nowrap',
    'nopyflakes',  # Leo 6.1.
    'nosearch',  # Leo 5.3.
    'others', 'pagewidth', 'path', 'quiet',
    # 'raw',  # #2276.
    'section-delims',  # Leo 6.6. #2276.
    'silent',
    'tabwidth',
    'unit', 'verbose', 'wrap',
]

directives_pat = None  # Set below.
</t>
<t tx="EKR.20040612114220"></t>
<t tx="EKR.20040612114220.4">class ReadLinesClass:
    """A class whose next method provides a readline method for Python's tokenize module."""

    def __init__(self, s: str) -&gt; None:
        self.lines = g.splitLines(s)
        self.i = 0

    def next(self) -&gt; str:
        if self.i &lt; len(self.lines):
            line = self.lines[self.i]
            self.i += 1
        else:
            line = ''
        return line

    __next__ = next
</t>
<t tx="EKR.20040612215018">if g.os_path_exists(fileName):
    with open(fileName) as f:
        lines = f.readlines()
else:
    lines = g.splitLines(script)
s = '-' * 20
g.es_print('', s)
# Print surrounding lines.
i = max(0, n - 2)
j = min(n + 2, len(lines))
while i &lt; j:
    ch = '*' if i == n - 1 else ' '
    s = f"{ch} line {i+1:d}: {lines[i]}"
    g.es('', s, newline=False)
    i += 1
</t>
<t tx="EKR.20040614071102.1">def getScript(
    c: Cmdr,
    p: Position,
    useSelectedText: bool = True,
    forcePythonSentinels: bool = True,
    useSentinels: bool = True,
) -&gt; str:
    """
    Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if
    p is not the current node or if there is no text selection.
    """
    w = c.frame.body.wrapper
    if not p:
        p = c.p
    try:
        if g.app.inBridge:
            s = p.b
        elif w and p == c.p and useSelectedText and w.hasSelection():
            s = w.getSelectedText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = textwrap.dedent(s)
        s = g.extractExecutableString(c, p, s)
        script = g.composeScript(c, p, s,
                    forcePythonSentinels=forcePythonSentinels,
                    useSentinels=useSentinels)
    except Exception:
        g.es_print("unexpected exception in g.getScript")
        g.es_exception()
        script = ''
    return script
</t>
<t tx="bob.20170516112250.1">def stderr2log(g: Any, ree: Any, fname: str) -&gt; None:
    """ Display stderr output in the Leo-Editor log pane

    Arguments:
        g:  Leo-Editor globals
        ree:  Read file descriptor for stderr
        fname:  file pathname

    Returns:
        None
    """

    while True:
        emsg = ree.read().decode('utf-8')
        if emsg:
            g.es_print_error(f"xdg-open {fname} caused output to stderr:\n{emsg}")
        else:
            break
</t>
<t tx="bob.20170516112304.1">def itPoll(fname: str, ree: Any, subPopen: Any, g: Any, ito: Any) -&gt; None:
    """ Poll for subprocess done

    Arguments:
        fname:  File name
        ree:  stderr read file descriptor
        subPopen:  URL open subprocess object
        g: Leo-Editor globals
        ito: Idle time object for itPoll()

    Returns:
        None
    """

    stderr2log(g, ree, fname)
    rc = subPopen.poll()
    if rc is not None:
        ito.stop()
        ito.destroy_self()
        if rc != 0:
            g.es_print(f"xdg-open {fname} failed with exit code {rc}")
        stderr2log(g, ree, fname)
        ree.close()
</t>
<t tx="ekr.20031218072017.1264">def getBaseDirectory(c: Cmdr) -&gt; str:
    """
    This function is deprectated.

    Previously it convert '!' or '.' to proper directory references using
    @string relative-path-base-directory.
    """
    return ''
</t>
<t tx="ekr.20031218072017.1315"></t>
<t tx="ekr.20031218072017.1317">def module_date(mod: Any, format: str = None) -&gt; str:
    theFile = g.os_path_join(app.loadDir, mod.__file__)
    root, ext = g.os_path_splitext(theFile)
    return g.file_date(root + ".py", format=format)

def plugin_date(plugin_mod: Any, format: str = None) -&gt; str:
    theFile = g.os_path_join(app.loadDir, "..", "plugins", plugin_mod.__file__)
    root, ext = g.os_path_splitext(theFile)
    return g.file_date(root + ".py", format=str)

def file_date(theFile: Any, format: str = None) -&gt; str:
    if theFile and g.os_path_exists(theFile):
        try:
            n = g.os_path_getmtime(theFile)
            if format is None:
                format = "%m/%d/%y %H:%M:%S"
            return time.strftime(format, time.gmtime(n))
        except(ImportError, NameError):
            pass  # Time module is platform dependent.
    return ""
</t>
<t tx="ekr.20031218072017.1380"># Weird pylint bug, activated by TestLeoGlobals class.
# Disabling this will be safe, because pyflakes will still warn about true redefinitions
# pylint: disable=function-redefined
</t>
<t tx="ekr.20031218072017.1382">def set_delims_from_language(language: str) -&gt; tuple[str, str, str]:
    """Return a tuple (single,start,end) of comment delims."""
    val = g.app.language_delims_dict.get(language)
    if val:
        delim1, delim2, delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return '', delim1, delim2
        # 0,1 or 3 params.
        return delim1, delim2, delim3
    return '', '', ''  # Indicate that no change should be made
</t>
<t tx="ekr.20031218072017.1383">def set_delims_from_string(s: str) -&gt; tuple[str, str, str]:
    """
    Return (delim1, delim2, delim2), the delims following the @comment
    directive.

    This code can be called from @language logic, in which case s can
    point at @comment
    """
    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s, i, tag):
        i += len(tag)
    count = 0
    delims = ['', '', '']
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s, i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
            i += 1
        if j == i:
            break
        delims[count] = s[j:i] or ''
        count += 1
    # 'rr 09/25/02
    if count == 2:  # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = ''
    for i in range(0, 3):
        if delims[i]:
            if delims[i].startswith("@0x"):
                # Allow delimiter definition as @0x + hexadecimal encoded delimiter
                # to avoid problems with duplicate delimiters on the @comment line.
                # If used, whole delimiter must be encoded.
                if len(delims[i]) == 3:
                    g.warning(f"'{delims[i]}' delimiter is invalid")
                    return None, None, None
                try:
                    delims[i] = binascii.unhexlify(delims[i][3:])  # type:ignore
                    delims[i] = g.toUnicode(delims[i])
                except Exception as e:
                    g.warning(f"'{delims[i]}' delimiter is invalid: {e}")
                    return None, None, None
            else:
                # 7/8/02: The "REM hack": replace underscores by blanks.
                # 9/25/02: The "perlpod hack": replace double underscores by newlines.
                delims[i] = delims[i].replace("__", '\n').replace('_', ' ')
    return delims[0], delims[1], delims[2]
</t>
<t tx="ekr.20031218072017.1384">def set_language(s: str, i: int, issue_errors_flag: bool = False) -&gt; tuple:
    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """
    tag = "@language"
    assert i is not None
    if g.match_word(s, i, tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i
    i = g.skip_c_id(s, i)
    # Allow tcl/tk.
    arg = s[j:i].lower()
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    if issue_errors_flag:
        g.es("ignoring:", g.get_line(s, i))
    return None, None, None, None
</t>
<t tx="ekr.20031218072017.1385"># Called from the syntax coloring method that colorizes section references.
# Also called from write at.putRefAt.

def findReference(name: str, root: Position) -&gt; Optional[Position]:
    """Return the position containing the section definition for name."""
    for p in root.subtree(copy=False):
        assert p != root
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p.copy()
    return None
</t>
<t tx="ekr.20031218072017.1386">def getOutputNewline(c: Cmdr = None, name: str = None) -&gt; str:
    """Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.
    """
    if name:
        s = name
    elif c:
        s = c.config.getString('output-newline')
    else:
        s = 'nl'  # Legacy value. Perhaps dubious.
    if not s:
        s = ''
    s = s.lower()
    if s in ("nl", "lf"):
        s = '\n'
    elif s == "cr":
        s = '\r'
    elif s == "platform":
        s = os.linesep  # 12/2/03: emakital
    elif s == "crlf":
        s = "\r\n"
    else:
        s = '\n'  # Default for erroneous values.
    assert isinstance(s, str), repr(s)
    return s
</t>
<t tx="ekr.20031218072017.1474">def ecnl(tabName: str = 'Log') -&gt; None:
    g.ecnls(1, tabName)

def ecnls(n: int, tabName: str = 'Log') -&gt; None:
    log = app.log
    if log and not log.isNull:
        while log.newlines &lt; n:
            g.enl(tabName)

def enl(tabName: str = 'Log') -&gt; None:
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)
</t>
<t tx="ekr.20031218072017.1498"></t>
<t tx="ekr.20031218072017.1500">def isValidEncoding(encoding: str) -&gt; bool:
    """Return True if the encoding is valid."""
    if not encoding:
        return False
    if sys.platform == 'cli':
        return True
    try:
        codecs.lookup(encoding)
        return True
    except LookupError:  # Windows
        return False
    except AttributeError:  # Linux
        return False
    except Exception:
        # UnicodeEncodeError
        g.es_print('Please report the following error')
        g.es_exception()
        return False
</t>
<t tx="ekr.20031218072017.1588"></t>
<t tx="ekr.20031218072017.1589">def clearAllIvars(o: Any) -&gt; None:
    """Clear all ivars of o, a member of some class."""
    if o:
        o.__dict__.clear()
</t>
<t tx="ekr.20031218072017.1592"># Formerly called from unit tests.

def printGc() -&gt; None:
    """Called from trace_gc_plugin."""
    g.printGcSummary()
    g.printGcObjects()
    g.printGcRefs()
</t>
<t tx="ekr.20031218072017.1593">def printGcRefs() -&gt; None:

    refs = gc.get_referrers(app.windowList[0])
    print(f"{len(refs):d} referrers")
</t>
<t tx="ekr.20031218072017.1596">def doHook(tag: str, *args: Any, **keywords: Any) -&gt; Any:
    """
    This global function calls a hook routine. Hooks are identified by the
    tag param.

    Returns the value returned by the hook routine, or None if the there is
    an exception.

    We look for a hook routine in three places:
    1. c.hookFunction
    2. app.hookFunction
    3. leoPlugins.doPlugins()

    Set app.hookError on all exceptions.
    Scripts may reset app.hookError to try again.
    """
    if g.app.killed or g.app.hookError:
        return None
    if args:
        # A minor error in Leo's core.
        g.pr(f"***ignoring args param.  tag = {tag}")
    if not g.app.enablePlugins:
        if tag in ('open0', 'start1'):
            g.warning("Plugins disabled: use_plugins is 0 in a leoSettings.leo file.")
        return None
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    # pylint: disable=consider-using-ternary
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        g.app.hookFunction = f = g.app.pluginsController.doPlugins
    try:
        # Pass the hook to the hook handler.
        # g.pr('doHook',f.__name__,keywords.get('c'))
        return f(tag, keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True  # Suppress this function.
        g.app.idle_time_hooks_enabled = False
        return None
</t>
<t tx="ekr.20031218072017.1656">@others
</t>
<t tx="ekr.20031218072017.2145">@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
</t>
<t tx="ekr.20031218072017.2146">def os_path_abspath(path: str) -&gt; str:
    """Convert a path to an absolute path."""
    if not path:
        return ''
    path = os.path.abspath(path)
    path = g.os_path_normslashes(path)
    return path
</t>
<t tx="ekr.20031218072017.2147">def os_path_basename(path: str) -&gt; str:
    """Return the second half of the pair returned by split(path)."""
    if not path:
        return ''
    path = os.path.basename(path)
    path = g.os_path_normslashes(path)
    return path
</t>
<t tx="ekr.20031218072017.2148">def os_path_dirname(path: str) -&gt; str:
    """Return the first half of the pair returned by split(path)."""
    if not path:
        return ''
    path = os.path.dirname(path)
    path = g.os_path_normslashes(path)
    return path
</t>
<t tx="ekr.20031218072017.2149">def os_path_exists(path: str) -&gt; bool:
    """Return True if path exists."""
    return os.path.exists(path) if path else False
</t>
<t tx="ekr.20031218072017.2150">def os_path_getmtime(path: str) -&gt; float:
    """Return the modification time of path."""
    if not path:
        return 0
    try:
        return os.path.getmtime(path)
    except Exception:
        return 0
</t>
<t tx="ekr.20031218072017.2151">def os_path_isabs(path: str) -&gt; bool:
    """Return True if path is an absolute path."""
    return os.path.isabs(path) if path else False
</t>
<t tx="ekr.20031218072017.2152">def os_path_isdir(path: str) -&gt; bool:
    """Return True if the path is a directory."""
    return os.path.isdir(path) if path else False
</t>
<t tx="ekr.20031218072017.2153">def os_path_isfile(path: str) -&gt; bool:
    """Return True if path is a file."""
    return os.path.isfile(path) if path else False
</t>
<t tx="ekr.20031218072017.2154">def os_path_join(*args: Any, **keys: Any) -&gt; str:
    """
    Wrap os.path.join, *without* finalizing the result.
    """
    uargs = [z for z in args if z]
    if not uargs:
        return ''
    path = os.path.join(*uargs)
    path = g.os_path_normslashes(path)
    return path

</t>
<t tx="ekr.20031218072017.2156">def os_path_normcase(path: str) -&gt; str:
    """Normalize the path's case."""
    if not path:
        return ''
    path = os.path.normcase(path)
    path = g.os_path_normslashes(path)
    return path

</t>
<t tx="ekr.20031218072017.2157">def os_path_normpath(path: str) -&gt; str:
    """Normalize the path."""
    if not path:
        return ''
    path = os.path.normpath(path)
    path = g.os_path_normslashes(path)
    return path
</t>
<t tx="ekr.20031218072017.2158">def os_path_split(path: str) -&gt; tuple[str, str]:
    if not path:
        return '', ''
    head, tail = os.path.split(path)
    return head, tail
</t>
<t tx="ekr.20031218072017.2159">def os_path_splitext(path: str) -&gt; tuple[str, str]:

    if not path:
        return '', ''
    head, tail = os.path.splitext(path)
    return head, tail
</t>
<t tx="ekr.20031218072017.2317">def trace(*args: Any, **keys: Any) -&gt; None:
    """Print the name of the calling function followed by all the args."""
    name = g._callerName(2)
    if name.endswith(".pyc"):
        name = name[:-1]
    g.pr(name, *args)
</t>
<t tx="ekr.20031218072017.2369">def skip_string(s: str, i: int) -&gt; int:
    """Scan forward to the end of a string."""
    delim = s[i]
    i += 1
    assert delim in '\'"', (repr(delim), repr(s))
    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\':
            i += 2
        else:
            i += 1
    if i &gt;= n:
        pass
    elif s[i] == delim:
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3093">"""
Global constants, variables and utility functions used throughout Leo.

Important: This module imports no other Leo module.
"""
&lt;&lt; leoGlobals imports &gt;&gt;
&lt;&lt; leoGlobals annotations &gt;&gt;
in_bridge = False  # True: leoApp object loads a null Gui.
in_vs_code = False  # #2098.
minimum_python_version = '3.9'
isPython3 = sys.version_info &gt;= (3, 0, 0)  # Not used in Leo's core.
isMac = sys.platform.startswith('darwin')
isWindows = sys.platform.startswith('win')
&lt;&lt; define g.globalDirectiveList &gt;&gt;
&lt;&lt; define global decorator dicts &gt;&gt;
&lt;&lt; define global error regexes &gt;&gt;
&lt;&lt; define g.decorators &gt;&gt;
&lt;&lt; define regex's &gt;&gt;
tree_popup_handlers: list[Callable] = []  # Set later.
user_dict: dict[Any, Any] = {}  # Non-persistent dictionary for scripts and plugins.
app: Any = None  # The singleton app object. Set by runLeo.py.
# Global status vars.
inScript = False  # A synonym for app.inScript
unitTesting = False  # A synonym for app.unitTesting.
@others
# set g when the import is about to complete.
g = sys.modules.get('leo.core.leoGlobals')
assert g, sorted(sys.modules.keys())
if __name__ == '__main__':
    unittest.main()

@language python
@tabwidth -4
@pagewidth 70
</t>
<t tx="ekr.20031218072017.3098">class Bunch:
    """
    From The Python Cookbook:

        Create a Bunch whenever you want to group a few variables:

            point = Bunch(datum=y, squared=y*y, coord=x)

        You can read/write the named attributes you just created, add others,
        del some of them, etc::

            if point.squared &gt; threshold:
                point.isok = True
    """

    def __init__(self, **keywords: Any) -&gt; None:
        self.__dict__.update(keywords)

    def __repr__(self) -&gt; str:
        return self.toString()

    def ivars(self) -&gt; list:
        return sorted(self.__dict__)

    def keys(self) -&gt; list:
        return sorted(self.__dict__)

    def toString(self) -&gt; str:
        tag = self.__dict__.get('tag')
        entries = [
            f"{key}: {str(self.__dict__.get(key)) or repr(self.__dict__.get(key))}"
                for key in self.ivars() if key != 'tag'
        ]
        # Fail.
        result = [f'g.Bunch({tag or ""})']
        result.extend(entries)
        return '\n    '.join(result) + '\n'

    # Used by new undo code.

    def __setitem__(self, key: str, value: Any) -&gt; Any:
        """Support aBunch[key] = val"""
        return operator.setitem(self.__dict__, key, value)

    def __getitem__(self, key: str) -&gt; Any:
        """Support aBunch[key]"""
        # g.pr('g.Bunch.__getitem__', key)
        return operator.getitem(self.__dict__, key)

    def get(self, key: str, theDefault: Any = None) -&gt; Any:
        return self.__dict__.get(key, theDefault)

    def __contains__(self, key: str) -&gt; bool:  # New.
        # g.pr('g.Bunch.__contains__', key in self.__dict__, key)
        return key in self.__dict__

bunch = Bunch
</t>
<t tx="ekr.20031218072017.3103">def computeWindowTitle(fileName: str) -&gt; str:

    branch, commit = g.gitInfoForFile(fileName)  # #1616
    if not fileName:
        return branch + ": untitled" if branch else 'untitled'
    path, fn = g.os_path_split(fileName)
    if path:
        title = fn + " in " + path
    else:
        title = fn
    # Yet another fix for bug 1194209: regularize slashes.
    if os.sep in '/\\':
        title = title.replace('/', os.sep).replace('\\', os.sep)
    if branch:
        title = branch + ": " + title
    return title
</t>
<t tx="ekr.20031218072017.3104"></t>
<t tx="ekr.20031218072017.3106">def angleBrackets(s: str) -&gt; str:
    """Returns &lt; &lt; s &gt; &gt;"""
    lt = "&lt;&lt;"
    rt = "&gt;&gt;"
    return lt + s + rt

virtual_event_name = angleBrackets
</t>
<t tx="ekr.20031218072017.3107">def _callerName(n: int) -&gt; str:
    try:
        # get the function name from the call stack.
        f1 = sys._getframe(n)  # The stack frame, n levels up.
        code1 = f1.f_code  # The code object
        locals_ = f1.f_locals  # The local namespace.
        name = code1.co_name
        # sfn = shortFilename(code1.co_filename)  # The file name.
        # line = code1.co_firstlineno
        obj = locals_.get('self')
        if obj and name == '__init__':
            return f"{obj.__class__.__name__}.{name}"
        return name
    except ValueError:
        # The stack is not deep enough OR
        # sys._getframe does not exist on this platform.
        return ''
    except Exception:
        es_exception()
        return ''  # "&lt;no caller name&gt;"
</t>
<t tx="ekr.20031218072017.3108"># g.es and related print to the Log window.
# g.pr prints to the console.
# g.es_print and related print to both the Log window and the console.
</t>
<t tx="ekr.20031218072017.3109">def dump(s: str) -&gt; str:
    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out

def oldDump(s: str) -&gt; str:
    out = ""
    for i in s:
        if i == '\n':
            out += "["
            out += "n"
            out += "]"
        if i == '\t':
            out += "["
            out += "t"
            out += "]"
        elif i == ' ':
            out += "["
            out += " "
            out += "]"
        else:
            out += i
    return out
</t>
<t tx="ekr.20031218072017.3110">def es_error(*args: Any, **keys: Any) -&gt; None:
    color = keys.get('color')
    if color is None and g.app.config:
        keys['color'] = g.app.config.getColor("log-error-color") or 'red'
    g.es(*args, **keys)

def es_print_error(*args: Any, **keys: Any) -&gt; None:
    color = keys.get('color')
    if color is None and g.app.config:
        keys['color'] = g.app.config.getColor("log-error-color") or 'red'
    g.es_print(*args, **keys)
</t>
<t tx="ekr.20031218072017.3111">def es_event_exception(eventName: str, full: bool = False) -&gt; None:
    g.es("exception handling ", eventName, "event")
    typ, val, tb = sys.exc_info()
    if full:
        errList = traceback.format_exception(typ, val, tb)
    else:
        errList = traceback.format_exception_only(typ, val)
    for i in errList:
        g.es('', i)
    if not g.stdErrIsRedirected():  # 2/16/04
        traceback.print_exc()
</t>
<t tx="ekr.20031218072017.3112">def es_exception(*args: Sequence, **kwargs: Sequence) -&gt; None:
    """Print the last exception."""
    # val is the second argument to the raise statement.
    typ, val, tb = sys.exc_info()
    for line in traceback.format_exception(typ, val, tb):
        g.es_print_error(line)
</t>
<t tx="ekr.20031218072017.3113">def print_bindings(name: str, window: Any) -&gt; None:
    bindings = window.bind()
    g.pr("\nBindings for", name)
    for b in bindings:
        g.pr(b)
</t>
<t tx="ekr.20031218072017.3114">def printGlobals(message: str = None) -&gt; None:
    # Get the list of globals.
    globs = list(globals())
    globs.sort()
    # Print the list.
    if message:
        leader = "-" * 10
        g.pr(leader, ' ', message, ' ', leader)
    for name in globs:
        g.pr(name)
</t>
<t tx="ekr.20031218072017.3115">def printLeoModules(message: str = None) -&gt; None:
    # Create the list.
    mods = []
    for name in sys.modules:
        if name and name[0:3] == "leo":
            mods.append(name)
    # Print the list.
    if message:
        leader = "-" * 10
        g.pr(leader, ' ', message, ' ', leader)
    mods.sort()
    for m in mods:
        g.pr(m, newline=False)
    g.pr('')
</t>
<t tx="ekr.20031218072017.3116"></t>
<t tx="ekr.20031218072017.3117">def create_temp_file(textMode: bool = False) -&gt; tuple[Any, str]:
    """
    Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.
    """
    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd, theFileName = tempfile.mkstemp(text=textMode)
        mode = 'w' if textMode else 'wb'
        theFile = os.fdopen(fd, mode)
    except Exception:
        g.error('unexpected exception in g.create_temp_file')
        g.es_exception()
        theFile, theFileName = None, ''
    return theFile, theFileName
</t>
<t tx="ekr.20031218072017.3118">def ensure_extension(name: str, ext: str) -&gt; str:

    theFile, old_ext = g.os_path_splitext(name)
    if not name:
        return name  # don't add to an empty name.
    if old_ext in ('.db', '.leo', '.leojs'):
        return name
    if old_ext and old_ext == ext:
        return name
    return name + ext
</t>
<t tx="ekr.20031218072017.3119">def makeAllNonExistentDirectories(theDir: str) -&gt; Optional[str]:
    """
    A wrapper from os.makedirs.
    Attempt to make all non-existent directories.

    Return True if the directory exists or was created successfully.
    """
    # Return True if the directory already exists.
    theDir = g.os_path_normpath(theDir)
    ok = g.os_path_isdir(theDir) and g.os_path_exists(theDir)
    if ok:
        return theDir
    # #1450: Create the directory with os.makedirs.
    try:
        os.makedirs(theDir, mode=0o777, exist_ok=False)
        return theDir
    except Exception:
        return None
</t>
<t tx="ekr.20031218072017.3120">@ Stephen P. Schaefer 9/7/2002

The Unix readline() routine delivers "\r\n" line end strings verbatim,
while the windows versions force the string to use the Unix convention
of using only "\n". This routine causes the Unix readline to do the
same.
@c

def readlineForceUnixNewline(f: Any, fileName: Optional[str] = None) -&gt; str:
    try:
        s = f.readline()
    except UnicodeDecodeError:
        g.trace(f"UnicodeDecodeError: {fileName}", f, g.callers())
        s = ''
    if len(s) &gt;= 2 and s[-2] == "\r" and s[-1] == "\n":
        s = s[0:-2] + "\n"
    return s
</t>
<t tx="ekr.20031218072017.3121">class RedirectClass:
    """A class to redirect stdout and stderr to Leo's log pane."""
    &lt;&lt; RedirectClass methods &gt;&gt;

# Create two redirection objects, one for each stream.

redirectStdErrObj = RedirectClass()
redirectStdOutObj = RedirectClass()
&lt;&lt; define convenience methods for redirecting streams &gt;&gt;
</t>
<t tx="ekr.20031218072017.3122">@others
</t>
<t tx="ekr.20031218072017.3124">def sanitize_filename(s: str) -&gt; str:
    """
    Prepares string s to be a valid file name:

    - substitute '_' for whitespace and special path characters.
    - eliminate all other non-alphabetic characters.
    - convert double quotes to single quotes.
    - strip leading and trailing whitespace.
    - return at most 128 characters.
    """
    result = []
    for ch in s:
        if ch in string.ascii_letters:
            result.append(ch)
        elif ch == '\t':
            result.append(' ')
        elif ch == '"':
            result.append("'")
        elif ch in '\\/:|&lt;&gt;*:._':
            result.append('_')
    s = ''.join(result).strip()
    while len(s) &gt; 1:
        n = len(s)
        s = s.replace('__', '_')
        if len(s) == n:
            break
    return s[:128]
</t>
<t tx="ekr.20031218072017.3125">def shortFileName(fileName: str, n: int = None) -&gt; str:
    """Return the base name of a path."""
    if n is not None:
        g.trace('"n" keyword argument is no longer used')
    return g.os_path_basename(fileName) if fileName else ''

shortFilename = shortFileName
</t>
<t tx="ekr.20031218072017.3126">def funcToMethod(f: Any, theClass: Any, name: str = None) -&gt; None:
    """
    From the Python Cookbook...

    The following method allows you to add a function as a method of
    any class. That is, it converts the function to a method of the
    class. The method just added is available instantly to all
    existing instances of the class, and to all instances created in
    the future.

    The function's first argument should be self.

    The newly created method has the same name as the function unless
    the optional name argument is supplied, in which case that name is
    used as the method name.
    """
    setattr(theClass, name or f.__name__, f)
</t>
<t tx="ekr.20031218072017.3127"># Very useful for tracing.

def get_line(s: str, i: int) -&gt; str:
    nl = ""
    if g.is_nl(s, i):
        i = g.skip_nl(s, i)
        nl = "[nl]"
    j = g.find_line_start(s, i)
    k = g.skip_to_end_of_line(s, i)
    return nl + s[j:k]

# Important: getLine is a completely different function.
# getLine = get_line

def get_line_after(s: str, i: int) -&gt; str:
    nl = ""
    if g.is_nl(s, i):
        i = g.skip_nl(s, i)
        nl = "[nl]"
    k = g.skip_to_end_of_line(s, i)
    return nl + s[i:k]

getLineAfter = get_line_after
</t>
<t tx="ekr.20031218072017.3128">def pause(s: str) -&gt; None:
    g.pr(s)
    i = 0
    while i &lt; 1000 * 1000:
        i += 1
</t>
<t tx="ekr.20031218072017.3133"></t>
<t tx="ekr.20031218072017.3134">def clearStats() -&gt; None:

    g.app.statsDict = {}
</t>
<t tx="ekr.20031218072017.3135">@command('show-stats')
def printStats(event: Event = None, name: str = None) -&gt; None:
    """
    Print all gathered statistics.

    Here is the recommended code to gather stats for one method/function:

        if not g.app.statsLockout:
            g.app.statsLockout = True
            try:
                d = g.app.statsDict
                key = 'g.isUnicode:' + g.callers()
                d [key] = d.get(key, 0) + 1
            finally:
                g.app.statsLockout = False
    """
    if name:
        if not isinstance(name, str):
            name = repr(name)
    else:
        # Get caller name 2 levels back.
        name = g._callerName(n=2)
    # Print the stats, organized by number of calls.
    d = g.app.statsDict
    print('g.app.statsDict...')
    for key in reversed(sorted(d)):
        print(f"{key:7} {d.get(key)}")
</t>
<t tx="ekr.20031218072017.3136">def stat(name: str = None) -&gt; None:
    """Increments the statistic for name in g.app.statsDict
    The caller's name is used by default.
    """
    d = g.app.statsDict
    if name:
        if not isinstance(name, str):
            name = repr(name)
    else:
        name = g._callerName(n=2)  # Get caller name 2 levels back.
    d[name] = 1 + d.get(name, 0)
</t>
<t tx="ekr.20031218072017.3137">def getTime() -&gt; float:
    return time.time()

def esDiffTime(message: str, start: float) -&gt; float:
    delta = time.time() - start
    g.es('', f"{message} {delta:5.2f} sec.")
    return time.time()

def printDiffTime(message: str, start: float) -&gt; float:
    delta = time.time() - start
    g.pr(f"{message} {delta:5.2f} sec.")
    return time.time()

def timeSince(start: float) -&gt; str:
    return f"{time.time()-start:5.2f} sec."
</t>
<t tx="ekr.20031218072017.3139"></t>
<t tx="ekr.20031218072017.3144"># From the Python cookbook.

def makeDict(**keys: Any) -&gt; dict:
    """Returns a Python dictionary from using the optional keyword arguments."""
    return keys
</t>
<t tx="ekr.20031218072017.3150">def windows() -&gt; Optional[list]:
    return app and app.windowList
</t>
<t tx="ekr.20031218072017.3151"></t>
<t tx="ekr.20031218072017.3156"># It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s: str) -&gt; None:
    """Bump the error count in the tangle command."""
    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors += 1
    g.es('', s)
</t>
<t tx="ekr.20031218072017.3157"># A quick and dirty sscanf.  Understands only %s and %d.

def scanf(s: str, pat: str) -&gt; list[str]:
    count = pat.count("%s") + pat.count("%d")
    pat = pat.replace("%s", r"(\S+)")
    pat = pat.replace("%d", r"(\d+)")
    parts = re.split(pat, s)
    result: list[str] = []
    for part in parts:
        if part and len(result) &lt; count:
            result.append(part)
    return result
</t>
<t tx="ekr.20031218072017.3158">@ These scanners all call g.scanError() directly or indirectly, so they
will call g.es if they find an error. g.scanError() also bumps
c.tangleCommands.errors, which is harmless if we aren't tangling, and
useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="ekr.20031218072017.3159"># Scans past a block comment (an old_style C comment).

def skip_block_comment(s: str, i: int) -&gt; int:
    assert g.match(s, i, "/*")
    j = i
    i += 2
    n = len(s)
    k = s.find("*/", i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    return k + 2
</t>
<t tx="ekr.20031218072017.3160">@ This code is called only from the import logic, so we are allowed to
try some tricks. In particular, we assume all braces are matched in
if blocks.
@c

def skip_braces(s: str, i: int) -&gt; int:
    """
    Skips from the opening to the matching brace.

    If no matching is found i is set to len(s)
    """
    # start = g.get_line(s,i)
    assert g.match(s, i, '{')
    level = 0
    n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1
            i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0:
                return i
            i += 1
        elif c == '\'' or c == '"':
            i = g.skip_string(s, i)
        elif g.match(s, i, '//'):
            i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, '/*'):
            i = g.skip_block_comment(s, i)
        # 7/29/02: be more careful handling conditional code.
        elif (
            g.match_word(s, i, "#if") or
            g.match_word(s, i, "#ifdef") or
            g.match_word(s, i, "#ifndef")
        ):
            i, delta = g.skip_pp_if(s, i)
            level += delta
        else:
            i += 1
    return i
</t>
<t tx="ekr.20031218072017.3162">def skip_parens(s: str, i: int) -&gt; int:
    """
    Skips from the opening ( to the matching ).

    If no matching is found i is set to len(s).
    """
    level = 0
    n = len(s)
    assert g.match(s, i, '('), repr(s[i])
    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1
            i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:
                return i
            i += 1
        elif c == '\'' or c == '"':
            i = g.skip_string(s, i)
        elif g.match(s, i, "//"):
            i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, "/*"):
            i = g.skip_block_comment(s, i)
        else:
            i += 1
    return i
</t>
<t tx="ekr.20031218072017.3163">def skip_pascal_begin_end(s: str, i: int) -&gt; int:
    """
    Skips from begin to matching end.
    If found, i points to the end. Otherwise, i &gt;= len(s)
    The end keyword matches begin, case, class, record, and try.
    """
    assert g.match_c_word(s, i, "begin")
    level = 1
    i = g.skip_c_id(s, i)  # Skip the opening begin.
    while i &lt; len(s):
        ch = s[i]
        if ch == '{':
            i = g.skip_pascal_braces(s, i)
        elif ch == '"' or ch == '\'':
            i = g.skip_pascal_string(s, i)
        elif g.match(s, i, "//"):
            i = g.skip_line(s, i)
        elif g.match(s, i, "(*"):
            i = g.skip_pascal_block_comment(s, i)
        elif g.match_c_word(s, i, "end"):
            level -= 1
            if level == 0:
                return i
            i = g.skip_c_id(s, i)
        elif g.is_c_id(ch):
            j = i
            i = g.skip_c_id(s, i)
            name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else:
            i += 1
    return i
</t>
<t tx="ekr.20031218072017.3164">def skip_pascal_block_comment(s: str, i: int) -&gt; int:
    """Scan past a pascal comment delimited by (* and *)."""
    j = i
    assert g.match(s, i, "(*")
    i = s.find("*)", i)
    if i &gt; -1:
        return i + 2
    g.scanError("Run on comment" + s[j:i])
    return len(s)
</t>
<t tx="ekr.20031218072017.3165">def skip_pascal_string(s: str, i: int) -&gt; int:
    j = i
    delim = s[i]
    i += 1
    assert delim == '"' or delim == '\''
    while i &lt; len(s):
        if s[i] == delim:
            return i + 1
        i += 1
    g.scanError("Run on string: " + s[j:i])
    return i
</t>
<t tx="ekr.20031218072017.3166">def skip_heredoc_string(s: str, i: int) -&gt; int:
    """
    08-SEP-2002 DTHEIN.
    A heredoc string in PHP looks like:

      &lt;&lt;&lt;EOS
      This is my string.
      It is mine. I own it.
      No one else has it.
      EOS

    It begins with &lt;&lt;&lt; plus a token (naming same as PHP variable names).
    It ends with the token on a line by itself (must start in first position.
    """
    j = i
    assert g.match(s, i, "&lt;&lt;&lt;")
    m = re.match(r"\&lt;\&lt;\&lt;([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)", s[i:])
    if m is None:
        i += 3
        return i
    # 14-SEP-2002 DTHEIN: needed to add \n to find word, not just string
    delim = m.group(1) + '\n'
    i = g.skip_line(s, i)  # 14-SEP-2002 DTHEIN: look after \n, not before
    n = len(s)
    while i &lt; n and not g.match(s, i, delim):
        i = g.skip_line(s, i)  # 14-SEP-2002 DTHEIN: move past \n
    if i &gt;= n:
        g.scanError("Run on string: " + s[j:i])
    elif g.match(s, i, delim):
        i += len(delim)
    return i
</t>
<t tx="ekr.20031218072017.3167">def skip_pp_directive(s: str, i: int) -&gt; int:
    """Now handles continuation lines and block comments."""
    while i &lt; len(s):
        if g.is_nl(s, i):
            if g.escaped(s, i):
                i = g.skip_nl(s, i)
            else:
                break
        elif g.match(s, i, "//"):
            i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, "/*"):
            i = g.skip_block_comment(s, i)
        else:
            i += 1
    return i
</t>
<t tx="ekr.20031218072017.3168"># Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s: str, i: int) -&gt; tuple[int, int]:
    start_line = g.get_line(s, i)  # used for error messages.
    assert(
        g.match_word(s, i, "#if") or
        g.match_word(s, i, "#ifdef") or
        g.match_word(s, i, "#ifndef"))
    i = g.skip_line(s, i)
    i, delta1 = g.skip_pp_part(s, i)
    i = g.skip_ws(s, i)
    if g.match_word(s, i, "#else"):
        i = g.skip_line(s, i)
        i = g.skip_ws(s, i)
        i, delta2 = g.skip_pp_part(s, i)
        if delta1 != delta2:
            g.es("#if and #else parts have different braces:", start_line)
    i = g.skip_ws(s, i)
    if g.match_word(s, i, "#endif"):
        i = g.skip_line(s, i)
    else:
        g.es("no matching #endif:", start_line)
    return i, delta1
</t>
<t tx="ekr.20031218072017.3169"># Skip to an #else or #endif.  The caller has eaten the #if, #ifdef, #ifndef or #else

def skip_pp_part(s: str, i: int) -&gt; tuple[int, int]:

    delta = 0
    while i &lt; len(s):
        c = s[i]
        if (
            g.match_word(s, i, "#if") or
            g.match_word(s, i, "#ifdef") or
            g.match_word(s, i, "#ifndef")
        ):
            i, delta1 = g.skip_pp_if(s, i)
            delta += delta1
        elif g.match_word(s, i, "#else") or g.match_word(s, i, "#endif"):
            return i, delta
        elif c == '\'' or c == '"':
            i = g.skip_string(s, i)
        elif c == '{':
            delta += 1
            i += 1
        elif c == '}':
            delta -= 1
            i += 1
        elif g.match(s, i, "//"):
            i = g.skip_line(s, i)
        elif g.match(s, i, "/*"):
            i = g.skip_block_comment(s, i)
        else:
            i += 1
    return i, delta
</t>
<t tx="ekr.20031218072017.3170">def skip_python_string(s: str, i: int) -&gt; int:
    if g.match(s, i, "'''") or g.match(s, i, '"""'):
        delim = s[i] * 3
        i += 3
        k = s.find(delim, i)
        if k &gt; -1:
            return k + 3
        return len(s)
    return g.skip_string(s, i)
</t>
<t tx="ekr.20031218072017.3171"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s: str, i: int) -&gt; int:
    n = len(s)
    while i &lt; n:
        c = s[i]
        if c == ';':
            return i
        if c == '\'' or c == '"':
            i = g.skip_string(s, i)
        elif g.match(s, i, "//"):
            i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, "/*"):
            i = g.skip_block_comment(s, i)
        else:
            i += 1
    return i
</t>
<t tx="ekr.20031218072017.3172">def skip_typedef(s: str, i: int) -&gt; int:
    n = len(s)
    while i &lt; n and g.is_c_id(s[i]):
        i = g.skip_c_id(s, i)
        i = g.skip_ws_and_nl(s, i)
    if g.match(s, i, '{'):
        i = g.skip_braces(s, i)
        i = g.skip_to_semicolon(s, i)
    return i
</t>
<t tx="ekr.20031218072017.3173"></t>
<t tx="ekr.20031218072017.3174"># Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s: str, i: int) -&gt; bool:
    count = 0
    while i - 1 &gt;= 0 and s[i - 1] == '\\':
        count += 1
        i -= 1
    return (count % 2) == 1
</t>
<t tx="ekr.20031218072017.3175">def find_line_start(s: str, i: int) -&gt; int:
    """Return the index in s of the start of the line containing s[i]."""
    if i &lt; 0:
        return 0  # New in Leo 4.4.5: add this defensive code.
    # bug fix: 11/2/02: change i to i+1 in rfind
    i = s.rfind('\n', 0, i + 1)  # Finds the highest index in the range.
    return 0 if i == -1 else i + 1
</t>
<t tx="ekr.20031218072017.3176">def find_on_line(s: str, i: int, pattern: str) -&gt; int:
    j = s.find('\n', i)
    if j == -1:
        j = len(s)
    k = s.find(pattern, i, j)
    return k
</t>
<t tx="ekr.20031218072017.3177">def is_c_id(ch: str) -&gt; bool:
    return g.isWordChar(ch)
</t>
<t tx="ekr.20031218072017.3178">def is_nl(s: str, i: int) -&gt; bool:
    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')
</t>
<t tx="ekr.20031218072017.3179">def is_special(s: str, directive: str) -&gt; tuple[bool, int]:
    """Return True if the body text contains the @ directive."""
    assert(directive and directive[0] == '@')
    # Most directives must start the line.
    lws = directive in ("@others", "@all")
    pattern_s = r'^\s*(%s\b)' if lws else r'^(%s\b)'
    pattern = re.compile(pattern_s % directive, re.MULTILINE)
    m = re.search(pattern, s)
    if m:
        return True, m.start(1)
    return False, -1
</t>
<t tx="ekr.20031218072017.3180">def is_ws(ch: str) -&gt; bool:
    return ch == '\t' or ch == ' '

def is_ws_or_nl(s: str, i: int) -&gt; bool:
    return g.is_nl(s, i) or (i &lt; len(s) and g.is_ws(s[i]))
</t>
<t tx="ekr.20031218072017.3181"># Warning: this code makes no assumptions about what follows pattern.

def match(s: str, i: int, pattern: str) -&gt; bool:
    return bool(s and pattern and s.find(pattern, i, i + len(pattern)) == i)
</t>
<t tx="ekr.20031218072017.3182">def match_c_word(s: str, i: int, name: str) -&gt; bool:
    n = len(name)
    return bool(
        name and
        name == s[i : i + n] and
        (i + n == len(s) or not g.is_c_id(s[i + n]))
    )
</t>
<t tx="ekr.20031218072017.3183">def match_ignoring_case(s1: str, s2: str) -&gt; bool:
    return bool(s1 and s2 and s1.lower() == s2.lower())
</t>
<t tx="ekr.20031218072017.3184">def match_word(s: str, i: int, pattern: str) -&gt; bool:

    # Using a regex is surprisingly tricky.
    if pattern is None:
        return False
    if i &gt; 0 and g.isWordChar(s[i - 1]):  # Bug fix: 2017/06/01.
        return False
    j = len(pattern)
    if j == 0:
        return False
    if s.find(pattern, i, i + j) != i:
        return False
    if i + j &gt;= len(s):
        return True
    ch = s[i + j]
    return not g.isWordChar(ch)

def match_words(s: str, i: int, patterns: Sequence[str]) -&gt; bool:
    return any(g.match_word(s, i, pattern) for pattern in patterns)
</t>
<t tx="ekr.20031218072017.3185"># This routine differs from skip_ws_and_nl in that
# it does not advance over whitespace at the start
# of a non-empty or non-nl terminated line

def skip_blank_lines(s: str, i: int) -&gt; int:
    while i &lt; len(s):
        if g.is_nl(s, i):
            i = g.skip_nl(s, i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s, i)
            if g.is_nl(s, j):
                i = j
            else:
                break
        else:
            break
    return i
</t>
<t tx="ekr.20031218072017.3186">def skip_c_id(s: str, i: int) -&gt; int:
    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3187">@ These methods skip to the next newline, regardless of whether the
newline may be preceded by a backslash. Consequently, they should be
used only when we know that we are not in a preprocessor directive or
string.
@c

def skip_line(s: str, i: int) -&gt; int:
    if i &gt;= len(s):
        return len(s)
    if i &lt; 0:
        i = 0
    i = s.find('\n', i)
    if i == -1:
        return len(s)
    return i + 1

def skip_to_end_of_line(s: str, i: int) -&gt; int:
    if i &gt;= len(s):
        return len(s)
    if i &lt; 0:
        i = 0
    i = s.find('\n', i)
    if i == -1:
        return len(s)
    return i

def skip_to_start_of_line(s: str, i: int) -&gt; int:
    if i &gt;= len(s):
        return len(s)
    if i &lt;= 0:
        return 0
    # Don't find s[i], so it doesn't matter if s[i] is a newline.
    i = s.rfind('\n', 0, i)
    if i == -1:
        return 0
    return i + 1
</t>
<t tx="ekr.20031218072017.3188">def skip_long(s: str, i: int) -&gt; tuple[int, Optional[int]]:
    """
    Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """
    val = 0
    i = g.skip_ws(s, i)
    n = len(s)
    if i &gt;= n or (not s[i].isdigit() and s[i] not in '+-'):
        return i, None
    j = i
    if s[i] in '+-':  # Allow sign before the first digit
        i += 1
    while i &lt; n and s[i].isdigit():
        i += 1
    try:  # There may be no digits.
        val = int(s[j:i])
        return i, val
    except Exception:
        return i, None
</t>
<t tx="ekr.20031218072017.3190"># We need this function because different systems have different end-of-line conventions.

def skip_nl(s: str, i: int) -&gt; int:
    """Skips a single "logical" end-of-line character."""
    if g.match(s, i, "\r\n"):
        return i + 2
    if g.match(s, i, '\n') or g.match(s, i, '\r'):
        return i + 1
    return i
</t>
<t tx="ekr.20031218072017.3191">def skip_non_ws(s: str, i: int) -&gt; int:
    n = len(s)
    while i &lt; n and not g.is_ws(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3192"># Skips from the opening { to the matching }.

def skip_pascal_braces(s: str, i: int) -&gt; int:
    # No constructs are recognized inside Pascal block comments!
    if i == -1:
        return len(s)
    return s.find('}', i)
</t>
<t tx="ekr.20031218072017.3193">def skip_to_char(s: str, i: int, ch: str) -&gt; tuple[int, str]:
    j = s.find(ch, i)
    if j == -1:
        return len(s), s[i:]
    return j, s[i:j]
</t>
<t tx="ekr.20031218072017.3194">def skip_ws(s: str, i: int) -&gt; int:
    n = len(s)
    while i &lt; n and g.is_ws(s[i]):
        i += 1
    return i

def skip_ws_and_nl(s: str, i: int) -&gt; int:
    n = len(s)
    while i &lt; n and (g.is_ws(s[i]) or g.is_nl(s, i)):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3195">def splitLines(s: str) -&gt; list[str]:
    """
    Split s into lines, preserving the number of lines and
    the endings of all lines, including the last line.
    """
    # The guard protects only against s == None.
    return s.splitlines(True) if s else []  # This is a Python string function!

splitlines = splitLines
</t>
<t tx="ekr.20031218072017.3197"></t>
<t tx="ekr.20031218072017.3198"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace(width: int, tab_width: int) -&gt; str:
    if width &lt;= 0:
        return ""
    if tab_width &gt; 1:
        tabs = int(width / tab_width)
        blanks = int(width % tab_width)
        return ('\t' * tabs) + (' ' * blanks)
    # Negative tab width always gets converted to blanks.
    return ' ' * width
</t>
<t tx="ekr.20031218072017.3199"># Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth(s: str, tab_width: int) -&gt; int:
    w = 0
    for ch in s:
        if ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        elif ch == '\n':  # Bug fix: 2012/06/05.
            break
        else:
            w += 1
    return w
</t>
<t tx="ekr.20031218072017.3200">def get_leading_ws(s: str) -&gt; str:
    """Returns the leading whitespace of 's'."""
    i = 0
    n = len(s)
    while i &lt; n and s[i] in (' ', '\t'):
        i += 1
    return s[0:i]
</t>
<t tx="ekr.20031218072017.3201"># Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace(line: str, tab_width: int) -&gt; str:
    i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
    s = g.computeLeadingWhitespace(width, tab_width) + line[i:]
    return s
</t>
<t tx="ekr.20031218072017.3202"># Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace(s: str, first_ws: int, tab_width: int) -&gt; str:
    j = 0
    ws = 0
    first_ws = abs(first_ws)
    for ch in s:
        if ws &gt;= first_ws:
            break
        elif ch == ' ':
            j += 1
            ws += 1
        elif ch == '\t':
            j += 1
            ws += (abs(tab_width) - (ws % abs(tab_width)))
        else:
            break
    if j &gt; 0:
        s = s[j:]
    return s
</t>
<t tx="ekr.20031218072017.3203"># Warning: string.rstrip also removes newlines!

def removeTrailingWs(s: str) -&gt; str:
    j = len(s) - 1
    while j &gt;= 0 and (s[j] == ' ' or s[j] == '\t'):
        j -= 1
    return s[: j + 1]
</t>
<t tx="ekr.20031218072017.3204"># Skips leading up to width leading whitespace.

def skip_leading_ws(s: str, i: int, ws: int, tab_width: int) -&gt; int:
    count = 0
    while count &lt; ws and i &lt; len(s):
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else:
            break
    return i
</t>
<t tx="ekr.20031218072017.3205">def skip_leading_ws_with_indent(s: str, i: int, tab_width: int) -&gt; tuple[int, int]:
    """Skips leading whitespace and returns (i, indent),

    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""
    count = 0
    n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else:
            break
    return i, count
</t>
<t tx="ekr.20031218072017.822">def createTopologyList(c: Cmdr, root: Position = None, useHeadlines: bool = False) -&gt; list:
    """Creates a list describing a node and all its descendents"""
    if not root:
        root = c.rootPosition()
    v = root
    if useHeadlines:
        aList = [(v.numberOfChildren(), v.headString()),]  # type: ignore
    else:
        aList = [v.numberOfChildren()]  # type: ignore
    child = v.firstChild()
    while child:
        aList.append(g.createTopologyList(c, child, useHeadlines))  # type: ignore
        child = child.next()
    return aList
</t>
<t tx="ekr.20031219074948.1">@nobeautify

tracing_tags: dict[int, str] = {}  # Keys are id's, values are tags.
tracing_vars: dict[int, list] = {}  # Keys are id's, values are names of ivars.
# Keys are signatures: '%s.%s:%s' % (tag, attr, callers). Values not important.
tracing_signatures: dict[str, Any] = {}

class NullObject:
    """An object that does nothing, and does it very well."""
    def __init__(self, ivars: list[str]=None, *args: Any, **kwargs: Any) -&gt; None:
        if isinstance(ivars, str):
            ivars = [ivars]
        tracing_vars [id(self)] = ivars or []
    def __call__(self, *args: Any, **keys: Any) -&gt; "NullObject":
        return self
    def __repr__(self) -&gt; str:
        return "NullObject"
    def __str__(self) -&gt; str:
        return "NullObject"
    # Attribute access...
    def __delattr__(self, attr: str) -&gt; None:
        return None
    def __getattr__(self, attr: str) -&gt; Any:
        if attr in tracing_vars.get(id(self), []):
            return getattr(self, attr, None)
        return self # Required.
    def __setattr__(self, attr: str, val: Any) -&gt; None:
        if attr in tracing_vars.get(id(self), []):
            object.__setattr__(self, attr, val)
    # Container methods..
    def __bool__(self) -&gt; bool:
        return False
    def __contains__(self, item: Any) -&gt; bool:
        return False
    def __getitem__(self, key: str) -&gt; None:
        raise KeyError
    def __setitem__(self, key: str, val: Any) -&gt; None:
        pass
    def __iter__(self) -&gt; "NullObject":
        return self
    def __len__(self) -&gt; int:
        return 0
    # Iteration methods:
    def __next__(self) -&gt; None:
        raise StopIteration


class TracingNullObject:
    """Tracing NullObject."""
    def __init__(self, tag: str, ivars: list[Any]=None, *args: Any, **kwargs: Any) -&gt; None:
        tracing_tags [id(self)] = tag
        if isinstance(ivars, str):
            ivars = [ivars]
        tracing_vars [id(self)] = ivars or []
    def __call__(self, *args: Any, **kwargs: Any) -&gt; "TracingNullObject":
        return self
    def __repr__(self) -&gt; str:
        return f'TracingNullObject: {tracing_tags.get(id(self), "&lt;NO TAG&gt;")}'
    def __str__(self) -&gt; str:
        return f'TracingNullObject: {tracing_tags.get(id(self), "&lt;NO TAG&gt;")}'
    #
    # Attribute access...
    def __delattr__(self, attr: str) -&gt; None:
        return None
    def __getattr__(self, attr: str) -&gt; "TracingNullObject":
        null_object_print_attr(id(self), attr)
        if attr in tracing_vars.get(id(self), []):
            return getattr(self, attr, None)
        return self # Required.
    def __setattr__(self, attr: str, val: Any) -&gt; None:
        g.null_object_print(id(self), '__setattr__', attr, val)
        if attr in tracing_vars.get(id(self), []):
            object.__setattr__(self, attr, val)
    #
    # All other methods...
    def __bool__(self) -&gt; bool:
        if 0: # To do: print only once.
            suppress = ('getShortcut','on_idle', 'setItemText')
            callers = g.callers(2)
            if not callers.endswith(suppress):
                g.null_object_print(id(self), '__bool__')
        return False
    def __contains__(self, item: Any) -&gt; bool:
        g.null_object_print(id(self), '__contains__')
        return False
    def __getitem__(self, key: str) -&gt; None:
        g.null_object_print(id(self), '__getitem__')
        # pylint doesn't like trailing return None.
    def __iter__(self) -&gt; "TracingNullObject":
        g.null_object_print(id(self), '__iter__')
        return self
    def __len__(self) -&gt; int:
        # g.null_object_print(id(self), '__len__')
        return 0
    def __next__(self) -&gt; None:
        g.null_object_print(id(self), '__next__')
        raise StopIteration
    def __setitem__(self, key: str, val: Any) -&gt; None:
        g.null_object_print(id(self), '__setitem__')
        # pylint doesn't like trailing return None.
</t>
<t tx="ekr.20040321065415">@others
</t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040705195048">def skip_id(s: str, i: int, chars: str = None) -&gt; int:
    chars = g.toUnicode(chars) if chars else ''
    n = len(s)
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
</t>
<t tx="ekr.20040712084911.1">def scanForAtLanguage(c: Cmdr, p: Position) -&gt; str:
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.
    if c and p:
        for p in p.self_and_parents(copy=False):
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language, delim1, delim2, delim3 = g.set_language(z, 0)
                return language
    return c.target_language
</t>
<t tx="ekr.20040715155607">def scanForAtIgnore(c: Cmdr, p: Position) -&gt; bool:
    """Scan position p and its ancestors looking for @ignore directives."""
    if g.unitTesting:
        return False  # For unit tests.
    for p in p.self_and_parents(copy=False):
        d = g.get_directives_dict(p)
        if 'ignore' in d:
            return True
    return False
</t>
<t tx="ekr.20040723093558">@ The caller should call g.stripBlankLines before calling this routine
if desired.

This routine does _not_ simply call rstrip(): that would delete all
trailing whitespace-only lines, and in some cases that would change
the meaning of program or data.
@c

def regularizeTrailingNewlines(s: str, kind: str) -&gt; None:
    """Kind is 'asis', 'zero' or 'one'."""
    pass
</t>
<t tx="ekr.20040723093558.1">def stripBlankLines(s: str) -&gt; str:
    lines = g.splitLines(s)
    for i, line in enumerate(lines):
        j = g.skip_ws(line, 0)
        if j &gt;= len(line):
            lines[i] = ''
        elif line[j] == '\n':
            lines[i] = '\n'
    return ''.join(lines)
</t>
<t tx="ekr.20040731204831">def getLastTracebackFileAndLineNumber() -&gt; tuple[str, int]:
    typ, val, tb = sys.exc_info()
    if typ == SyntaxError:
        # IndentationError is a subclass of SyntaxError.
        return val.filename, val.lineno
    #
    # Data is a list of tuples, one per stack entry.
    # Tupls have the form (filename,lineNumber,functionName,text).
    data = traceback.extract_tb(tb)
    if data:
        item = data[-1]  # Get the item at the top of the stack.
        filename, n, functionName, text = item
        return filename, n
    # Should never happen.
    return '&lt;string&gt;', 0
</t>
<t tx="ekr.20040917061619">def cantImport(moduleName: str, pluginName: str = None, verbose: bool = True) -&gt; None:
    """Print a "Can't Import" message and return None."""
    s = f"Can not import {moduleName}"
    if pluginName:
        s = s + f" from {pluginName}"
    if not g.app or not g.app.gui:
        print(s)
    elif g.unitTesting:
        return
    else:
        g.warning('', s)
</t>
<t tx="ekr.20041012082437">def __init__(self) -&gt; None:
    self.old = None
    self.encoding = 'utf-8'  # 2019/03/29 For pdb.
</t>
<t tx="ekr.20041012082437.1">def isRedirected(self) -&gt; bool:
    return self.old is not None
</t>
<t tx="ekr.20041012082437.2"># For LeoN: just for compatibility.

def flush(self, *args: Any) -&gt; None:
    return
</t>
<t tx="ekr.20041012082437.3">def redirect(self, stdout: bool = True) -&gt; None:
    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return
    if not self.old:
        if stdout:
            self.old, sys.stdout = sys.stdout, self  # type:ignore
        else:
            self.old, sys.stderr = sys.stderr, self  # type:ignore
</t>
<t tx="ekr.20041012082437.4">def undirect(self, stdout: bool = True) -&gt; None:
    if self.old:
        if stdout:
            sys.stdout, self.old = self.old, None
        else:
            sys.stderr, self.old = self.old, None
</t>
<t tx="ekr.20041012082437.5">def write(self, s: str) -&gt; None:

    if self.old:
        if app.log:
            app.log.put(s, from_redirect=True)
        else:
            self.old.write(s + '\n')
    else:
        # Can happen when g.batchMode is True.
        g.pr(s)
</t>
<t tx="ekr.20041012090942"># Redirect streams to the current log window.

def redirectStderr() -&gt; None:
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout() -&gt; None:
    global redirectStdOutObj
    redirectStdOutObj.redirect()
</t>
<t tx="ekr.20041012090942.1"># Restore standard streams.

def restoreStderr() -&gt; None:
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)

def restoreStdout() -&gt; None:
    global redirectStdOutObj
    redirectStdOutObj.undirect()
</t>
<t tx="ekr.20041012090942.2">def stdErrIsRedirected() -&gt; bool:
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()

def stdOutIsRedirected() -&gt; bool:
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
</t>
<t tx="ekr.20041012090942.3"># Send output to original stdout.

def rawPrint(s: str) -&gt; None:
    global redirectStdOutObj
    redirectStdOutObj.rawPrint(s)
</t>
<t tx="ekr.20041012091252">def rawPrint(self, s: str) -&gt; None:
    if self.old:
        self.old.write(s + '\n')
    else:
        g.pr(s)
</t>
<t tx="ekr.20041105091148">def pdb(message: str = '') -&gt; None:
    """Fall into pdb."""
    if app and not app.useIpython:
        try:
            from leo.core.leoQt import QtCore
            QtCore.pyqtRemoveInputHook()
        except Exception:
            pass
    if message:
        print(message)
    # pylint: disable=forgotten-debug-statement
    breakpoint()  # New in Python 3.7.
</t>
<t tx="ekr.20041122153823">def printStack() -&gt; None:
    traceback.print_stack()
</t>
<t tx="ekr.20041123094807">def scanForAtSettings(p: Position) -&gt; bool:
    """Scan position p and its ancestors looking for @settings nodes."""
    for p in p.self_and_parents(copy=False):
        h = p.h
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True
    return False
</t>
<t tx="ekr.20041219095213"></t>
<t tx="ekr.20050208093800">def toEncodedString(s: str, encoding: str = 'utf-8', reportErrors: bool = False) -&gt; bytes:
    """Convert unicode string to an encoded string."""
    if not isinstance(s, str):
        return s
    if not encoding:
        encoding = 'utf-8'
    # These are the only significant calls to s.encode in Leo.
    try:
        s = s.encode(encoding, "strict")  # type:ignore
    except UnicodeError:
        s = s.encode(encoding, "replace")  # type:ignore
        if reportErrors:
            g.error(f"Error converting {s} from unicode to {encoding} encoding")
    # Tracing these calls directly yields thousands of calls.
    return s  # type:ignore
</t>
<t tx="ekr.20050208093800.1">unicode_warnings: dict[str, bool] = {}  # Keys are g.callers.

def toUnicode(s: Any, encoding: str = None, reportErrors: bool = False) -&gt; str:
    """Convert bytes to unicode if necessary."""
    if isinstance(s, str):
        return s
    tag = 'g.toUnicode'
    if not isinstance(s, bytes):
        if reportErrors and not isinstance(s, (NullObject, TracingNullObject)):
            callers = g.callers()
            if callers not in unicode_warnings:
                unicode_warnings[callers] = True
                g.error(f"{tag}: unexpected argument of type {s.__class__.__name__}")
                g.trace(callers)
        return ''
    if not encoding:
        encoding = 'utf-8'
    try:
        s = s.decode(encoding, 'strict')
    except(UnicodeDecodeError, UnicodeError):  # noqa
        # https://wiki.python.org/moin/UnicodeDecodeError
        s = s.decode(encoding, 'replace')
        if reportErrors:
            g.error(f"{tag}: unicode error. encoding: {encoding!r}, s:\n{s!r}")
            g.trace(g.callers())
    except Exception:
        g.es_exception()
        g.error(f"{tag}: unexpected error! encoding: {encoding!r}, s:\n{s!r}")
        g.trace(g.callers())
    return s
</t>
<t tx="ekr.20050208101229">from __future__ import annotations
import binascii
from collections.abc import Callable
import codecs
import copy
import fnmatch
from functools import reduce
import gc
import gettext
import glob
import importlib
import inspect
import io
import operator
import os
from pathlib import Path
# import pdb  # Do NOT import pdb here! g.pdb is a *function*
import pprint
import re
import shlex
import string
import sys
import subprocess
import tempfile
import textwrap
import time
import traceback
import types
from typing import Any, Generator, Iterable, Optional, Sequence, Union, TYPE_CHECKING
import unittest
import urllib
import urllib.parse as urlparse

# Leo never imports any other Leo module.

# Third-party tools.
import webbrowser
try:
    import tkinter as Tk
except Exception:
    Tk = None
#
# Abbreviations...
StringIO = io.StringIO
</t>
<t tx="ekr.20050314140957">def convertPythonIndexToRowCol(s: str, i: int) -&gt; tuple[int, int]:
    """Convert index i into string s into zero-based row/col indices."""
    if not s or i &lt;= 0:
        return 0, 0
    i = min(i, len(s))
    # works regardless of what s[i] is
    row = s.count('\n', 0, i)  # Don't include i
    if row == 0:
        return row, i
    prevNL = s.rfind('\n', 0, i)  # Don't include i
    return row, i - prevNL - 1
</t>
<t tx="ekr.20050315071727">def convertRowColToPythonIndex(s: str, row: int, col: int, lines: list[str] = None) -&gt; int:
    """Convert zero-based row/col indices into a python index into string s."""
    if row &lt; 0:
        return 0
    if lines is None:
        lines = g.splitLines(s)
    if row &gt;= len(lines):
        return len(s)
    col = min(col, len(lines[row]))
    # A big bottleneck
    prev = 0
    for line in lines[:row]:
        prev += len(line)
    return prev + col
</t>
<t tx="ekr.20050503112513.7">def executeFile(filename: str, options: str = '') -&gt; None:
    if not os.access(filename, os.R_OK):
        return
    fdir, fname = g.os_path_split(filename)
    # New in Leo 4.10: alway use subprocess.

    def subprocess_wrapper(cmdlst: str) -&gt; tuple:

        p = subprocess.Popen(cmdlst, cwd=fdir,
            universal_newlines=True,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdo, stde = p.communicate()
        return p.wait(), stdo, stde

    rc, so, se = subprocess_wrapper(f"{sys.executable} {fname} {options}")
    if rc:
        g.pr('return code', rc)
    g.pr(so, se)
</t>
<t tx="ekr.20050707064040"># see: http://www.diveintopython.org/xml_processing/unicode.html

def es_print(*args: Any, **keys: Any) -&gt; None:
    """
    Print all non-keyword args, and put them to the log pane.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    g.pr(*args, **keys)
    if g.app and not g.unitTesting:
        g.es(*args, **keys)
</t>
<t tx="ekr.20050707065530">def es_trace(*args: Any, **keys: Any) -&gt; None:
    if args:
        try:
            s = args[0]
            g.trace(g.toEncodedString(s, 'ascii'))
        except Exception:
            pass
    g.es(*args, **keys)
</t>
<t tx="ekr.20050819064157">def objToString(obj: Any, *, indent: int = 0, tag: str = None, width: int = 120) -&gt; str:
    """Pretty print any Python object to a string."""
    if isinstance(obj, (list, tuple)):
        # Return the enumerated lines of the list.
        result_list = ['[\n' if isinstance(obj, list) else '(\n']
        for i, z in enumerate(obj):
            result_list.append(f"  {i:4}: {z!r}\n")
        result_list.append(']\n' if isinstance(obj, list) else ')\n')
        result = ''.join(result_list)
    elif not isinstance(obj, str):
        result = pprint.pformat(obj, indent=indent, width=width)
        # Put opening/closing delims on separate lines.
        if result.count('\n') &gt; 0 and result[0] in '([{' and result[-1] in ')]}':
            result = f"{result[0]}\n{result[1:-2]}\n{result[-1]}"
    elif '\n' not in obj:
        result = repr(obj)
    else:
        # Return the enumerated lines of the string.
        lines = ''.join([
            f"  {i:4}: {z!r}\n" for i, z in enumerate(g.splitLines(obj))
        ])
        result = f"[\n{lines}]\n"
    return f"{tag.strip()}: {result}" if tag and tag.strip() else result

toString = objToString
dictToString = objToString
listToString = objToString
tupleToString = objToString
</t>
<t tx="ekr.20050920084036.4">def longestCommonPrefix(s1: str, s2: str) -&gt; str:
    """Find the longest prefix common to strings s1 and s2."""
    prefix = ''
    for ch in s1:
        if s2.startswith(prefix + ch):
            prefix = prefix + ch
        else:
            return prefix
    return prefix

def itemsMatchingPrefixInList(s: str, aList: list[str], matchEmptyPrefix: bool = False) -&gt; tuple[list, str]:
    """This method returns a sorted list items of aList whose prefix is s.

    It also returns the longest common prefix of all the matches.
    """
    if s:
        pmatches = [a for a in aList if a.startswith(s)]
    elif matchEmptyPrefix:
        pmatches = aList[:]
    else:
        pmatches = []
    if pmatches:
        pmatches.sort()
        common_prefix = reduce(g.longestCommonPrefix, pmatches)
    else:
        common_prefix = ''
    return pmatches, common_prefix
</t>
<t tx="ekr.20051023083258"></t>
<t tx="ekr.20060127162818">def enable_gc_debug() -&gt; None:

    gc.set_debug(
        gc.DEBUG_STATS |  # prints statistics.
        gc.DEBUG_LEAK |  # Same as all below.
        gc.DEBUG_COLLECTABLE |
        gc.DEBUG_UNCOLLECTABLE |
        # gc.DEBUG_INSTANCES |
        # gc.DEBUG_OBJECTS |
        gc.DEBUG_SAVEALL)
</t>
<t tx="ekr.20060127164729.1">lastObjectCount = 0

def printGcObjects() -&gt; int:
    """Print a summary of GC statistics."""
    global lastObjectCount
    n = len(gc.garbage)
    n2 = len(gc.get_objects())
    delta = n2 - lastObjectCount
    print('-' * 30)
    print(f"garbage: {n}")
    print(f"{delta:6d} = {n2:7d} totals")
    # print number of each type of object.
    d: dict[str, int] = {}
    count = 0
    for obj in gc.get_objects():
        key = str(type(obj))
        n = d.get(key, 0)
        d[key] = n + 1
        count += 1
    print(f"{count:7} objects...")
    # Invert the dict.
    d2: dict[Any, Any] = {v: k for k, v in d.items()}
    for key in reversed(sorted(d2.keys())):
        val = d2.get(key)
        print(f"{key:7} {val}")
    lastObjectCount = count
    return delta
</t>
<t tx="ekr.20060205043324.1">def printGcSummary() -&gt; None:

    g.enable_gc_debug()
    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = f"printGCSummary: garbage: {n}, objects: {n2}"
        print(s)
    except Exception:
        traceback.print_exc()
</t>
<t tx="ekr.20060221083356">def prettyPrintType(obj: Any) -&gt; str:
    if isinstance(obj, str):
        return 'string'
    t: Any = type(obj)
    if t in (types.BuiltinFunctionType, types.FunctionType):
        return 'function'
    if t == types.ModuleType:  # noqa
        return 'module'
    if t in [types.MethodType, types.BuiltinMethodType]:
        return 'method'
    # Fall back to a hack.
    t = str(type(obj))  # type:ignore
    if t.startswith("&lt;type '"):
        t = t[7:]
    if t.endswith("'&gt;"):
        t = t[:-2]
    return t
</t>
<t tx="ekr.20060328150113">def setGlobalOpenDir(fileName: str) -&gt; None:
    if fileName:
        g.app.globalOpenDir = g.os_path_dirname(fileName)
        # g.es('current directory:',g.app.globalOpenDir)
</t>
<t tx="ekr.20060410112600">def stripBrackets(s: str) -&gt; str:
    """Strip leading and trailing angle brackets."""
    if s.startswith('&lt;'):
        s = s[1:]
    if s.endswith('&gt;'):
        s = s[:-1]
    return s
</t>
<t tx="ekr.20060624085200">def handleScriptException(
    c: Cmdr,
    p: Position,
    script: str = None,  # No longer used.
    script1: str = None,  # No longer used.
) -&gt; None:
    g.warning("exception executing script")
    g.es_exception()

    # Careful: this test is no longer guaranteed.
    if p.v.context != c:
        return
    fileName, n = g.getLastTracebackFileAndLineNumber()
    try:
        c.goToScriptLineNumber(n, p)
        &lt;&lt; dump the lines near the error &gt;&gt;
    except Exception:
        g.es_print('Unexpected exception in g.handleScriptException')
        g.es_exception()
</t>
<t tx="ekr.20060810095921">def translateString(s: str) -&gt; str:
    """Return the translated text of s."""
    # pylint: disable=undefined-loop-variable
    # looks like a pylint bug
    upper = app and getattr(app, 'translateToUpperCase', None)
    if not isinstance(s, str):
        s = str(s, 'utf-8')
    if upper:
        s = s.upper()
    else:
        s = gettext.gettext(s)
    return s

tr = translateString
</t>
<t tx="ekr.20060913090832.1">init_zodb_import_failed = False
init_zodb_failed: dict[str, bool] = {}  # Keys are paths, values are True.
init_zodb_db: dict[str, Any] = {}  # Keys are paths, values are ZODB.DB instances.

def init_zodb(pathToZodbStorage: str, verbose: bool = True) -&gt; Any:
    """
    Return an ZODB.DB instance from the given path.
    return None on any error.
    """
    global init_zodb_db, init_zodb_failed, init_zodb_import_failed
    db = init_zodb_db.get(pathToZodbStorage)
    if db:
        return db
    if init_zodb_import_failed:
        return None
    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed:
        return None
    try:
        import ZODB  # type:ignore
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None
    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db[pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed[pathToZodbStorage] = True
        return None
</t>
<t tx="ekr.20060917120951">def es_dump(s: str, n: int = 30, title: str = None) -&gt; None:
    if title:
        g.es_print('', title)
    i = 0
    while i &lt; len(s):
        aList = ''.join([f"{ord(ch):2x} " for ch in s[i : i + n]])
        g.es_print('', aList)
        i += n
</t>
<t tx="ekr.20060921100435"># Simplified version by EKR: stringCompare not used.

def CheckVersion(
    s1: str,
    s2: str,
    condition: str = "&gt;=",
    stringCompare: bool = None,
    delimiter: str = '.',
    trace: bool = False,
) -&gt; bool:
    # CheckVersion is called early in the startup process.
    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)]
    n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)]
    n2 = len(vals2)
    n = max(n1, n2)
    if n1 &lt; n:
        vals1.extend([0 for _i in range(n - n1)])
    if n2 &lt; n:
        vals2.extend([0 for _i in range(n - n2)])
    for cond, val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('&lt;', vals1 &lt; vals2), ('&lt;=', vals1 &lt;= vals2),
        ('&gt;', vals1 &gt; vals2), ('&gt;=', vals1 &gt;= vals2),
    ):
        if condition == cond:
            result = val
            break
    else:
        raise EnvironmentError(
            "condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='.")
    return result
</t>
<t tx="ekr.20061006152327">def isWordChar(ch: str) -&gt; bool:
    """Return True if ch should be considered a letter."""
    return bool(ch and (ch.isalnum() or ch == '_'))

def isWordChar1(ch: str) -&gt; bool:
    return bool(ch and (ch.isalpha() or ch == '_'))
</t>
<t tx="ekr.20061015090538">def es_exception_type(c: Cmdr = None, color: str = "red") -&gt; None:
    # exctype is a Exception class object; value is the error message.
    exctype, value = sys.exc_info()[:2]
    g.es_print('', f"{exctype.__name__}, {value}", color=color)
</t>
<t tx="ekr.20061031102333.2">def getWord(s: str, i: int) -&gt; tuple[int, int]:
    """Return i,j such that s[i:j] is the word surrounding s[i]."""
    if i &gt;= len(s):
        i = len(s) - 1
    if i &lt; 0:
        i = 0
    # Scan backwards.
    while 0 &lt;= i &lt; len(s) and g.isWordChar(s[i]):
        i -= 1
    i += 1
    # Scan forwards.
    j = i
    while 0 &lt;= j &lt; len(s) and g.isWordChar(s[j]):
        j += 1
    return i, j

def getLine(s: str, i: int) -&gt; tuple[int, int]:
    """
    Return i,j such that s[i:j] is the line surrounding s[i].
    s[i] is a newline only if the line is empty.
    s[j] is a newline unless there is no trailing newline.
    """
    if i &gt; len(s):
        i = len(s) - 1
    if i &lt; 0:
        i = 0
    # A newline *ends* the line, so look to the left of a newline.
    j = s.rfind('\n', 0, i)
    if j == -1:
        j = 0
    else:
        j += 1
    k = s.find('\n', i)
    if k == -1:
        k = len(s)
    else:
        k = k + 1
    return j, k
</t>
<t tx="ekr.20061113221414">def find_matching_bracket(self, ch1: str, s: str, i: int) -&gt; Any:
    """Find the bracket matching s[i] for self.language."""
    self.forward = ch1 in self.open_brackets
    # Find the character matching the initial bracket.
    for n in range(len(self.brackets)):  # pylint: disable=consider-using-enumerate
        if ch1 == self.brackets[n]:
            target = self.matching_brackets[n]
            break
    else:
        return None
    f = self.scan if self.forward else self.scan_back
    return f(ch1, target, s, i)
</t>
<t tx="ekr.20070120123930">def CheckVersionToInt(s: str) -&gt; int:
    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit():
                aList.append(ch)
            else:
                break
        if aList:
            s = ''.join(aList)
            return int(s)
        return 0
</t>
<t tx="ekr.20070510074941">def printEntireTree(c: Cmdr, tag: str = '') -&gt; None:
    g.pr('printEntireTree', '=' * 50)
    g.pr('printEntireTree', tag, 'root', c.rootPosition())
    for p in c.all_positions():
        g.pr('..' * p.level(), p.v)
</t>
<t tx="ekr.20070524083513"></t>
<t tx="ekr.20070626132332">def es(*args: Any, **keys: Any) -&gt; None:
    """Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    if not app or app.killed:
        return
    if app.gui and app.gui.consoleOnly:
        return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return  # New in 4.3.
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    # Do not call g.es, g.es_print, g.pr or g.trace here!
        # sys.__stdout__.write('\n===== g.es: %r\n' % s)
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # This makes the output of unit tests match the output of scripts.
            g.pr(s, newline=newline)
    elif log and app.logInited:
        if newline:
            s += '\n'
        log.put(s, color=color, tabName=tabName, nodeLink=d['nodeLink'])
        # Count the number of *trailing* newlines.
        for ch in s:
            if ch == '\n':
                log.newlines += 1
            else:
                log.newlines = 0
    else:
        app.logWaiting.append((s, color, newline, d),)

log = es
</t>
<t tx="ekr.20071109165315">def stripPathCruft(path: str) -&gt; str:
    """Strip cruft from a path name."""
    if not path:
        return path  # Retain empty paths for warnings.
    if len(path) &gt; 2 and (
        (path[0] == '&lt;' and path[-1] == '&gt;') or
        (path[0] == '"' and path[-1] == '"') or
        (path[0] == "'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()
    # We want a *relative* path, not an absolute path.
    return path
</t>
<t tx="ekr.20071114113736">def makePathRelativeTo(fullPath: str, basePath: str) -&gt; str:
    if fullPath.startswith(basePath):
        s = fullPath[len(basePath) :]
        if s.startswith(os.path.sep):
            s = s[len(os.path.sep) :]
        return s
    return fullPath
</t>
<t tx="ekr.20080220111323">console_encoding = None

def translateArgs(args: Iterable[Any], d: dict[str, Any]) -&gt; str:
    """
    Return the concatenation of s and all args, with odd args translated.
    """
    global console_encoding
    if not console_encoding:
        e = sys.getdefaultencoding()
        console_encoding = e if isValidEncoding(e) else 'utf-8'
    result: list[str] = []
    n, spaces = 0, d.get('spaces')
    for arg in args:
        n += 1
        # First, convert to unicode.
        if isinstance(arg, str):
            arg = toUnicode(arg, console_encoding)
        # Now translate.
        if not isinstance(arg, str):
            arg = repr(arg)
        elif (n % 2) == 1:
            arg = translateString(arg)
        else:
            pass  # The arg is an untranslated string.
        if arg:
            if result and spaces:
                result.append(' ')
            result.append(arg)
    return ''.join(result)
</t>
<t tx="ekr.20080531075119.1">class Tracer:
    """A "debugger" that computes a call graph.

    To trace a function and its callers, put the following at the function's start:

    g.startTracer()
    """
    @others

def startTracer(limit: int = 0, trace: bool = False, verbose: bool = False) -&gt; Callable:
    t = g.Tracer(limit=limit, trace=trace, verbose=verbose)
    sys.settrace(t.tracer)
    return t
</t>
<t tx="ekr.20080531075119.2">def __init__(self, limit: int = 0, trace: bool = False, verbose: bool = False) -&gt; None:
    # Keys are function names.
    # Values are the number of times the function was called by the caller.
    self.callDict: dict[str, Any] = {}
    # Keys are function names.
    # Values are the total number of times the function was called.
    self.calledDict: dict[str, int] = {}
    self.count = 0
    self.inited = False
    self.limit = limit  # 0: no limit, otherwise, limit trace to n entries deep.
    self.stack: list[str] = []
    self.trace = trace
    self.verbose = verbose  # True: print returns as well as calls.
</t>
<t tx="ekr.20080531075119.3">def computeName(self, frame: Any) -&gt; str:
    if not frame:
        return ''
    code = frame.f_code
    result = []
    module = inspect.getmodule(code)
    if module:
        module_name = module.__name__
        if module_name == 'leo.core.leoGlobals':
            result.append('g')
        else:
            tag = 'leo.core.'
            if module_name.startswith(tag):
                module_name = module_name[len(tag) :]
            result.append(module_name)
    try:
        # This can fail during startup.
        self_obj = frame.f_locals.get('self')
        if self_obj:
            result.append(self_obj.__class__.__name__)
    except Exception:
        pass
    result.append(code.co_name)
    return '.'.join(result)
</t>
<t tx="ekr.20080531075119.4">def report(self) -&gt; None:
    if 0:
        g.pr('\nstack')
        for z in self.stack:
            g.pr(z)
    g.pr('\ncallDict...')
    for key in sorted(self.callDict):
        # Print the calling function.
        g.pr(f"{self.calledDict.get(key,0):d}", key)
        # Print the called functions.
        d = self.callDict.get(key)
        for key2 in sorted(d):  # type:ignore
            g.pr(f"{d.get(key2):8d}", key2)  # type:ignore
</t>
<t tx="ekr.20080531075119.5">def stop(self) -&gt; None:
    sys.settrace(None)
    self.report()
</t>
<t tx="ekr.20080531075119.6">def tracer(self, frame: Any, event: Any, arg: Any) -&gt; Optional[Callable]:
    """A function to be passed to sys.settrace."""
    n = len(self.stack)
    if event == 'return':
        n = max(0, n - 1)
    pad = '.' * n
    if event == 'call':
        if not self.inited:
            # Add an extra stack element for the routine containing the call to startTracer.
            self.inited = True
            name = self.computeName(frame.f_back)
            self.updateStats(name)
            self.stack.append(name)
        name = self.computeName(frame)
        if self.trace and (self.limit == 0 or len(self.stack) &lt; self.limit):
            g.trace(f"{pad}call", name)
        self.updateStats(name)
        self.stack.append(name)
        return self.tracer
    if event == 'return':
        if self.stack:
            name = self.stack.pop()
            if (
                self.trace and
                self.verbose and
                (self.limit == 0 or len(self.stack) &lt; self.limit)
            ):
                g.trace(f"{pad}ret ", name)
        else:
            g.trace('return underflow')
            self.stop()
            return None
        if self.stack:
            return self.tracer
        self.stop()
        return None
    return self.tracer
</t>
<t tx="ekr.20080531075119.7">def updateStats(self, name: str) -&gt; None:
    if not self.stack:
        return
    caller = self.stack[-1]
    # d is a dict representing the called functions.
    # Keys are called functions, values are counts.
    d: dict[str, int] = self.callDict.get(caller, {})
    d[name] = 1 + d.get(name, 0)
    self.callDict[caller] = d
    # Update the total counts.
    self.calledDict[name] = 1 + self.calledDict.get(name, 0)
</t>
<t tx="ekr.20080605064555.2">def os_path_realpath(path: str) -&gt; str:
    """Return the canonical path of the specified filename, eliminating any
    symbolic links encountered in the path (if they are supported by the
    operating system).
    """
    if not path:
        return ''
    path = os.path.realpath(path)
    path = g.os_path_normslashes(path)
    return path
</t>
<t tx="ekr.20080606074139.2">def chdir(path: str) -&gt; None:
    if not g.os_path_isdir(path):
        path = g.os_path_dirname(path)
    if g.os_path_isdir(path) and g.os_path_exists(path):
        os.chdir(path)
</t>
<t tx="ekr.20080710101653.1"># see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args: Any, **keys: Any) -&gt; None:
    """
    Print all non-keyword args. This is a wrapper for the print statement.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    # Compute the effective args.
    d = {'commas': False, 'newline': True, 'spaces': True}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    # Unit tests require sys.stdout.
    stdout = sys.stdout if sys.stdout and g.unitTesting else sys.__stdout__
    if not stdout:
        # #541.
        return
    if sys.platform.lower().startswith('win'):
        encoding = 'ascii'  # 2011/11/9.
    elif getattr(stdout, 'encoding', None):
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = stdout.encoding
    else:
        encoding = 'utf-8'
    s = translateArgs(args, d)  # Translates everything to unicode.
    s = g.toUnicode(s, encoding=encoding, reportErrors=False)
    if newline:
        s += '\n'
    # Python's print statement *can* handle unicode, but
    # sitecustomize.py must have sys.setdefaultencoding('utf-8')
    try:
        # #783: print-* commands fail under pythonw.
        stdout.write(s)
    except Exception:
        pass
</t>
<t tx="ekr.20080729142651.1">def getIvarsDict(obj: Any) -&gt; dict[str, Any]:
    """Return a dictionary of ivars:values for non-methods of obj."""
    d: dict[str, Any] = dict(
        [[key, getattr(obj, key)] for key in dir(obj)
            if not isinstance(getattr(obj, key), types.MethodType)])
    return d

def checkUnchangedIvars(
    obj: Any,
    d: dict[str, Any],
    exceptions: Sequence[str] = None,
) -&gt; bool:
    if not exceptions:
        exceptions = []
    ok = True
    for key in d:
        if key not in exceptions:
            if getattr(obj, key) != d.get(key):
                g.trace(
                    f"changed ivar: {key} "
                    f"old: {repr(d.get(key))} "
                    f"new: {repr(getattr(obj, key))}")
                ok = False
    return ok
</t>
<t tx="ekr.20080729142651.2">def os_path_getsize(path: str) -&gt; int:
    """Return the size of path."""
    return os.path.getsize(path) if path else 0
</t>
<t tx="ekr.20080821073134.2">def doKeywordArgs(keys: dict, d: dict = None) -&gt; dict:
    """
    Return a result dict that is a copy of the keys dict
    with missing items replaced by defaults in d dict.
    """
    if d is None:
        d = {}
    result = {}
    for key, default_val in d.items():
        isBool = default_val in (True, False)
        val = keys.get(key)
        if isBool and val in (True, 'True', 'true'):
            result[key] = True
        elif isBool and val in (False, 'False', 'false'):
            result[key] = False
        elif val is None:
            result[key] = default_val
        else:
            result[key] = val
    return result
</t>
<t tx="ekr.20080827175609.1">def get_directives_dict_list(p: Position) -&gt; list[dict]:
    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to
    the start of each directive"""
    result = []
    p1 = p.copy()
    for p in p1.self_and_parents(copy=False):
        # No copy necessary: g.get_directives_dict does not change p.
        result.append(g.get_directives_dict(p))
    return result
</t>
<t tx="ekr.20080827175609.32">def scanAtEncodingDirectives(aList: list) -&gt; Optional[str]:
    """Scan aList for @encoding directives."""
    for d in aList:
        encoding = d.get('encoding')
        if encoding and g.isValidEncoding(encoding):
            return encoding
        if encoding and not g.unitTesting:
            g.error("invalid @encoding:", encoding)
    return None
</t>
<t tx="ekr.20080827175609.33">def scanAtLineendingDirectives(aList: list) -&gt; Optional[str]:
    """Scan aList for @lineending directives."""
    for d in aList:
        e = d.get('lineending')
        if e in ("cr", "crlf", "lf", "nl", "platform"):
            lineending = g.getOutputNewline(name=e)
            return lineending
        # else:
            # g.error("invalid @lineending directive:",e)
    return None
</t>
<t tx="ekr.20080827175609.34">def scanAtPagewidthDirectives(aList: list, issue_error_flag: bool = False) -&gt; Optional[int]:
    """Scan aList for @pagewidth directives. Return the page width or None"""
    for d in aList:
        s = d.get('pagewidth')
        if s is not None:
            i, val = g.skip_long(s, 0)
            if val is not None and val &gt; 0:
                return val
            if issue_error_flag and not g.unitTesting:
                g.error("ignoring @pagewidth", s)
    return None
</t>
<t tx="ekr.20080827175609.37">def scanAtTabwidthDirectives(aList: list, issue_error_flag: bool = False) -&gt; Optional[int]:
    """Scan aList for @tabwidth directives."""
    for d in aList:
        s = d.get('tabwidth')
        if s is not None:
            junk, val = g.skip_long(s, 0)
            if val not in (None, 0):
                return val
            if issue_error_flag and not g.unitTesting:
                g.error("ignoring @tabwidth", s)
    return None

def scanAllAtTabWidthDirectives(c: Cmdr, p: Position) -&gt; Optional[int]:
    """Scan p and all ancestors looking for @tabwidth directives."""
    if c and p:
        aList = g.get_directives_dict_list(p)
        val = g.scanAtTabwidthDirectives(aList)
        ret = c.tab_width if val is None else val
    else:
        ret = None
    return ret
</t>
<t tx="ekr.20080827175609.52">def scanAtCommentAndAtLanguageDirectives(aList: list) -&gt; Optional[dict[str, str]]:
    """
    Scan aList for @comment and @language directives.

    @comment should follow @language if both appear in the same node.
    """
    lang = None
    for d in aList:
        comment = d.get('comment')
        language = d.get('language')
        # Important: assume @comment follows @language.
        if language:
            lang, delim1, delim2, delim3 = g.set_language(language, 0)
        if comment:
            delim1, delim2, delim3 = g.set_delims_from_string(comment)
        if comment or language:
            delims = delim1, delim2, delim3
            d = {'language': lang, 'comment': comment, 'delims': delims}
            return d
    return None
</t>
<t tx="ekr.20080827175609.53">def scanAtHeaderDirectives(aList: list) -&gt; None:
    """scan aList for @header and @noheader directives."""
    for d in aList:
        if d.get('header') and d.get('noheader'):
            g.error("conflicting @header and @noheader directives")
</t>
<t tx="ekr.20080831084419.4">def scanAtWrapDirectives(aList: list, issue_error_flag: bool = False) -&gt; Optional[bool]:
    """Scan aList for @wrap and @nowrap directives."""
    for d in aList:
        if d.get('wrap') is not None:
            return True
        if d.get('nowrap') is not None:
            return False
    return None

def scanAllAtWrapDirectives(c: Cmdr, p: Position) -&gt; Optional[bool]:
    """Scan p and all ancestors looking for @wrap/@nowrap directives."""
    if c and p:
        default = bool(c and c.config.getBool("body-pane-wraps"))
        aList = g.get_directives_dict_list(p)
        val = g.scanAtWrapDirectives(aList)
        ret = default if val is None else val
    else:
        ret = None
    return ret
</t>
<t tx="ekr.20090214075058.10">def update_directives_pat() -&gt; None:
    """Init/update g.directives_pat"""
    global globalDirectiveList, directives_pat
    # Use a pattern that guarantees word matches.
    aList = [
        fr"\b{z}\b" for z in globalDirectiveList if z != 'others'
    ]
    pat = "^@(%s)" % "|".join(aList)
    directives_pat = re.compile(pat, re.MULTILINE)

# #1688: Initialize g.directives_pat
update_directives_pat()
</t>
<t tx="ekr.20090214075058.6">def findLanguageDirectives(c: Cmdr, p: Position) -&gt; Optional[str]:
    """Return the language in effect at position p."""
    if c is None or p is None:
        return None  # c may be None for testing.

    v0 = p.v

    def find_language(p_or_v: Any) -&gt; Optional[str]:
        for s in p_or_v.h, p_or_v.b:
            for m in g_language_pat.finditer(s):
                language = m.group(1)
                if g.isValidLanguage(language):
                    return language
        return None

    # First, search up the tree.
    for p in p.self_and_parents(copy=False):
        language = find_language(p)
        if language:
            return language
    # #1625: Second, expand the search for cloned nodes.
    seen = []  # vnodes that have already been searched.
    parents = v0.parents[:]  # vnodes whose ancestors are to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        language = find_language(parent_v)
        if language:
            return language
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    # Finally, fall back to the defaults.
    return c.target_language.lower() if c.target_language else 'python'
</t>
<t tx="ekr.20090214075058.8">def findTabWidthDirectives(c: Cmdr, p: Position) -&gt; Optional[str]:
    """Return the tab width in effect at position p."""
    if c is None:
        return None  # c may be None for testing.
    w = None
    # 2009/10/02: no need for copy arg to iter
    for p in p.self_and_parents(copy=False):
        if w:
            break
        for s in p.h, p.b:
            if w:
                break
            anIter = g_tabwidth_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = g.skip_ws(s, i + len(word))
                junk, w = g.skip_long(s, j)
                if w == 0:
                    w = None
    return w
</t>
<t tx="ekr.20090214075058.9">def get_directives_dict(p: Position) -&gt; dict[str, str]:
    """
    Scan p for Leo directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive.
    """
    d = {}
    # The headline has higher precedence because it is more visible.
    for s in (p.h, p.b):
        anIter = g.directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d:
                continue
            j = i + len(word)
            if j &lt; len(s) and s[j] not in ' \t\n':
                # Not a valid directive: just ignore it.
                continue
            k = g.skip_line(s, j)
            val = s[j:k].strip()
            d[word] = val
    return d
</t>
<t tx="ekr.20090516135452.5776"># Warning: g.removeTrailingWs already exists.
# Do not change it!

def removeLeading(s: str, chars: str) -&gt; str:
    """Remove all characters in chars from the front of s."""
    i = 0
    while i &lt; len(s) and s[i] in chars:
        i += 1
    return s[i:]

def removeTrailing(s: str, chars: str) -&gt; str:
    """Remove all characters in chars from the end of s."""
    i = len(s) - 1
    while i &gt;= 0 and s[i] in chars:
        i -= 1
    i += 1
    return s[:i]
</t>
<t tx="ekr.20090516135452.5777">def ensureLeadingNewlines(s: str, n: int) -&gt; str:
    s = g.removeLeading(s, '\t\n\r ')
    return ('\n' * n) + s

def ensureTrailingNewlines(s: str, n: int) -&gt; str:
    s = g.removeTrailing(s, '\t\n\r ')
    return s + '\n' * n
</t>
<t tx="ekr.20090520055433.5945">def openWithFileName(fileName: str, old_c: Cmdr = None, gui: LeoGui = None) -&gt; Cmdr:
    """
    Create a Leo Frame for the indicated fileName if the file exists.

    Return the commander of the newly-opened outline.
    """
    return g.app.loadManager.loadLocalFile(fileName, gui, old_c)
</t>
<t tx="ekr.20090829140232.6036">def os_startfile(fname: str) -&gt; None:
    @others
    # pylint: disable=used-before-assignment
    if fname.find('"') &gt; -1:
        quoted_fname = f"'{fname}'"
    else:
        quoted_fname = f'"{fname}"'
    if sys.platform.startswith('win'):
        # pylint: disable=no-member
        os.startfile(quoted_fname)  # Exists only on Windows.
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            # Fix bug 1226358: File URL's are broken on MacOS:
            # use fname, not quoted_fname, as the argument to subprocess.call.
            subprocess.call(['open', fname])
        except OSError:
            pass  # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system(f"open {quoted_fname}")
    else:
        try:
            ree = None
            wre = tempfile.NamedTemporaryFile()
            ree = io.open(wre.name, 'rb', buffering=0)
        except IOError:
            g.trace(f"error opening temp file for {fname!r}")
            if ree:
                ree.close()
            return
        try:
            subPopen = subprocess.Popen(['xdg-open', fname], stderr=wre, shell=False)
        except Exception:
            g.es_print(f"error opening {fname!r}")
            g.es_exception()
        try:
            itoPoll = g.IdleTime(
                (lambda ito: itPoll(fname, ree, subPopen, g, ito)),
                delay=1000,
            )
            itoPoll.start()
            # Let the Leo-Editor process run
            # so that Leo-Editor is usable while the file is open.
        except Exception:
            g.es_exception(f"exception executing g.startfile for {fname!r}")
</t>
<t tx="ekr.20091229075924.6235">def removeLeadingBlankLines(s: str) -&gt; str:
    lines = g.splitLines(s)
    result = []
    remove = True
    for line in lines:
        if remove and not line.strip():
            pass
        else:
            remove = False
            result.append(line)
    return ''.join(result)
</t>
<t tx="ekr.20091229090857.11698">def removeBlankLines(s: str) -&gt; str:
    lines = g.splitLines(s)
    lines = [z for z in lines if z.strip()]
    return ''.join(lines)
</t>
<t tx="ekr.20100125073206.8709">def getPythonEncodingFromString(s: str) -&gt; str:
    """Return the encoding given by Python's encoding line.
    s is the entire file.
    """
    encoding = None
    tag, tag2 = '# -*- coding:', '-*-'
    n1, n2 = len(tag), len(tag2)
    if s:
        # For Python 3.x we must convert to unicode before calling startswith.
        # The encoding doesn't matter: we only look at the first line, and if
        # the first line is an encoding line, it will contain only ascii characters.
        s = g.toUnicode(s, encoding='ascii', reportErrors=False)
        lines = g.splitLines(s)
        line1 = lines[0].strip()
        if line1.startswith(tag) and line1.endswith(tag2):
            e = line1[n1 : -n2].strip()
            if e and g.isValidEncoding(e):
                encoding = e
        elif g.match_word(line1, 0, '@first'):  # 2011/10/21.
            line1 = line1[len('@first') :].strip()
            if line1.startswith(tag) and line1.endswith(tag2):
                e = line1[n1 : -n2].strip()
                if e and g.isValidEncoding(e):
                    encoding = e
    return encoding
</t>
<t tx="ekr.20100125073206.8710">def readFileIntoString(
    fileName: str,
    encoding: str = 'utf-8',  # BOM may override this.
    kind: str = None,  # @file, @edit, ...
    verbose: bool = True,
) -&gt; tuple[Any, Any]:
    """
    Return the contents of the file whose full path is fileName.

    Return (s,e)
    s is the string, converted to unicode, or None if there was an error.
    e is the encoding of s, computed in the following order:
    - The BOM encoding if the file starts with a BOM mark.
    - The encoding given in the # -*- coding: utf-8 -*- line for python files.
    - The encoding given by the 'encoding' keyword arg.
    - None, which typically means 'utf-8'.
    """
    if not fileName:
        if verbose:
            g.trace('no fileName arg given')
        return None, None
    if g.os_path_isdir(fileName):
        if verbose:
            g.trace('not a file:', fileName)
        return None, None
    if not g.os_path_exists(fileName):
        if verbose:
            g.error('file not found:', fileName)
        return None, None
    try:
        e = None
        with open(fileName, 'rb') as f:
            s = f.read()
        # Fix #391.
        if not s:
            return '', None
        # New in Leo 4.11: check for unicode BOM first.
        e, s = g.stripBOM(s)
        if not e:
            # Python's encoding comments override everything else.
            junk, ext = g.os_path_splitext(fileName)
            if ext == '.py':
                e = g.getPythonEncodingFromString(s)
        s = g.toUnicode(s, encoding=e or encoding)
        return s, e
    except IOError:
        # Translate 'can not open' and kind, but not fileName.
        if verbose:
            g.error('can not open', '', (kind or ''), fileName)
    except Exception:
        g.error(f"readFileIntoString: unexpected exception reading {fileName}")
        g.es_exception()
    return None, None
</t>
<t tx="ekr.20100126062623.6240">def internalError(*args: Any) -&gt; None:
    """Report a serious interal error in Leo."""
    callers = g.callers(20).split(',')
    caller = callers[-1]
    g.error('\nInternal Leo error in', caller)
    g.es_print(*args)
    g.es_print('Called from', ', '.join(callers[:-1]))
    g.es_print('Please report this error to Leo\'s developers', color='red')
</t>
<t tx="ekr.20100329071036.5744">def is_binary_file(f: Any) -&gt; bool:
    return f and isinstance(f, io.BufferedIOBase)

def is_binary_external_file(fileName: str) -&gt; bool:
    try:
        with open(fileName, 'rb') as f:
            s = f.read(1024)  # bytes, in Python 3.
        return g.is_binary_string(s)
    except IOError:
        return False
    except Exception:
        g.es_exception()
        return False

def is_binary_string(s: str) -&gt; bool:
    # http://stackoverflow.com/questions/898669
    # aList is a list of all non-binary characters.
    aList = [7, 8, 9, 10, 12, 13, 27] + list(range(0x20, 0x100))
    return bool(s.translate(None, bytes(aList)))  # type:ignore
</t>
<t tx="ekr.20100910075900.5950"># Important: we can not define g.pc here!
</t>
<t tx="ekr.20100910075900.5951">def loadOnePlugin(pluginName: str, verbose: bool = False) -&gt; Any:
    pc = g.app.pluginsController
    return pc.loadOnePlugin(pluginName, verbose=verbose)

def registerExclusiveHandler(tags: list[str], fn: str) -&gt; Any:
    pc = g.app.pluginsController
    return pc.registerExclusiveHandler(tags, fn)

def registerHandler(tags: Any, fn: Any) -&gt; Any:
    pc = g.app.pluginsController
    return pc.registerHandler(tags, fn)

def plugin_signon(module_name: str, verbose: bool = False) -&gt; Any:
    pc = g.app.pluginsController
    return pc.plugin_signon(module_name, verbose)

def unloadOnePlugin(moduleOrFileName: str, verbose: bool = False) -&gt; Any:
    pc = g.app.pluginsController
    return pc.unloadOnePlugin(moduleOrFileName, verbose)

def unregisterHandler(tags: Any, fn: Any) -&gt; Any:
    pc = g.app.pluginsController
    return pc.unregisterHandler(tags, fn)
</t>
<t tx="ekr.20100910075900.5952">def getHandlersForTag(tags: list[str]) -&gt; list:
    pc = g.app.pluginsController
    return pc.getHandlersForTag(tags)

def getLoadedPlugins() -&gt; list:
    pc = g.app.pluginsController
    return pc.getLoadedPlugins()

def getPluginModule(moduleName: str) -&gt; Any:
    pc = g.app.pluginsController
    return pc.getPluginModule(moduleName)

def pluginIsLoaded(fn: str) -&gt; bool:
    pc = g.app.pluginsController
    return pc.isLoaded(fn)
</t>
<t tx="ekr.20100914094836.5892">def blue(*args: Any, **keys: Any) -&gt; None:
    g.es_print(color='blue', *args, **keys)

def error(*args: Any, **keys: Any) -&gt; None:
    g.es_print(color='error', *args, **keys)

def note(*args: Any, **keys: Any) -&gt; None:
    g.es_print(color='note', *args, **keys)

def red(*args: Any, **keys: Any) -&gt; None:
    g.es_print(color='red', *args, **keys)

def warning(*args: Any, **keys: Any) -&gt; None:
    g.es_print(color='warning', *args, **keys)
</t>
<t tx="ekr.20101022172109.6108">def scanAtPathDirectives(c: Cmdr, aList: list) -&gt; str:
    path = c.scanAtPathDirectives(aList)
    return path

def scanAllAtPathDirectives(c: Cmdr, p: Position) -&gt; str:
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path
</t>
<t tx="ekr.20101028131948.5860">def dummy_act_on_node(c: Cmdr, p: Position, event: Any) -&gt; None:
    pass

# This dummy definition keeps pylint happy.
# Plugins can change this.

act_on_node = dummy_act_on_node
</t>
<t tx="ekr.20110605121601.18135">def openUrlOnClick(event: Any, url: str = None) -&gt; Optional[str]:
    """Open the URL under the cursor.  Return it for unit testing."""
    # QTextEditWrapper.mouseReleaseEvent calls this outside Leo's command logic.
    # Make sure to catch all exceptions!
    try:
        return openUrlHelper(event, url)
    except Exception:
        g.es_exception()
        return None
</t>
<t tx="ekr.20110609125359.16493">def isMacOS() -&gt; bool:
    return sys.platform == 'darwin'
</t>
<t tx="ekr.20110727091744.15083">@language rest
@
Important note: this routine need not deal with leading whitespace.

Instead, the caller should simply reduce pageWidth by the width of
leading whitespace wanted, then add that whitespace to the lines
returned here.

The key to this code is the invariant that line never ends in whitespace.
@c
@language python

def wrap_lines(lines: list[str], pageWidth: int, firstLineWidth: int = None) -&gt; list[str]:
    """Returns a list of lines, consisting of the input lines wrapped to the given pageWidth."""
    if pageWidth &lt; 10:
        pageWidth = 10
    # First line is special
    if not firstLineWidth:
        firstLineWidth = pageWidth
    if firstLineWidth &lt; 10:
        firstLineWidth = 10
    outputLineWidth = firstLineWidth
    # Sentence spacing
    # This should be determined by some setting, and can only be either 1 or 2
    sentenceSpacingWidth = 1
    assert 0 &lt; sentenceSpacingWidth &lt; 3
    result = []  # The lines of the result.
    line = ""  # The line being formed.  It never ends in whitespace.
    for s in lines:
        i = 0
        while i &lt; len(s):
            assert len(line) &lt;= outputLineWidth  # DTHEIN 18-JAN-2004
            j = g.skip_ws(s, i)
            k = g.skip_non_ws(s, j)
            word = s[j:k]
            assert k &gt; i
            i = k
            # DTHEIN 18-JAN-2004: wrap at exactly the text width,
            # not one character less
            #
            wordLen = len(word)
            if line.endswith('.') or line.endswith('?') or line.endswith('!'):
                space = ' ' * sentenceSpacingWidth
            else:
                space = ' '
            if line and wordLen &gt; 0:
                wordLen += len(space)
            if wordLen + len(line) &lt;= outputLineWidth:
                if wordLen &gt; 0:
                    &lt;&lt; place blank and word on the present line &gt;&gt;
                else:
                    pass  # discard the trailing whitespace.
            else:
                &lt;&lt; place word on a new line &gt;&gt;
    if line:
        result.append(line)
    return result
</t>
<t tx="ekr.20110727091744.15084">if line:
    # Add the word, preceded by a blank.
    line = space.join((line, word))
else:
    # Just add the word to the start of the line.
    line = word
</t>
<t tx="ekr.20110727091744.15085"># End the previous line.
if line:
    result.append(line)
    outputLineWidth = pageWidth  # DTHEIN 3-NOV-2002: width for remaining lines
# Discard the whitespace and put the word on a new line.
line = word
# Careful: the word may be longer than pageWidth.
if len(line) &gt; pageWidth:  # DTHEIN 18-JAN-2004: line can equal pagewidth
    result.append(line)
    outputLineWidth = pageWidth  # DTHEIN 3-NOV-2002: width for remaining lines
    line = ""
</t>
<t tx="ekr.20111010082822.15545">def getLanguageFromAncestorAtFileNode(p: Position) -&gt; Optional[str]:
    """
    Return the language in effect at node p.

    1. Use an unambiguous @language directive in p itself.
    2. Search p's "extended parents" for an @&lt;file&gt; node.
    3. Search p's "extended parents" for an unambiguous @language directive.
    """
    v0 = p.v
    seen: set[VNode]

    # The same generator as in v.setAllAncestorAtFileNodesDirty.
    # Original idea by Виталије Милошевић (Vitalije Milosevic).
    # Modified by EKR.

    def v_and_parents(v: VNode) -&gt; Generator:
        if v in seen:
            return
        seen.add(v)
        yield v
        for parent_v in v.parents:
            if parent_v not in seen:
                yield from v_and_parents(parent_v)

    def find_language(v: VNode, phase: int) -&gt; Optional[str]:
        """
        A helper for all searches.
        Phase one searches only @&lt;file&gt; nodes.
        """
        if phase == 1 and not v.isAnyAtFileNode():
            return None
        # #1693: Scan v.b for an *unambiguous* @language directive.
        languages = g.findAllValidLanguageDirectives(v.b)
        if len(languages) == 1:  # An unambiguous language
            return languages[0]
        if v.isAnyAtFileNode():
            # Use the file's extension.
            name = v.anyAtFileNodeName()
            junk, ext = g.os_path_splitext(name)
            ext = ext[1:]  # strip the leading period.
            language = g.app.extension_dict.get(ext)
            if g.isValidLanguage(language):
                return language
        return None

    # First, see if p contains any @language directive.
    language = g.findFirstValidAtLanguageDirective(p.b)
    if language:
        return language
    #
    # Phase 1: search only @&lt;file&gt; nodes: #2308.
    # Phase 2: search all nodes.
    for phase in (1, 2):
        # Search direct parents.
        for p2 in p.self_and_parents(copy=False):
            language = find_language(p2.v, phase)
            if language:
                return language
        # Search all extended parents.
        seen = set([v0.context.hiddenRootNode])
        for v in v_and_parents(v0):
            language = find_language(v, phase)
            if language:
                return language
    return None
</t>
<t tx="ekr.20111017204736.15898">def getDocString(s: str) -&gt; str:
    """Return the text of the first docstring found in s."""
    tags = ('"""', "'''")
    tag1, tag2 = tags
    i1, i2 = s.find(tag1), s.find(tag2)
    if i1 == -1 and i2 == -1:
        return ''
    if i1 &gt; -1 and i2 &gt; -1:
        i = min(i1, i2)
    else:
        i = max(i1, i2)
    tag = s[i : i + 3]
    assert tag in tags
    j = s.find(tag, i + 3)
    if j &gt; -1:
        return s[i + 3 : j]
    return ''
</t>
<t tx="ekr.20111017211256.15905">def getDocStringForFunction(func: Any) -&gt; str:
    """Return the docstring for a function that creates a Leo command."""

    def name(func: Any) -&gt; str:
        return func.__name__ if hasattr(func, '__name__') else '&lt;no __name__&gt;'

    def get_defaults(func: str, i: int) -&gt; Any:
        defaults = inspect.getfullargspec(func)[3]
        return defaults[i]

    # Fix bug 1251252: https://bugs.launchpad.net/leo-editor/+bug/1251252
    # Minibuffer commands created by mod_scripting.py have no docstrings.
    # Do special cases first.

    s = ''
    if name(func) == 'minibufferCallback':
        func = get_defaults(func, 0)
        if hasattr(func, '__doc__') and func.__doc__.strip():
            s = func.__doc__
    if not s and name(func) == 'commonCommandCallback':
        script = get_defaults(func, 1)
        s = g.getDocString(script)  # Do a text scan for the function.
    # Now the general cases.  Prefer __doc__ to docstring()
    if not s and hasattr(func, '__doc__'):
        s = func.__doc__
    if not s and hasattr(func, 'docstring'):
        s = func.docstring
    return s
</t>
<t tx="ekr.20111103205308.9657">@command('cls')
def cls(event: Event = None) -&gt; None:
    """Clear the screen."""
    if sys.platform.lower().startswith('win'):
        os.system('cls')
</t>
<t tx="ekr.20111107181638.9741">def print_exception(
    full: bool = True,
    c: Cmdr = None,
    flush: bool = False,
    color: str = "red",
) -&gt; tuple[str, int]:
    """Print exception info about the last exception."""
    # val is the second argument to the raise statement.
    typ, val, tb = sys.exc_info()
    if full:
        lines = traceback.format_exception(typ, val, tb)
    else:
        lines = traceback.format_exception_only(typ, val)
    print(''.join(lines), flush=flush)
    try:
        fileName, n = g.getLastTracebackFileAndLineNumber()
        return fileName, n
    except Exception:
        return "&lt;no file&gt;", 0
</t>
<t tx="ekr.20111114151846.9847">def toPythonIndex(s: str, index: str) -&gt; int:
    """
    Convert index to a Python int.

    index may be a Tk index (x.y) or 'end'.
    """
    if index is None:
        return 0
    if isinstance(index, int):
        return index
    if index == '1.0':
        return 0
    if index == 'end':
        return len(s)
    data = index.split('.')
    if len(data) == 2:
        row1, col1 = data
        row, col = int(row1), int(col1)
        i = g.convertRowColToPythonIndex(s, row - 1, col)
        return i
    g.trace(f"bad string index: {index}")
    return 0
</t>
<t tx="ekr.20111115155710.9814">def python_tokenize(s: str) -&gt; list:
    """
    Tokenize string s and return a list of tokens (kind, value, line_number)

    where kind is in ('comment,'id','nl','other','string','ws').
    """
    result: list[tuple[str, str, int]] = []
    i, line_number = 0, 0
    while i &lt; len(s):
        progress = j = i
        ch = s[i]
        if ch == '\n':
            kind, i = 'nl', i + 1
        elif ch in ' \t':
            kind = 'ws'
            while i &lt; len(s) and s[i] in ' \t':
                i += 1
        elif ch == '#':
            kind, i = 'comment', g.skip_to_end_of_line(s, i)
        elif ch in '"\'':
            kind, i = 'string', g.skip_python_string(s, i)
        elif ch == '_' or ch.isalpha():
            kind, i = 'id', g.skip_id(s, i)
        else:
            kind, i = 'other', i + 1
        assert progress &lt; i and j == progress
        val = s[j:i]
        assert val
        line_number += val.count('\n')  # A comment.
        result.append((kind, val, line_number),)
    return result
</t>
<t tx="ekr.20111115155710.9859"></t>
<t tx="ekr.20120123115816.10209">class BindingInfo:
    """
    A class representing any kind of key binding line.

    This includes other information besides just the KeyStroke.
    """
    # Important: The startup code uses this class,
    # so it is convenient to define it in leoGlobals.py.
    @others

def isBindingInfo(obj: Any) -&gt; bool:
    return isinstance(obj, BindingInfo)
</t>
<t tx="ekr.20120123143207.10223">class GeneralSetting:
    """A class representing any kind of setting except shortcuts."""
    # Important: The startup code uses this class,
    # so it is convenient to define it in leoGlobals.py.

    def __init__(
        self,
        kind: str,
        encoding: str = None,
        ivar: str = None,
        source: str = None,
        val: Any = None,
        path: str = None,
        tag: str = 'setting',
        unl: str = None,
    ) -&gt; None:
        self.encoding = encoding
        self.ivar = ivar
        self.kind = kind
        self.path = path
        self.unl = unl
        self.source = source  # Only @font sets this.
        self.val = val
        self.tag = tag

    def __repr__(self) -&gt; str:
        # Better for g.printObj.
        val = str(self.val).replace('\n', ' ')
        return (
            f"GS: path: {g.shortFileName(self.path or '')} "
            f"source: {self.source or ''} "
            f"kind: {self.kind:} val: {val}")

    dump = __repr__
    __str__ = __repr__
</t>
<t tx="ekr.20120125045244.10188">def __repr__(self) -&gt; str:
    return self.dump()

__str__ = __repr__

def dump(self) -&gt; str:
    result = [f"BindingInfo kind: {self.kind}"]
    # Print all existing ivars.
    table = ('pane', 'commandName', 'func', 'stroke')  # 'nextMode',
    for ivar in table:
        if hasattr(self, ivar):
            val = getattr(self, ivar)
            if val not in (None, 'none', 'None', ''):
                if ivar == 'func':
                    # pylint: disable=no-member
                    val = val.__name__
                s = f"{ivar}: {val!r}"
                result.append(s)
    # Clearer w/o f-string.
    return "&lt;%s&gt;" % ' '.join(result).strip()
</t>
<t tx="ekr.20120129040823.10226">def isModeBinding(self) -&gt; bool:
    return self.kind.startswith('*mode')
</t>
<t tx="ekr.20120129040823.10254">def __init__(
    self,
    kind: str,
    commandName: str = '',
    func: Callable = None,
    nextMode: str = None,
    pane: str = None,
    stroke: "KeyStroke" = None,
) -&gt; None:
    if not g.isStrokeOrNone(stroke):
        g.trace('***** (BindingInfo) oops', repr(stroke))
    self.kind = kind
    self.commandName = commandName
    self.func = func
    self.nextMode = nextMode
    self.pane = pane
    self.stroke = stroke  # The *caller* must canonicalize the shortcut.
</t>
<t tx="ekr.20120129181245.10220">class SettingsDict(dict):
    """A subclass of dict providing settings-related methods."""

    def __init__(self, name: str) -&gt; None:
        super().__init__()
        self._name = name  # For __repr__ only.

    def __repr__(self) -&gt; str:
        return f"&lt;SettingsDict name:{self._name} "

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20120201164453.10090">class KeyStroke:
    """
    A class that represent any key stroke or binding.

    stroke.s is the "canonicalized" stroke.
    """
    @others

def isStroke(obj: Any) -&gt; bool:
    return isinstance(obj, KeyStroke)

def isStrokeOrNone(obj: Any) -&gt; bool:
    return obj is None or isinstance(obj, KeyStroke)
</t>
<t tx="ekr.20120203053243.10117">@ All these must be defined in order to say, for example:
    for key in sorted(d)
where the keys of d are KeyStroke objects.
@c

def __eq__(self, other: Any) -&gt; bool:
    if not other:
        return False
    if hasattr(other, 's'):
        return self.s == other.s
    return self.s == other

def __lt__(self, other: Any) -&gt; bool:
    if not other:
        return False
    if hasattr(other, 's'):
        return self.s &lt; other.s
    return self.s &lt; other

def __le__(self, other: Any) -&gt; bool:
    return self.__lt__(other) or self.__eq__(other)

def __ne__(self, other: Any) -&gt; bool:
    return not self.__eq__(other)

def __gt__(self, other: Any) -&gt; bool:
    return not self.__lt__(other) and not self.__eq__(other)

def __ge__(self, other: Any) -&gt; bool:
    return not self.__lt__(other)
</t>
<t tx="ekr.20120203053243.10118"># Allow KeyStroke objects to be keys in dictionaries.

def __hash__(self) -&gt; Any:
    return self.s.__hash__() if self.s else 0
</t>
<t tx="ekr.20120203053243.10121">def isFKey(self) -&gt; bool:
    return self.s in g.app.gui.FKeys
</t>
<t tx="ekr.20120203053243.10124"># These may go away later, but for now they make conversion of string strokes easier.

def find(self, pattern: str) -&gt; int:
    return self.s.find(pattern)

def lower(self) -&gt; str:
    return self.s.lower()

def startswith(self, s: str) -&gt; bool:
    return self.s.startswith(s)
</t>
<t tx="ekr.20120203053243.10125">def toGuiChar(self) -&gt; str:
    """Replace special chars by the actual gui char."""
    s = self.s.lower()
    if s in ('\n', 'return'):
        s = '\n'
    elif s in ('\t', 'tab'):
        s = '\t'
    elif s in ('\b', 'backspace'):
        s = '\b'
    elif s in ('.', 'period'):
        s = '.'
    return s
</t>
<t tx="ekr.20120203153754.10031">def __hash__(self) -&gt; Any:
    return self.stroke.__hash__() if self.stroke else 0
</t>
<t tx="ekr.20120204061120.10067">def __repr__(self) -&gt; str:
    return f"&lt;KeyStroke: {repr(self.s)}&gt;"

def __str__(self) -&gt; str:
    return repr(self.s)
</t>
<t tx="ekr.20120219154958.10492">class EmergencyDialog:
    """
    A class that creates an tkinter dialog with a single OK button.

    If tkinter doesn't exist (#2512), this class just prints the message
    passed to the ctor.

    """
    @others
</t>
<t tx="ekr.20120219154958.10493">def __init__(self, title: str, message: str) -&gt; None:
    """Constructor for the leoTkinterDialog class."""
    self.answer = None  # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None  # Frame to hold typical dialog buttons.
    # Command to call when user click's the window's close box.
    self.defaultButtonCommand = None
    self.frame = None  # The outermost frame.
    self.root = None  # Created in createTopFrame.
    self.top = None  # The toplevel Tk widget.
    if Tk:  # #2512.
        self.createTopFrame()
        buttons = [{
            "text": "OK",
            "command": self.okButton,
            "default": True,
        }]
        self.createButtons(buttons)
        self.top.bind("&lt;Key&gt;", self.onKey)
    else:
        print(message.rstrip() + '\n')
</t>
<t tx="ekr.20120219154958.10494">def createButtons(self, buttons: list[dict[str, Any]]) -&gt; list[Any]:
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button.
    """
    assert self.frame
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "&lt;missing button name&gt;")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
</t>
<t tx="ekr.20120219154958.10495">def createTopFrame(self) -&gt; None:
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()  # type:ignore
    self.top = Tk.Toplevel(self.root)  # type:ignore
    self.top.title(self.title)
    self.root.withdraw()  # This root window should *never* be shown.
    self.frame = Tk.Frame(self.top)  # type:ignore
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=self.message, bg='white')
    label.pack(pady=10)
</t>
<t tx="ekr.20120219154958.10496">def okButton(self) -&gt; None:
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
</t>
<t tx="ekr.20120219154958.10497">def onKey(self, event: Any) -&gt; None:
    """Handle Key events in askOk dialogs."""
    self.okButton()
</t>
<t tx="ekr.20120219154958.10498">def run(self) -&gt; None:
    """Run the modal emergency dialog."""
    # Suppress f-stringify.
    self.top.geometry("%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set()  # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
</t>
<t tx="ekr.20120222084734.10287"># For compatibility with old code.

def computeGlobalConfigDir() -&gt; str:
    return g.app.loadManager.computeGlobalConfigDir()

def computeHomeDir() -&gt; str:
    return g.app.loadManager.computeHomeDir()

def computeLeoDir() -&gt; str:
    return g.app.loadManager.computeLeoDir()

def computeLoadDir() -&gt; str:
    return g.app.loadManager.computeLoadDir()

def computeMachineName() -&gt; str:
    return g.app.loadManager.computeMachineName()

def computeStandardDirectories() -&gt; str:
    return g.app.loadManager.computeStandardDirectories()
</t>
<t tx="ekr.20120223062418.10422">def copy(self, name: str = None) -&gt; Any:
    """Return a new dict with the same contents."""
    # The result is a g.SettingsDict.
    return copy.deepcopy(self)
</t>
<t tx="ekr.20120311151914.9916">&lt;&lt; About clickable links &gt;&gt;
</t>
<t tx="ekr.20120311151914.9917">def getUrlFromNode(p: Position) -&gt; Optional[str]:
    """
    Get an url from node p:
    1. Use the headline if it contains a valid url.
    2. Otherwise, look *only* at the first line of the body.
    """
    if not p:
        return None
    c = p.v.context
    assert c
    table = [p.h, g.splitLines(p.b)[0] if p.b else '']
    table = [s[4:] if g.match_word(s, 0, '@url') else s for s in table]
    table = [s.strip() for s in table if s.strip()]
    # First, check for url's with an explicit scheme.
    for s in table:
        if g.isValidUrl(s):
            return s
    # Next check for existing file and add a file:// scheme.
    for s in table:
        tag = 'file://'
        url = computeFileUrl(s, c=c, p=p)
        if url.startswith(tag):
            fn = url[len(tag) :].lstrip()
            fn = fn.split('#', 1)[0]
            if g.os_path_isfile(fn):
                # Return the *original* url, with a file:// scheme.
                # g.handleUrl will call computeFileUrl again.
                return 'file://' + s
    # Finally, check for local url's.
    for s in table:
        if s.startswith("#"):
            return s
    return None
</t>
<t tx="ekr.20120311151914.9918">def isValidUrl(url: str) -&gt; bool:
    """Return true if url *looks* like a valid url."""
    table = (
        'file', 'ftp', 'gopher', 'hdl', 'http', 'https', 'imap',
        'mailto', 'mms', 'news', 'nntp', 'prospero', 'rsync', 'rtsp', 'rtspu',
        'sftp', 'shttp', 'sip', 'sips', 'snews', 'svn', 'svn+ssh', 'telnet', 'wais',
    )
    if not url:
        return False
    if url.lower().startswith('unl://') or url.startswith('#'):
        # All Leo UNL's.
        return True
    if url.startswith('@'):
        return False
    parsed = urlparse.urlparse(url)
    scheme = parsed.scheme
    for s in table:
        if scheme.startswith(s):
            return True
    return False
</t>
<t tx="ekr.20120315062642.9744">def openUrl(p: Position) -&gt; None:
    """
    Open the url of node p.
    Use the headline if it contains a valid url.
    Otherwise, look *only* at the first line of the body.
    """
    if p:
        url = g.getUrlFromNode(p)
        if url:
            c = p.v.context
            if not g.doHook("@url1", c=c, p=p, url=url):
                g.handleUrl(url, c=c, p=p)
            g.doHook("@url2", c=c, p=p, url=url)
</t>
<t tx="ekr.20120320053907.9776">def computeFileUrl(fn: str, c: Cmdr = None, p: Position = None) -&gt; str:
    """
    Compute finalized url for filename fn.
    """
    # First, replace special characters (especially %20, by their equivalent).
    url = urllib.parse.unquote(fn)
    # Finalize the path *before* parsing the url.
    i = url.find('~')
    if i &gt; -1:
        # Expand '~'.
        path = url[i:]
        path = g.finalize(path)
        url = url[:i] + path
    else:
        tag = 'file://'
        tag2 = 'file:///'
        if sys.platform.startswith('win') and url.startswith(tag2):
            path = url[len(tag2) :].lstrip()
        elif url.startswith(tag):
            path = url[len(tag) :].lstrip()
        else:
            path = url
        # Handle ancestor @path directives.
        if c and c.openDirectory:
            base = c.getNodePath(p)
            path = g.finalize_join(c.openDirectory, base, path)
        else:
            path = g.finalize(path)
        url = f"{tag}{path}"
    return url
</t>
<t tx="ekr.20120605172139.10263"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespaceWidth(s: str, tab_width: int) -&gt; int:
    w = 0
    for ch in s:
        if ch == ' ':
            w += 1
        elif ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        else:
            break
    return w
</t>
<t tx="ekr.20120912153732.10597">def sleep(n: float) -&gt; None:
    """Wait about n milliseconds."""
    from time import sleep  # type:ignore
    sleep(n)  # type:ignore
</t>
<t tx="ekr.20120928142052.10116">def actualColor(color: str) -&gt; str:
    """Return the actual color corresponding to the requested color."""
    c = g.app.log and g.app.log.c
    # Careful: c.config may not yet exist.
    if not c or not c.config:
        return color
    # Don't change absolute colors.
    if color and color.startswith('#'):
        return color
    # #788: Translate colors to theme-defined colors.
    if color is None:
        # Prefer text_foreground_color'
        color2 = c.config.getColor('log-text-foreground-color')
        if color2:
            return color2
        # Fall back to log_black_color.
        color2 = c.config.getColor('log-black-color')
        return color2 or 'black'
    if color == 'black':
        # Prefer log_black_color.
        color2 = c.config.getColor('log-black-color')
        if color2:
            return color2
        # Fall back to log_text_foreground_color.
        color2 = c.config.getColor('log-text-foreground-color')
        return color2 or 'black'
    color2 = c.config.getColor(f"log_{color}_color")
    return color2 or color
</t>
<t tx="ekr.20121128031949.12602">def __init__(
    self,
    patterns: list[Any],
    indent: bool = True,
    show_args: bool = True,
    show_return: bool = True,
    verbose: bool = True,
) -&gt; None:
    """SherlockTracer ctor."""
    self.bad_patterns: list[str] = []  # List of bad patterns.
    self.indent = indent  # True: indent calls and returns.
    self.contents_d: dict[str, list] = {}  # Keys are file names, values are file lines.
    self.n = 0  # The frame level on entry to run.
    self.stats: dict[str, dict] = {}  # Keys are full file names, values are dicts.
    self.patterns: list[Any] = None  # A list of regex patterns to match.
    self.pattern_stack: list[str] = []
    self.show_args = show_args  # True: show args for each function call.
    self.show_return = show_return  # True: show returns from each function.
    self.trace_lines = True  # True: trace lines in enabled functions.
    self.verbose = verbose  # True: print filename:func
    self.set_patterns(patterns)
    try:  # Don't assume g.app exists.
        from leo.core.leoQt import QtCore
        if QtCore:
            # pylint: disable=no-member
            QtCore.pyqtRemoveInputHook()
    except Exception:
        pass
</t>
<t tx="ekr.20121128031949.12603">def do_call(self, frame: Any, unused_arg: Any) -&gt; None:
    """Trace through a function call."""
    frame1 = frame
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    function_name = code.co_name
    try:
        full_name = self.get_full_name(locals_, function_name)
    except Exception:
        full_name = function_name
    if not self.is_enabled(file_name, full_name, self.patterns):
        # 2020/09/09: Don't touch, for example, __ methods.
        return
    n = 0  # The number of callers of this def.
    while frame:
        frame = frame.f_back
        n += 1
    indent = ' ' * max(0, n - self.n) if self.indent else ''
    path = f"{os.path.basename(file_name):&gt;20}" if self.verbose else ''
    leadin = '+' if self.show_return else ''
    args_list = self.get_args(frame1)
    if self.show_args and args_list:
        args_s = ','.join(args_list)
        args_s2 = f"({args_s})"
        if len(args_s2) &gt; 100:
            print(f"{path}:{indent}{leadin}{full_name}")
            g.printObj(args_list, indent=len(indent) + 22)
        else:
            print(f"{path}:{indent}{leadin}{full_name}{args_s2}")
    else:
        print(f"{path}:{indent}{leadin}{full_name}")
    # Always update stats.
    d = self.stats.get(file_name, {})
    d[full_name] = 1 + d.get(full_name, 0)
    self.stats[file_name] = d
</t>
<t tx="ekr.20121128031949.12605">class SherlockTracer:
    """
    A stand-alone tracer class with many of Sherlock's features.

    This class should work in any environment containing the re, os and sys modules.

    The arguments in the pattern lists determine which functions get traced
    or which stats get printed. Each pattern starts with "+", "-", "+:" or
    "-:", followed by a regular expression::

    "+x"  Enables tracing (or stats) for all functions/methods whose name
          matches the regular expression x.
    "-x"  Disables tracing for functions/methods.
    "+:x" Enables tracing for all functions in the **file** whose name matches x.
    "-:x" Disables tracing for an entire file.

    Enabling and disabling depends on the order of arguments in the pattern
    list. Consider the arguments for the Rope trace::

    patterns=['+.*','+:.*',
        '-:.*\\lib\\.*','+:.*rope.*','-:.*leoGlobals.py',
        '-:.*worder.py','-:.*prefs.py','-:.*resources.py',])

    This enables tracing for everything, then disables tracing for all
    library modules, except for all rope modules. Finally, it disables the
    tracing for Rope's worder, prefs and resources modules.

    Being able to zero in on the code of interest can be a big help in
    studying other people's code. This is a non-invasive method: no tracing
    code needs to be inserted anywhere.

    Usage:

    g.SherlockTracer(patterns).run()
    """
    @others
</t>
<t tx="ekr.20121128031949.12609">def dispatch(self, frame: Any, event: Any, arg: Any) -&gt; Any:
    """The dispatch method."""
    if event == 'call':
        self.do_call(frame, arg)
    elif event == 'return' and self.show_return:
        self.do_return(frame, arg)
    elif event == 'line' and self.trace_lines:
        self.do_line(frame, arg)
    # Queue the SherlockTracer instance again.
    return self
</t>
<t tx="ekr.20121128031949.12614"># Modified from pdb.Pdb.set_trace.

def run(self, frame: Any = None) -&gt; None:
    """Trace from the given frame or the caller's frame."""
    print("SherlockTracer.run:patterns:\n%s" % '\n'.join(self.patterns))
    if frame is None:
        frame = sys._getframe().f_back
    # Compute self.n, the number of frames to ignore.
    self.n = 0
    while frame:
        frame = frame.f_back
        self.n += 1
    # Pass self to sys.settrace to give easy access to all methods.
    sys.settrace(self)
</t>
<t tx="ekr.20121128093229.12616">def stop(self) -&gt; None:
    """Stop all tracing."""
    sys.settrace(None)
</t>
<t tx="ekr.20121128111829.12182">def print_stats(self, patterns: list[str] = None) -&gt; None:
    """Print all accumulated statisitics."""
    print('\nSherlock statistics...')
    if not patterns:
        patterns = ['+.*', '+:.*',]
    for fn in sorted(self.stats.keys()):
        d = self.stats.get(fn)
        if self.fn_is_enabled(fn, patterns):
            result = sorted(d.keys())  # type:ignore
        else:
            result = [key for key in sorted(d.keys())  # type:ignore
                if self.is_enabled(fn, key, patterns)]
        if result:
            print('')
            fn = fn.replace('\\', '/')
            parts = fn.split('/')
            print('/'.join(parts[-2:]))
            for key in result:
                print(f"{d.get(key):4} {key}")
</t>
<t tx="ekr.20121128111829.12183">ignored_files: list[str] = []  # List of files.
ignored_functions: list[str] = []  # List of files.

def is_enabled(
    self,
    file_name: str,
    function_name: str,
    patterns: list[str] = None,
) -&gt; bool:
    """Return True if tracing for function_name in the given file is enabled."""
    #
    # New in Leo 6.3. Never trace through some files.
    if not os:
        return False  # Shutting down.
    base_name = os.path.basename(file_name)
    if base_name in self.ignored_files:
        return False

    def ignore_file() -&gt; None:
        if base_name not in self.ignored_files:
            self.ignored_files.append(base_name)

    def ignore_function() -&gt; None:
        if function_name not in self.ignored_functions:
            self.ignored_functions.append(function_name)

    if f"{os.sep}lib{os.sep}" in file_name:
        ignore_file()
        return False
    if base_name.startswith('&lt;') and base_name.endswith('&gt;'):
        ignore_file()
        return False
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '&lt;frozen&gt;', '&lt;genexpr&gt;', '&lt;listcomp&gt;',
        # '&lt;decorator-gen-.*&gt;',
        'get\b',
        # String primitives.
        'append\b', 'split\b', 'join\b',
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    for z in table:
        if re.match(z, function_name):
            ignore_function()
            return False
    #
    # Legacy code.
    enabled = False
    if patterns is None:
        patterns = self.patterns
    for pattern in patterns:
        try:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], file_name):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], file_name):
                    enabled = False
            elif pattern.startswith('+'):
                if re.match(pattern[1:], function_name):
                    enabled = True
            elif pattern.startswith('-'):
                if re.match(pattern[1:], function_name):
                    enabled = False
            else:
                self.bad_pattern(pattern)
        except Exception:
            self.bad_pattern(pattern)
    return enabled
</t>
<t tx="ekr.20121128111829.12185">def fn_is_enabled(self, func: Any, patterns: list[str]) -&gt; bool:
    """Return True if tracing for the given function is enabled."""
    if func in self.ignored_functions:
        return False

    def ignore_function() -&gt; None:
        if func not in self.ignored_functions:
            self.ignored_functions.append(func)
            print(f"Ignore function: {func}")
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '&lt;frozen&gt;', '&lt;genexpr&gt;', '&lt;listcomp&gt;',
        # '&lt;decorator-gen-.*&gt;',
        'get\b',
        # String primitives.
        'append\b', 'split\b', 'join\b',
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    g.trace('=====', func)
    for z in table:
        if re.match(z, func):
            ignore_function()
            return False
    #
    # Legacy code.
    try:
        enabled, pattern = False, None
        for pattern in patterns:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], func):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], func):
                    enabled = False
        return enabled
    except Exception:
        self.bad_pattern(pattern)
        return False
</t>
<t tx="ekr.20130109154743.10172">def do_return(self, frame: Any, arg: Any) -&gt; None:  # Arg *is* used below.
    """Trace a return statement."""
    code = frame.f_code
    fn = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    self.full_name = self.get_full_name(locals_, name)
    if not self.is_enabled(fn, self.full_name, self.patterns):
        return
    n = 0
    while frame:
        frame = frame.f_back
        n += 1
    path = f"{os.path.basename(fn):&gt;20}" if self.verbose else ''
    if name and name == '__init__':
        try:
            ret1 = locals_ and locals_.get('self', None)
            self.put_ret(ret1, n, path)
        except NameError:
            self.put_ret(f"&lt;{ret1.__class__.__name__}&gt;", n, path)
    else:
        self.put_ret(arg, n, path)
</t>
<t tx="ekr.20130111185820.10194">def get_args(self, frame: Any) -&gt; list[str]:
    """Return a list of string "name=val" for each arg in the function call."""
    code = frame.f_code
    locals_ = frame.f_locals
    name = code.co_name
    n = code.co_argcount
    if code.co_flags &amp; 4:
        n = n + 1
    if code.co_flags &amp; 8:
        n = n + 1
    result = []
    for i in range(n):
        name = code.co_varnames[i]
        if name != 'self':
            arg = locals_.get(name, '*undefined*')
            if arg:
                if isinstance(arg, (list, tuple)):
                    val_s = ','.join([self.show(z) for z in arg if self.show(z)])
                    val = f"[{val_s}]"
                elif isinstance(arg, str):
                    val = arg
                else:
                    val = self.show(arg)
                if val:
                    result.append(f"{name}={val}")
    return result
</t>
<t tx="ekr.20130112093655.10195">def get_full_name(self, locals_: Any, name: str) -&gt; str:
    """Return class_name::name if possible."""
    full_name = name
    try:
        user_self = locals_ and locals_.get('self', None)
        if user_self:
            full_name = user_self.__class__.__name__ + '::' + name
    except Exception:
        pass
    return full_name
</t>
<t tx="ekr.20130910044521.11304">def stripBOM(s_bytes: bytes) -&gt; tuple[str, bytes]:
    """
    If there is a BOM, return (e,s2) where e is the encoding
    implied by the BOM and s2 is the s stripped of the BOM.

    If there is no BOM, return (None,s)

    s must be the contents of a file (a string) read in binary mode.
    """
    table = (
        # Important: test longer bom's first.
        (4, 'utf-32', codecs.BOM_UTF32_BE),
        (4, 'utf-32', codecs.BOM_UTF32_LE),
        (3, 'utf-8', codecs.BOM_UTF8),
        (2, 'utf-16', codecs.BOM_UTF16_BE),
        (2, 'utf-16', codecs.BOM_UTF16_LE),
    )
    if s_bytes:
        for n, e, bom in table:
            assert len(bom) == n
            if bom == s_bytes[: len(bom)]:
                return e, s_bytes[len(bom) :]
    return None, s_bytes
</t>
<t tx="ekr.20131016032805.16721">def execute_shell_commands(commands: Any, trace: bool = False) -&gt; None:
    """
    Execute each shell command in a separate process.
    Wait for each command to complete, except those starting with '&amp;'
    """
    if isinstance(commands, str):
        commands = [commands]
    for command in commands:
        wait = not command.startswith('&amp;')
        if trace:
            g.trace(command)
        if command.startswith('&amp;'):
            command = command[1:].strip()
        proc = subprocess.Popen(command, shell=True)
        if wait:
            proc.communicate()
</t>
<t tx="ekr.20131114124839.16665">def createScratchCommander(fileName: str = None) -&gt; None:
    c = g.app.newCommander(fileName)
    frame = c.frame
    frame.createFirstTreeNode()
    assert c.rootPosition()
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
</t>
<t tx="ekr.20131230090121.16528">def isDirective(s: str) -&gt; bool:
    """Return True if s starts with a directive."""
    m = g_is_directive_pattern.match(s)
    if m:
        s2 = s[m.end(1) :]
        if s2 and s2[0] in ".(":
            return False
        return bool(m.group(1) in g.globalDirectiveList)
    return False
</t>
<t tx="ekr.20140209065845.16767">def insertCodingLine(encoding: str, script: str) -&gt; str:
    """
    Insert a coding line at the start of script s if no such line exists.
    The coding line must start with @first because it will be passed to
    at.stringToString.
    """
    if script:
        tag = '@first # -*- coding:'
        lines = g.splitLines(script)
        for s in lines:
            if s.startswith(tag):
                break
        else:
            lines.insert(0, f"{tag} {encoding} -*-\n")
            script = ''.join(lines)
    return script
</t>
<t tx="ekr.20140322090829.16831">def show(self, item: Any) -&gt; str:
    """return the best representation of item."""
    if not item:
        return repr(item)
    if isinstance(item, dict):
        return 'dict'
    if isinstance(item, str):
        s = repr(item)
        if len(s) &lt;= 20:
            return s
        return s[:17] + '...'
    s = repr(item)
    # A Hack for mypy:
    if s.startswith("&lt;object object"):
        s = "_dummy"
    return s
</t>
<t tx="ekr.20140322090829.16834">def push(self, patterns: list[str]) -&gt; None:
    """Push the old patterns and set the new."""
    self.pattern_stack.append(self.patterns)  # type:ignore
    self.set_patterns(patterns)
    print(f"SherlockTracer.push: {self.patterns}")

def pop(self) -&gt; None:
    """Restore the pushed patterns."""
    if self.pattern_stack:
        self.patterns = self.pattern_stack.pop()  # type:ignore
        print(f"SherlockTracer.pop: {self.patterns}")
    else:
        print('SherlockTracer.pop: pattern stack underflow')
</t>
<t tx="ekr.20140326100337.16844">def __call__(self, frame: Any, event: Any, arg: Any) -&gt; Any:
    """Exists so that self.dispatch can return self."""
    return self.dispatch(frame, event, arg)
</t>
<t tx="ekr.20140326100337.16845">def set_patterns(self, patterns: list[str]) -&gt; None:
    """Set the patterns in effect."""
    self.patterns = [z for z in patterns if self.check_pattern(z)]
</t>
<t tx="ekr.20140326100337.16846">def bad_pattern(self, pattern: Any) -&gt; None:
    """Report a bad Sherlock pattern."""
    if pattern not in self.bad_patterns:
        self.bad_patterns.append(pattern)
        print(f"\nignoring bad pattern: {pattern}\n")
</t>
<t tx="ekr.20140326100337.16847">def check_pattern(self, pattern: str) -&gt; bool:
    """Give an error and return False for an invalid pattern."""
    try:
        for prefix in ('+:', '-:', '+', '-'):
            if pattern.startswith(prefix):
                re.match(pattern[len(prefix) :], 'xyzzy')
                return True
        self.bad_pattern(pattern)
        return False
    except Exception:
        self.bad_pattern(pattern)
        return False
</t>
<t tx="ekr.20140402060647.16845">bad_fns: list[str] = []

def do_line(self, frame: Any, arg: Any) -&gt; None:
    """print each line of enabled functions."""
    if 1:
        return
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    full_name = self.get_full_name(locals_, name)
    if not self.is_enabled(file_name, full_name, self.patterns):
        return
    n = frame.f_lineno - 1  # Apparently, the first line is line 1.
    d = self.contents_d
    lines = d.get(file_name)
    if not lines:
        print(file_name)
        try:
            with open(file_name) as f:
                s = f.read()
        except Exception:
            if file_name not in self.bad_fns:
                self.bad_fns.append(file_name)
                print(f"open({file_name}) failed")
            return
        lines = g.splitLines(s)
        d[file_name] = lines
    line = lines[n].rstrip() if n &lt; len(lines) else '&lt;EOF&gt;'
    if 0:
        print(f"{name:3} {line}")
    else:
        print(f"{g.shortFileName(file_name)} {n} {full_name} {line}")
</t>
<t tx="ekr.20140526144610.17601"></t>
<t tx="ekr.20140528065727.17963">def pep8_class_name(s: str) -&gt; str:
    """Return the proper class name for s."""
    # Warning: s.capitalize() does not work.
    # It lower cases all but the first letter!
    return ''.join([z[0].upper() + z[1:] for z in s.split('_') if z])

if 0:  # Testing:
    cls()
    aList = (
        '_',
        '__',
        '_abc',
        'abc_',
        'abc',
        'abc_xyz',
        'AbcPdQ',
    )
    for s in aList:
        print(pep8_class_name(s))
</t>
<t tx="ekr.20140602083643.17659">def find_word(s: str, word: str, i: int = 0) -&gt; int:
    """
    Return the index of the first occurrence of word in s, or -1 if not found.

    g.find_word is *not* the same as s.find(i,word);
    g.find_word ensures that only word-matches are reported.
    """
    while i &lt; len(s):
        progress = i
        i = s.find(word, i)
        if i == -1:
            return -1
        # Make sure we are at the start of a word.
        if i &gt; 0:
            ch = s[i - 1]
            if ch == '_' or ch.isalnum():
                i += len(word)
                continue
        if g.match_word(s, i, word):
            return i
        i += len(word)
        assert progress &lt; i
    return -1
</t>
<t tx="ekr.20140711071454.17644"></t>
<t tx="ekr.20140711071454.17647"></t>
<t tx="ekr.20140711071454.17649"></t>
<t tx="ekr.20140711071454.17650"></t>
<t tx="ekr.20140825042850.18410">def IdleTime(handler: Any, delay: int = 500, tag: str = None) -&gt; Any:
    """
    A thin wrapper for the LeoQtGui.IdleTime class.

    The IdleTime class executes a handler with a given delay at idle time.
    The handler takes a single argument, the IdleTime instance::

        def handler(timer):
            '''IdleTime handler.  timer is an IdleTime instance.'''
            delta_t = timer.time-timer.starting_time
            g.trace(timer.count, '%2.4f' % (delta_t))
            if timer.count &gt;= 5:
                g.trace('done')
                timer.stop()

        # Execute handler every 500 msec. at idle time.
        timer = g.IdleTime(handler,delay=500)
        if timer: timer.start()

    Timer instances are completely independent::

        def handler1(timer):
            delta_t = timer.time-timer.starting_time
            g.trace('%2s %2.4f' % (timer.count,delta_t))
            if timer.count &gt;= 5:
                g.trace('done')
                timer.stop()

        def handler2(timer):
            delta_t = timer.time-timer.starting_time
            g.trace('%2s %2.4f' % (timer.count,delta_t))
            if timer.count &gt;= 10:
                g.trace('done')
                timer.stop()

        timer1 = g.IdleTime(handler1, delay=500)
        timer2 = g.IdleTime(handler2, delay=1000)
        if timer1 and timer2:
            timer1.start()
            timer2.start()
    """
    try:
        return g.app.gui.idleTimeClass(handler, delay, tag)
    except Exception:
        return None
</t>
<t tx="ekr.20140904112935.18526">def isTextWidget(w: Any) -&gt; bool:
    return g.app.gui.isTextWidget(w)

def isTextWrapper(w: Any) -&gt; bool:
    return g.app.gui.isTextWrapper(w)
</t>
<t tx="ekr.20150127060254.5">def log_to_file(s: str, fn: str = None) -&gt; None:
    """Write a message to ~/test/leo_log.txt."""
    if fn is None:
        fn = g.finalize('~/test/leo_log.txt')
    if not s.endswith('\n'):
        s = s + '\n'
    try:
        with open(fn, 'a') as f:
            f.write(s)
    except Exception:
        g.es_exception()
</t>
<t tx="ekr.20150227102835.8">def dump_encoded_string(encoding: str, s: str) -&gt; None:
    """Dump s, assumed to be an encoded string."""
    # Can't use g.trace here: it calls this function!
    print(f"dump_encoded_string: {g.callers()}")
    print(f"dump_encoded_string: encoding {encoding}\n")
    print(s)
    in_comment = False
    for ch in s:
        if ch == '#':
            in_comment = True
        elif not in_comment:
            print(f"{ord(ch):02x} {repr(ch)}")
        elif ch == '\n':
            in_comment = False
</t>
<t tx="ekr.20150306035851.7">def readFileIntoEncodedString(fn: str, silent: bool = False) -&gt; bytes:
    """Return the raw contents of the file whose full path is fn."""
    try:
        with open(fn, 'rb') as f:
            return f.read()
    except IOError:
        if not silent:
            g.error('can not open', fn)
    except Exception:
        if not silent:
            g.error(f"readFileIntoEncodedString: exception reading {fn}")
            g.es_exception()
    return None
</t>
<t tx="ekr.20150325075144.1">def getLanguageAtPosition(c: Cmdr, p: Position) -&gt; str:
    """
    Return the language in effect at position p.
    This is always a lowercase language name, never None.
    """
    aList = g.get_directives_dict_list(p)
    d = g.scanAtCommentAndAtLanguageDirectives(aList)
    language = (
        d and d.get('language') or
        g.getLanguageFromAncestorAtFileNode(p) or
        c.config.getString('target-language') or
        'python'
    )
    return language.lower()
</t>
<t tx="ekr.20150403150655.1">def fullPath(c: Cmdr, p: Position, simulate: bool = False) -&gt; str:
    """
    Return the full path (including fileName) in effect at p.

    Create neither the path nor the fileName.

    This function is deprecated. Use c.fullPath(p) instead.
    """
    return c.fullPath(p, simulate)
</t>
<t tx="ekr.20150508134046.1">def new_cmd_decorator(name: str, ivars: list[str]) -&gt; Callable:
    """
    Return a new decorator for a command with the given name.
    Compute the class *instance* using the ivar string or list.

    Don't even think about removing the @cmd decorators!
    See https://github.com/leo-editor/leo-editor/issues/325
    """

    def _decorator(func: Callable) -&gt; Callable:

        def new_cmd_wrapper(event: Any) -&gt; None:
            if isinstance(event, dict):
                c = event.get('c')
            else:
                c = event.c
            self = g.ivars2instance(c, g, ivars)
            try:
                # Don't use a keyword for self.
                # This allows the VimCommands class to use vc instead.
                func(self, event=event)
            except Exception:
                g.es_exception()

        new_cmd_wrapper.__func_name__ = func.__name__  # For leoInteg.
        new_cmd_wrapper.__name__ = name
        new_cmd_wrapper.__doc__ = func.__doc__
        # Put the *wrapper* into the global dict.
        global_commands_dict[name] = new_cmd_wrapper
        return func  # The decorator must return the func itself.

    return _decorator
</t>
<t tx="ekr.20150508164812.1">def ivars2instance(c: Cmdr, g: Any, ivars: list[str]) -&gt; Any:
    """
    Return the instance of c given by ivars.
    ivars is a list of strings.
    A special case: ivars may be 'g', indicating the leoGlobals module.
    """
    if not ivars:
        g.trace('can not happen: no ivars')
        return None
    ivar = ivars[0]
    if ivar not in ('c', 'g'):
        g.trace('can not happen: unknown base', ivar)
        return None
    obj = c if ivar == 'c' else g
    for ivar in ivars[1:]:
        obj = getattr(obj, ivar, None)
        if not obj:
            g.trace('can not happen: unknown attribute', obj, ivar, ivars)
            break
    return obj
</t>
<t tx="ekr.20150508165324.1">@others
</t>
<t tx="ekr.20150510103918.1">@nobeautify
@language rest
@
The cmd_instance_dict supports per-class @cmd decorators. For example, the
following appears in leo.commands.

    def cmd(name: Any) -&gt; Any:
        """Command decorator for the abbrevCommands class."""
        return g.new_cmd_decorator(name, ['c', 'abbrevCommands',])

For commands based on functions, use the @g.command decorator.
@c
@language python

global_commands_dict = {}

cmd_instance_dict = {
    # Keys are class names, values are attribute chains.
    'AbbrevCommandsClass':      ['c', 'abbrevCommands'],
    'AtFile':                   ['c', 'atFileCommands'],
    'AutoCompleterClass':       ['c', 'k', 'autoCompleter'],
    'ChapterController':        ['c', 'chapterController'],
    'Commands':                 ['c'],
    'ControlCommandsClass':     ['c', 'controlCommands'],
    'DebugCommandsClass':       ['c', 'debugCommands'],
    'EditCommandsClass':        ['c', 'editCommands'],
    'EditFileCommandsClass':    ['c', 'editFileCommands'],
    'FileCommands':             ['c', 'fileCommands'],
    'HelpCommandsClass':        ['c', 'helpCommands'],
    'KeyHandlerClass':          ['c', 'k'],
    'KeyHandlerCommandsClass':  ['c', 'keyHandlerCommands'],
    'KillBufferCommandsClass':  ['c', 'killBufferCommands'],
    'LeoApp':                   ['g', 'app'],
    'LeoFind':                  ['c', 'findCommands'],
    'LeoImportCommands':        ['c', 'importCommands'],
    # 'MacroCommandsClass':       ['c', 'macroCommands'],
    'PrintingController':       ['c', 'printingController'],
    'RectangleCommandsClass':   ['c', 'rectangleCommands'],
    'RstCommands':              ['c', 'rstCommands'],
    'SpellCommandsClass':       ['c', 'spellCommands'],
    'Undoer':                   ['c', 'undoer'],
    'VimCommands':              ['c', 'vimCommands'],
}
</t>
<t tx="ekr.20150510104148.1">def check_cmd_instance_dict(c: Cmdr, g: Any) -&gt; None:
    """
    Check g.check_cmd_instance_dict.
    This is a permanent unit test, called from c.finishCreate.
    """
    d = cmd_instance_dict
    for key in d:
        ivars = d.get(key)
        # Produces warnings.
        obj = ivars2instance(c, g, ivars)  # type:ignore
        if obj:
            name = obj.__class__.__name__
            if name != key:
                g.trace('class mismatch', key, name)
</t>
<t tx="ekr.20150610125813.1">def splitLongFileName(fn: str, limit: int = 40) -&gt; str:
    """Return fn, split into lines at slash characters."""
    aList = fn.replace('\\', '/').split('/')
    n, result = 0, []
    for i, s in enumerate(aList):
        n += len(s)
        result.append(s)
        if i + 1 &lt; len(aList):
            result.append('/')
            n += 1
        if n &gt; limit:
            result.append('\n')
            n = 0
    return ''.join(result)
</t>
<t tx="ekr.20150621095017.1">def goto_last_exception(c: Cmdr) -&gt; None:
    """Go to the line given by sys.last_traceback."""
    typ, val, tb = sys.exc_info()
    if tb:
        file_name, line_number = g.getLastTracebackFileAndLineNumber()
        line_number = max(0, line_number - 1)  # Convert to zero-based.
        if file_name.endswith('scriptFile.py'):
            # A script.
            c.goToScriptLineNumber(line_number, c.p)
        else:
            for p in c.all_nodes():
                if p.isAnyAtFileNode() and p.h.endswith(file_name):
                    c.goToLineNumber(line_number)
                    return
    else:
        g.trace('No previous exception')
</t>
<t tx="ekr.20160119090634.1">def scan_comment(self, s: str, i: int) -&gt; Optional[int]:
    """Return the index of the character after a comment."""
    i1 = i
    start = self.start_comment if self.forward else self.end_comment
    end = self.end_comment if self.forward else self.start_comment
    offset = 1 if self.forward else -1
    if g.match(s, i, start):
        if not self.forward:
            i1 += len(end)
        i += offset
        while 0 &lt;= i &lt; len(s):
            if g.match(s, i, end):
                i = i + len(end) if self.forward else i - 1
                return i
            i += offset
        self.oops('unmatched multiline comment')
    elif self.forward:
        # Scan to the newline.
        target = '\n'
        while 0 &lt;= i &lt; len(s):
            if s[i] == '\n':
                i += 1
                return i
            i += 1
    else:
        # Careful: scan to the *first* target on the line
        target = self.single_comment
        found = None
        i -= 1
        while 0 &lt;= i &lt; len(s) and s[i] != '\n':
            if g.match(s, i, target):
                found = i
            i -= 1
        if found is None:
            self.oops('can not happen: unterminated single-line comment')
            found = 0
        return found
    return i
</t>
<t tx="ekr.20160119093947.1">class MatchBrackets:
    """
    A class implementing the match-brackets command.

    In the interest of speed, the code assumes that the user invokes the
    match-bracket command outside of any string, comment or (for perl or
    javascript) regex.
    """
    @others
</t>
<t tx="ekr.20160119094053.1">@nobeautify

def run(self) -&gt; None:
    """The driver for the MatchBrackets class.

    With no selected range: find the nearest bracket and select from
    it to it's match, moving cursor to match.

    With selected range: the first time, move cursor back to other end of
    range. The second time, select enclosing range.
    """
    #
    # A partial fix for bug 127: Bracket matching is buggy.
    w = self.c.frame.body.wrapper
    s = w.getAllText()
    _mb = self.c.user_dict['_match_brackets']
    sel_range = w.getSelectionRange()
    if not w.hasSelection():
        _mb['count'] = 1
    if _mb['range'] == sel_range and _mb['count'] == 1:
        # haven't been to other end yet
        _mb['count'] += 1
        # move insert point to other end of selection
        insert = 1 if w.getInsertPoint() == sel_range[0] else 0
        w.setSelectionRange(
            sel_range[0], sel_range[1], insert=sel_range[insert])
        return

    # Find the bracket nearest the cursor.
    max_right = len(s) - 1 # insert point can be past last char.
    left = right = min(max_right, w.getInsertPoint())
    left, right, ch, index = self.expand_range(s, left, right, max_right)
    if left is None:
        g.es("Bracket not found")
        return
    index2 = self.find_matching_bracket(ch, s, index)
    if index2 is None:
        g.es("No matching bracket.")  # #1447.
        return

    # If this is the first time we've selected the range index-index2, do
    # nothing extra.  The second time, move cursor to other end (requires
    # no special action here), and the third time, try to expand the range
    # to any enclosing brackets
    minmax = (min(index, index2), max(index, index2)+1)
    # the range, +1 to match w.getSelectionRange()
    if _mb['range'] == minmax:  # count how many times this has been the answer
        _mb['count'] += 1
    else:
        _mb['count'] = 1
        _mb['range'] = minmax
    if _mb['count'] &gt;= 3:  # try to expand range
        left, right, ch, index3 = self.expand_range(
            s,
            max(minmax[0], 0),
            min(minmax[1], max_right),
            max_right, expand=True
        )
        if index3 is not None:  # found nearest bracket outside range
            index4 = self.find_matching_bracket(ch, s, index3)
            if index4 is not None:  # found matching bracket, expand range
                index, index2 = index3, index4
                _mb['count'] = 1
                _mb['range'] = (min(index3, index4), max(index3, index4)+1)

    if index2 is not None:
        if index2 &lt; index:
            w.setSelectionRange(index2, index + 1, insert=index2)
        else:
            w.setSelectionRange(
                index, index2 + 1, insert=min(len(s), index2 + 1))
        w.see(index2)
    else:
        g.es("unmatched", repr(ch))
</t>
<t tx="ekr.20160119101851.1">def starts_comment(self, s: str, i: int) -&gt; bool:
    """Return True if s[i] starts a comment."""
    assert 0 &lt;= i &lt; len(s)
    if self.forward:
        if self.single_comment and g.match(s, i, self.single_comment):
            return True
        return (
            self.start_comment and self.end_comment and
            g.match(s, i, self.start_comment)
        )
    if s[i] == '\n':
        if self.single_comment:
            # Scan backward for any single-comment delim.
            i -= 1
            while i &gt;= 0 and s[i] != '\n':
                if g.match(s, i, self.single_comment):
                    return True
                i -= 1
        return False
    return (
        self.start_comment and self.end_comment and
        g.match(s, i, self.end_comment)
    )
</t>
<t tx="ekr.20160119104148.1">def oops(self, s: str) -&gt; None:
    """Report an error in the match-brackets command."""
    g.es(s, color='red')
</t>
<t tx="ekr.20160119104510.1">def __init__(self, c: Cmdr, p: Position, language: str) -&gt; None:
    """Ctor for MatchBrackets class."""
    self.c = c
    self.p = p.copy()
    self.language = language
    # Constants.
    self.close_brackets = ")]}&gt;"
    self.open_brackets = "([{&lt;"
    self.brackets = self.open_brackets + self.close_brackets
    self.matching_brackets = self.close_brackets + self.open_brackets
    # Language dependent.
    d1, d2, d3 = g.set_delims_from_language(language)
    self.single_comment, self.start_comment, self.end_comment = d1, d2, d3
    # to track expanding selection
    c.user_dict.setdefault('_match_brackets', {'count': 0, 'range': (0, 0)})
</t>
<t tx="ekr.20160119230141.1">def scan_back(self, ch1: str, target: str, s: str, i: int) -&gt; Optional[int]:
    """Scan backwards for delim."""
    level = 0
    while i &gt;= 0:
        progress = i
        ch = s[i]
        if self.ends_comment(s, i):
            i = self.back_scan_comment(s, i)
        elif ch in '"\'':
            # Scan to the beginning of the string.
            i = self.scan_string(s, i)
        elif ch == '/' and self.is_regex(s, i):
            i = self.scan_regex(s, i)
        elif ch == ch1:
            level += 1
            i -= 1
        elif ch == target:
            level -= 1
            if level &lt;= 0:
                return i
            i -= 1
        else:
            i -= 1
        assert i &lt; progress
    # Not found
    return None
</t>
<t tx="ekr.20160119230141.2">def back_scan_comment(self, s: str, i: int) -&gt; int:
    """Return the index of the character after a comment."""
    i1 = i
    if g.match(s, i, self.end_comment):
        i1 += len(self.end_comment)  # For traces.
        i -= 1
        while i &gt;= 0:
            if g.match(s, i, self.start_comment):
                i -= 1
                return i
            i -= 1
        self.oops('unmatched multiline comment')
        return i
    # Careful: scan to the *first* target on the line
    found = None
    i -= 1
    while i &gt;= 0 and s[i] != '\n':
        if g.match(s, i, self.single_comment):
            found = i - 1
        i -= 1
    if found is None:
        self.oops('can not happen: unterminated single-line comment')
        found = 0
    return found
</t>
<t tx="ekr.20160119230141.4">def ends_comment(self, s: str, i: int) -&gt; bool:
    """
    Return True if s[i] ends a comment. This is called while scanning
    backward, so this is a bit of a guess.
    """
    if s[i] == '\n':
        # This is the hard (dubious) case.
        # Let w, x, y and z stand for any strings not containing // or quotes.
        # Case 1: w"x//y"z Assume // is inside a string.
        # Case 2: x//y"z Assume " is inside the comment.
        # Case 3: w//x"y"z Assume both quotes are inside the comment.
        #
        # That is, we assume (perhaps wrongly) that a quote terminates a
        # string if and *only* if the string starts *and* ends on the line.
        if self.single_comment:
            # Scan backward for single-line comment delims or quotes.
            quote = None
            i -= 1
            while i &gt;= 0 and s[i] != '\n':
                progress = i
                if quote and s[i] == quote:
                    quote = None
                    i -= 1
                elif s[i] in '"\'':
                    if not quote:
                        quote = s[i]
                    i -= 1
                elif g.match(s, i, self.single_comment):
                    # Assume that there is a comment only if the comment delim
                    # isn't inside a string that begins and ends on *this* line.
                    if quote:
                        while i &gt;= 0 and s[i] != 'n':
                            if s[i] == quote:
                                return False
                            i -= 1
                    return True
                else:
                    i -= 1
                assert progress &gt; i
        return False
    return (
        self.start_comment and
        self.end_comment and
        g.match(s, i, self.end_comment))
</t>
<t tx="ekr.20160121112303.1">def scan_string(self, s: str, i: int) -&gt; int:
    """
    Scan the string starting at s[i] (forward or backward).
    Return the index of the next character.
    """
    # i1 = i if self.forward else i + 1
    delim = s[i]
    assert delim in "'\"", repr(delim)
    offset = 1 if self.forward else -1
    i += offset
    while 0 &lt;= i &lt; len(s):
        ch = s[i]
        i2 = i - 1  # in case we have to look behind.
        i += offset
        if ch == delim:
            # Count the preceding backslashes.
            n = 0
            while 0 &lt;= i2 &lt; len(s) and s[i2] == '\\':
                n += 1
                i2 -= 1
            if (n % 2) == 0:
                return i
    # Annoying when matching brackets on the fly.
        # self.oops('unmatched string')
    return i + offset
</t>
<t tx="ekr.20160121112536.1">def scan_regex(self, s: str, i: int) -&gt; int:
    """Scan a regex (or regex substitution for perl)."""
    assert s[i] == '/'
    offset = 1 if self.forward else -1
    i1 = i
    i += offset
    found: Union[int, bool] = False
    while 0 &lt;= i &lt; len(s) and s[i] != '\n':
        ch = s[i]
        i2 = i - 1  # in case we have to look behind.
        i += offset
        if ch == '/':
            # Count the preceding backslashes.
            n = 0
            while 0 &lt;= i2 &lt; len(s) and s[i2] == '\\':
                n += 1
                i2 -= 1
            if (n % 2) == 0:
                if self.language == 'perl' and found is None:
                    found = i
                else:
                    found = i
                    break
    if found is None:
        self.oops('unmatched regex delim')
        return i1 + offset
    return found
</t>
<t tx="ekr.20160121112812.1">def is_regex(self, s: str, i: int) -&gt; bool:
    """Return true if there is another slash on the line."""
    if self.language in ('javascript', 'perl',):
        assert s[i] == '/'
        offset = 1 if self.forward else -1
        i += offset
        while 0 &lt;= i &lt; len(s) and s[i] != '\n':
            if s[i] == '/':
                return True
            i += offset
        return False
    return False
</t>
<t tx="ekr.20160121164556.1">def scan(self, ch1: str, target: str, s: str, i: int) -&gt; Optional[int]:
    """Scan forward for target."""
    level = 0
    while 0 &lt;= i &lt; len(s):
        progress = i
        ch = s[i]
        if ch in '"\'':
            # Scan to the end/beginning of the string.
            i = self.scan_string(s, i)
        elif self.starts_comment(s, i):
            i = self.scan_comment(s, i)
        elif ch == '/' and self.is_regex(s, i):
            i = self.scan_regex(s, i)
        elif ch == ch1:
            level += 1
            i += 1
        elif ch == target:
            level -= 1
            if level &lt;= 0:
                return i
            i += 1
        else:
            i += 1
        assert i &gt; progress
    # Not found
    return None
</t>
<t tx="ekr.20160121164723.1"></t>
<t tx="ekr.20160330204014.1">def init_dialog_folder(c: Cmdr, p: Position, use_at_path: bool = True) -&gt; str:
    """Return the most convenient folder to open or save a file."""
    if c and p and use_at_path:
        path = c.fullPath(p)
        if path:
            dir_ = g.os_path_dirname(path)
            if dir_ and g.os_path_exists(dir_):
                return dir_
    table = (
        c and c.last_dir,
        g.os_path_abspath(os.curdir),
    )
    for dir_ in table:
        if dir_ and g.os_path_exists(dir_):
            return dir_
    return ''
</t>
<t tx="ekr.20160331194701.1">def truncate(s: str, n: int) -&gt; str:
    """Return s truncated to n characters."""
    if len(s) &lt;= n:
        return s
    # Fail: weird ws.
    s2 = s[: n - 3] + f"...({len(s)})"
    if s.endswith('\n'):
        return s2 + '\n'
    return s2
</t>
<t tx="ekr.20160417174224.1">def plural(obj: Any) -&gt; str:
    """Return "s" or "" depending on n."""
    if isinstance(obj, (list, tuple, str)):
        n = len(obj)
    else:
        n = obj
    return '' if n == 1 else 's'
</t>
<t tx="ekr.20160504062833.1">def readFileIntoUnicodeString(
    fn: str,
    encoding: Optional[str] = None,
    silent: bool = False,
) -&gt; Optional[str]:
    """Return the raw contents of the file whose full path is fn."""
    try:
        with open(fn, 'rb') as f:
            s = f.read()
        return g.toUnicode(s, encoding=encoding)
    except IOError:
        if not silent:
            g.error('can not open', fn)
    except Exception:
        g.error(f"readFileIntoUnicodeString: unexpected exception reading {fn}")
        g.es_exception()
    return None
</t>
<t tx="ekr.20161027205025.1">def idleTimeHookHandler(timer: Any) -&gt; None:
    """This function exists for compatibility."""
    g.es_print('Replaced by IdleTimeManager.on_idle')
    g.trace(g.callers())
</t>
<t tx="ekr.20161223090721.1">def exec_file(path: str, d: dict[str, Any], script: str = None) -&gt; None:
    """Simulate python's execfile statement for python 3."""
    if script is None:
        with open(path) as f:
            script = f.read()
    exec(compile(script, path, 'exec'), d)
</t>
<t tx="ekr.20170123074946.1">def extractExecutableString(c: Cmdr, p: Position, s: str) -&gt; str:
    """
    Return all lines for the given @language directive.

    Ignore all lines under control of any other @language directive.
    """
    #
    # Rewritten to fix #1071.
    if g.unitTesting:
        return s  # Regretable, but necessary.
    #
    # Return s if no @language in effect. Should never happen.
    language = g.scanForAtLanguage(c, p)
    if not language:
        return s
    #
    # Return s if @language is unambiguous.
    pattern = r'^@language\s+(\w+)'
    matches = list(re.finditer(pattern, s, re.MULTILINE))
    if len(matches) &lt; 2:
        return s
    #
    # Scan the lines, extracting only the valid lines.
    extracting, result = False, []
    for line in g.splitLines(s):
        m = re.match(pattern, line)
        if m:
            extracting = m.group(1) == language
        elif extracting:
            result.append(line)
    return ''.join(result)
</t>
<t tx="ekr.20170127142001.5">def findFirstValidAtLanguageDirective(s: str) -&gt; Optional[str]:
    """
    Return the first language for which there is a valid @language
    directive in s.
    """
    if not s.strip():
        return None
    for m in g.g_language_pat.finditer(s):
        language = m.group(1)
        if g.isValidLanguage(language):
            return language
    return None
</t>
<t tx="ekr.20170201150505.1">def findAllValidLanguageDirectives(s: str) -&gt; list:
    """
    Return list of all languages for which there is a valid @language
    directive in s.
    """
    if not s.strip():
        return []
    languages = set()
    for m in g.g_language_pat.finditer(s):
        language = m.group(1)
        if g.isValidLanguage(language):
            languages.add(language)
    return list(sorted(languages))
</t>
<t tx="ekr.20170206080908.1">def input_(message: str = '', c: Cmdr = None) -&gt; str:
    """
    Safely execute python's input statement.

    c.executeScriptHelper binds 'input' to be a wrapper that calls g.input_
    with c and handler bound properly.
    """
    if app.gui.isNullGui:
        return ''
    # Prompt for input from the console, assuming there is one.
    # pylint: disable=no-member
    from leo.core.leoQt import QtCore
    QtCore.pyqtRemoveInputHook()
    return input(message)
</t>
<t tx="ekr.20170216091704.1">def openUrlHelper(event: Any, url: str = None) -&gt; Optional[str]:
    """Open the unl, url or gnx under the cursor.  Return it for unit testing."""
    c = getattr(event, 'c', None)
    if not c:
        return None
    w = getattr(event, 'w', c.frame.body.wrapper)
    if not g.app.gui.isTextWrapper(w):
        g.internalError('must be a text wrapper', w)
        return None
    if event:
        event.widget = w
    # Part 1: get the url.
    if url is None:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = w.getSelectionRange()
        if i != j:
            return None  # So find doesn't open the url.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        line = s[i:j]
        # Order is important.
        &lt;&lt; look for section ref &gt;&gt;
        url = unl = None
        &lt;&lt; look for url &gt;&gt;
        if not url:
            &lt;&lt; look for unl &gt;&gt;
            if not unl:
                &lt;&lt; look for gnx &gt;&gt;
    elif not isinstance(url, str):
        url = url.toString()
        url = g.toUnicode(url)  # #571
    if url and g.isValidUrl(url):
        # Part 2: handle the url
        p = c.p
        if not g.doHook("@url1", c=c, p=p, url=url):
            g.handleUrl(url, c=c, p=p)
        g.doHook("@url2", c=c, p=p)
        return url
    # Part 3: call find-def.
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if not word:
        return None
    p, pos, newpos = c.findCommands.find_def(event)
    if p:
        return None
    &lt;&lt; look for filename or import&gt;&gt;
    return None
</t>
<t tx="ekr.20170220103251.1">def findRootsWithPredicate(c: Cmdr, root: Position, predicate: Callable = None) -&gt; list[Position]:
    """
    Commands often want to find one or more **roots**, given a position p.
    A root is the position of any node matching a predicate.

    This function formalizes the search order used by the black,
    pylint, pyflakes and the rst3 commands, returning a list of zero
    or more found roots.
    """
    seen = []
    roots = []
    if predicate is None:

        # A useful default predicate for python.
        # pylint: disable=function-redefined

        def predicate(p: Position) -&gt; bool:
            headline = p.h.strip()
            is_python = headline.endswith(('py', 'pyw'))
            return p.isAnyAtFileNode() and is_python

    # 1. Search p's tree.
    for p in root.self_and_subtree(copy=False):
        if predicate(p) and p.v not in seen:
            seen.append(p.v)
            roots.append(p.copy())
    if roots:
        return roots
    # 2. Look up the tree.
    for p in root.parents():
        if predicate(p):
            return [p.copy()]
    # 3. Expand the search if root is a clone.
    clones = []
    for p in root.self_and_parents(copy=False):
        if p.isCloned():
            clones.append(p.v)
    if clones:
        for p in c.all_positions(copy=False):
            if predicate(p):
                # Match if any node in p's tree matches any clone.
                for p2 in p.self_and_subtree():
                    if p2.v in clones:
                        return [p.copy()]
    return []
</t>
<t tx="ekr.20170221063527.1">def handleUnl(unl_s: str, c: Cmdr) -&gt; None:
    """
    Select the node given by the unl.
    This must *never* open a browser.
    """
    if not unl_s:
        return
    unl = unl_s.strip()
    if not unl:
        return
    if not unl.startswith('unl:gnx:'):
        g.trace(f"Invalid unl: {unl!r}")
        return
    p = g.findGNX(unl[8:], c)
    # Do not assume that p is in c.
    if not p:
        print(f"Not found: {unl_s}")
</t>
<t tx="ekr.20170223093758.1">def getEncodingAt(p: Position, b: bytes = None) -&gt; str:
    """
    Return the encoding in effect at p and/or for string s.

    Read logic:  s is not None.
    Write logic: s is None.
    """
    # A BOM overrides everything.
    if b:
        e, junk_s = g.stripBOM(b)
        if e:
            return e
    aList = g.get_directives_dict_list(p)
    e = g.scanAtEncodingDirectives(aList)
    if b and b.strip() and not e:
        e = 'utf-8'
    return e
</t>
<t tx="ekr.20170226054459.1">def handleUrlHelper(url: str, c: Cmdr, p: Position) -&gt; None:
    """Open a url.  Most browsers should handle:
        ftp://ftp.uu.net/public/whatever
        http://localhost/MySiteUnderDevelopment/index.html
        file:///home/me/todolist.html
    """
    tag = 'file://'
    original_url = url
    if url.startswith(tag) and not url.startswith(tag + '#'):
        # Finalize the path *before* parsing the url.
        url = g.computeFileUrl(url, c=c, p=p)
    parsed = urlparse.urlparse(url)
    if parsed.netloc:
        leo_path = os.path.join(parsed.netloc, parsed.path)
        # "readme.txt" gets parsed into .netloc...
    else:
        leo_path = parsed.path
    if leo_path.endswith('\\'):
        leo_path = leo_path[:-1]
    if leo_path.endswith('/'):
        leo_path = leo_path[:-1]
    if parsed.scheme == 'file' and leo_path.endswith('.leo'):
        g.handleUnl(original_url, c)
    elif parsed.scheme in ('', 'file'):
        unquote_path = g.unquoteUrl(leo_path)
        if g.unitTesting:
            pass
        elif g.os_path_exists(leo_path):
            g.os_startfile(unquote_path)
        else:
            g.es(f"File '{leo_path}' does not exist")
    else:
        if g.unitTesting:
            pass
        else:
            # Mozilla throws a weird exception, then opens the file!
            try:
                webbrowser.open(url)
            except Exception:
                pass
</t>
<t tx="ekr.20170226060816.1">def traceUrl(c: Cmdr, path: str, parsed: Any, url: str) -&gt; None:

    print()
    g.trace('url          ', url)
    g.trace('c.frame.title', c.frame.title)
    g.trace('path         ', path)
    g.trace('parsed.fragment', parsed.fragment)
    g.trace('parsed.netloc', parsed.netloc)
    g.trace('parsed.path  ', parsed.path)
    g.trace('parsed.scheme', repr(parsed.scheme))
</t>
<t tx="ekr.20170226093349.1">def unquoteUrl(url: str) -&gt; str:
    """Replace special characters (especially %20, by their equivalent)."""
    return urllib.parse.unquote(url)
</t>
<t tx="ekr.20170228082641.1">def composeScript(
    c: Cmdr,
    p: Position,
    s: str,
    forcePythonSentinels: bool = True,
    useSentinels: bool = True,
) -&gt; str:
    """Compose a script from p.b."""
    # This causes too many special cases.
        # if not g.unitTesting and forceEncoding:
            # aList = g.get_directives_dict_list(p)
            # encoding = scanAtEncodingDirectives(aList) or 'utf-8'
            # s = g.insertCodingLine(encoding,s)
    if not s.strip():
        return ''
    at = c.atFileCommands
    old_in_script = g.app.inScript
    try:
        # #1297: set inScript flags.
        g.app.inScript = g.inScript = True
        g.app.scriptDict["script1"] = s
        # Important: converts unicode to utf-8 encoded strings.
        script = at.stringToString(p.copy(), s,
            forcePythonSentinels=forcePythonSentinels,
            sentinels=useSentinels)
        # Important, the script is an **encoded string**, not a unicode string.
        script = script.replace("\r\n", "\n")  # Use brute force.
        g.app.scriptDict["script2"] = script
    finally:
        g.app.inScript = g.inScript = old_in_script
    return script
</t>
<t tx="ekr.20170317101100.1">def unCamel(s: str) -&gt; list[str]:
    """Return a list of sub-words in camelCased string s."""
    result: list[str] = []
    word: list[str] = []
    for ch in s:
        if ch.isalpha() and ch.isupper():
            if word:
                result.append(''.join(word))
            word = [ch]
        elif ch.isalpha():
            word.append(ch)
        elif word:
            result.append(''.join(word))
            word = []
    if word:
        result.append(''.join(word))
    return result
</t>
<t tx="ekr.20170414034616.1"></t>
<t tx="ekr.20170414034616.2">def gitBranchName(path: str = None) -&gt; str:
    """
    Return the git branch name associated with path/.git, or the empty
    string if path/.git does not exist. If path is None, use the leo-editor
    directory.
    """
    branch, commit = g.gitInfo(path)
    return branch
</t>
<t tx="ekr.20170414034616.3">def gitInfo(path: str = None) -&gt; tuple[str, str]:
    """
    Path may be a directory or file.

    Return the branch and commit number or ('', '').
    """
    branch, commit = '', ''  # Set defaults.
    if path is None:
        # Default to leo/core.
        path = os.path.dirname(__file__)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    # Does path/../ref exist?
    path = g.gitHeadPath(path)
    if not path:
        return branch, commit
    try:
        with open(path) as f:
            s = f.read()
            if not s.startswith('ref'):
                branch = 'None'
                commit = s[:7]
                return branch, commit
        # On a proper branch
        pointer = s.split()[1]
        dirs = pointer.split('/')
        branch = dirs[-1]
    except IOError:
        g.trace('can not open:', path)
        return branch, commit
    # Try to get a better commit number.
    git_dir = g.finalize_join(path, '..')
    try:
        path = g.finalize_join(git_dir, pointer)
        with open(path) as f:
            s = f.read()
        commit = s.strip()[0:12]
        # shorten the hash to a unique shortname
    except IOError:
        try:
            path = g.finalize_join(git_dir, 'packed-refs')
            with open(path) as f:  # type:ignore
                for line in f:
                    if line.strip().endswith(' ' + pointer):
                        commit = line.split()[0][0:12]
                        break
        except IOError:
            pass
    return branch, commit
</t>
<t tx="ekr.20170414034616.4">def gitCommitNumber(path: str = None) -&gt; str:
    """
    Return the git commit number associated with path/.git, or the empty
    string if path/.git does not exist. If path is None, use the leo-editor
    directory.
    """
    branch, commit = g.gitInfo(path)
    return commit
</t>
<t tx="ekr.20170414034616.6">def gitHeadPath(path_s: str) -&gt; Optional[str]:
    """
    Compute the path to .git/HEAD given the path.
    """
    path = Path(path_s)
    # #1780: Look up the directory tree, looking the .git directory.
    while os.path.exists(path):
        head = os.path.join(path, '.git', 'HEAD')
        if os.path.exists(head):
            return head
        if path == path.parent:
            break
        path = path.parent
    return None
</t>
<t tx="ekr.20170616102324.1">def execGitCommand(command: str, directory: str) -&gt; list[str]:
    """Execute the given git command in the given directory."""
    git_dir = g.finalize_join(directory, '.git')
    if not g.os_path_exists(git_dir):
        g.trace('not found:', git_dir, g.callers())
        return []
    if '\n' in command:
        g.trace('removing newline from', command)
        command = command.replace('\n', '')
    # #1777: Save/restore os.curdir
    old_dir = os.getcwd()
    if directory:
        os.chdir(directory)
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=None,  # Shows error traces.
            shell=False,
        )
        out, err = p.communicate()
        lines = [g.toUnicode(z) for z in g.splitLines(out or [])]
    finally:
        os.chdir(old_dir)
    return lines
</t>
<t tx="ekr.20171023140544.1">def printObj(obj: Any, tag: str = None, indent: int = 0) -&gt; None:
    """Pretty print any Python object using g.pr."""
    g.pr(objToString(obj, indent=indent, tag=tag))

printDict = printObj
printList = printObj
printTuple = printObj
</t>
<t tx="ekr.20171123095526.1">class CommanderCommand:
    """
    A global decorator for creating commander commands, that is, commands
    that were formerly methods of the Commands class in leoCommands.py.

    Usage:

        @g.command('command-name')
        def command_name(self, *args, **kwargs):
            ...

    The decorator injects command_name into the Commander class and calls
    funcToMethod so the ivar will be injected in all future commanders.

    g can *not* be used anywhere in this class!
    """

    def __init__(self, name: str, **kwargs: Any) -&gt; None:
        """Ctor for command decorator class."""
        self.name = name

    def __call__(self, func: Callable) -&gt; Callable:
        """Register command for all future commanders."""

        def commander_command_wrapper(event: Any) -&gt; None:
            c = event.get('c')
            method = getattr(c, func.__name__, None)
            method(event=event)

        # Inject ivars for plugins_menu.py.
        commander_command_wrapper.__func_name__ = func.__name__  # For leoInteg.
        commander_command_wrapper.__name__ = self.name
        commander_command_wrapper.__doc__ = func.__doc__
        global_commands_dict[self.name] = commander_command_wrapper
        if app:
            from leo.core import leoCommands
            funcToMethod(func, leoCommands.Commands)
            for c in app.commanders():
                c.k.registerCommand(self.name, func)
        # Inject ivars for plugins_menu.py.
        func.is_command = True
        func.command_name = self.name
        return func

commander_command = CommanderCommand
</t>
<t tx="ekr.20171124070654.1">def command_alias(alias: str, func: Callable) -&gt; None:
    """Create an alias for the *already defined* method in the Commands class."""
    from leo.core import leoCommands
    assert hasattr(leoCommands.Commands, func.__name__)
    funcToMethod(func, leoCommands.Commands, alias)
</t>
<t tx="ekr.20180126043719.3">def get_one_issue(self, label: str, state: Any, limit: int = 20) -&gt; None:
    """Create a list of issues with the given label."""
    try:
        import requests
    except Exception:
        g.trace('requests not found: `pip install requests`')
        return
    root = self.root.insertAsLastChild()
    page, total = 1, 0
    page_url = self.base_url + '?labels=%s&amp;state=%s&amp;page=%s'
    while True:
        url = page_url % (label, state, page)
        r = requests.get(url, timeout=2.0)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # Do not remove this trace. It's reassuring.
            g.trace(f"done: {done:5} page: {page:3} found: {n:3} label: {label}")
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page &gt; limit:
            g.trace('too many pages')
            break
    state = state.capitalize()
    if self.milestone:
        root.h = f"{total} {state} {label} issues for milestone {self.milestone}"
    else:
        root.h = f"{total} {state} {label} issues"
</t>
<t tx="ekr.20180126043719.4">def get_one_page(self, label: str, page: int, r: Any, root: Position) -&gt; tuple[bool, int]:

    if self.milestone:
        aList = [
            z for z in r.json()
                if z.get('milestone') is not None and
                    self.milestone == z.get('milestone').get('title')
        ]
    else:
        aList = [z for z in r.json()]
    for d in aList:
        n, title = d.get('number'), d.get('title')
        html_url = d.get('html_url') or self.base_url
        p = root.insertAsNthChild(0)
        p.h = f"#{n}: {title}"
        p.b = f"{html_url}\n\n"
        p.b += d.get('body').strip()
    link = r.headers.get('Link')
    done = not link or link.find('rel="next"') == -1
    return done, len(aList)
</t>
<t tx="ekr.20180126043905.1">def getGitIssues(c: Cmdr,
    base_url: str = None,
    label_list: list = None,
    milestone: str = None,
    state: Optional[str] = None,  # in (None, 'closed', 'open')
) -&gt; None:
    """Get a list of issues from Leo's GitHub site."""
    if base_url is None:
        base_url = 'https://api.github.com/repos/leo-editor/leo-editor/issues'
    if isinstance(label_list, (list, tuple)):
        root = c.lastTopLevel().insertAfter()
        root.h = 'Issues for ' + milestone if milestone else 'Backup'
        GitIssueController().backup_issues(base_url, c, label_list, root)
        root.expand()
        c.selectPosition(root)
        c.redraw()
        g.trace('done')
    else:
        g.trace('label_list must be a list or tuple', repr(label_list))
</t>
<t tx="ekr.20180126044602.1">class GitIssueController:
    """
    A class encapsulating the retrieval of GitHub issues.

    The GitHub api: https://developer.github.com/v3/issues/
    """
    @others
</t>
<t tx="ekr.20180126044850.1">def get_issues(self, base_url: str, label_list: list, milestone: Any, root: Position, state: Any) -&gt; None:
    """Create a list of issues for each label in label_list."""
    self.base_url = base_url
    self.milestone = milestone
    self.root = root
    for label in label_list:
        self.get_one_issue(label, state)
</t>
<t tx="ekr.20180127092201.1">def print_header(self, r: Any) -&gt; None:

    # r.headers is a CaseInsensitiveDict
    # so g.printObj(r.headers) is just repr(r.headers)
    if 0:
        print('Link', r.headers.get('Link'))
    else:
        for key in r.headers:
            print(f"{key:35}: {r.headers.get(key)}")
</t>
<t tx="ekr.20180217113719.1">def execute_shell_commands_with_options(
    base_dir: str = None,
    c: Cmdr = None,
    command_setting: str = None,
    commands: list = None,
    path_setting: str = None,
    trace: bool = False,
    warning: str = None,
) -&gt; None:
    """
    A helper for prototype commands or any other code that
    runs programs in a separate process.

    base_dir:           Base directory to use if no config path given.
    commands:           A list of commands, for g.execute_shell_commands.
    commands_setting:   Name of @data setting for commands.
    path_setting:       Name of @string setting for the base directory.
    warning:            A warning to be printed before executing the commands.
    """
    base_dir = g.computeBaseDir(c, base_dir, path_setting)
    if not base_dir:
        return
    commands = g.computeCommands(c, commands, command_setting)
    if not commands:
        return
    if warning:
        g.es_print(warning)
    os.chdir(base_dir)  # Can't do this in the commands list.
    g.execute_shell_commands(commands, trace=trace)
</t>
<t tx="ekr.20180217152624.1">def computeBaseDir(c: Cmdr, base_dir: str, path_setting: str) -&gt; Optional[str]:
    """
    Compute a base_directory.
    If given, @string path_setting takes precedence.
    """
    # Prefer the path setting to the base_dir argument.
    if path_setting:
        if not c:
            g.es_print('@string path_setting requires valid c arg')
            return None
        # It's not an error for the setting to be empty.
        base_dir2 = c.config.getString(path_setting)
        if base_dir2:
            base_dir2 = base_dir2.replace('\\', '/')
            if g.os_path_exists(base_dir2):
                return base_dir2
            g.es_print(f"@string {path_setting} not found: {base_dir2!r}")
            return None
    # Fall back to given base_dir.
    if base_dir:
        base_dir = base_dir.replace('\\', '/')
        if g.os_path_exists(base_dir):
            return base_dir
        g.es_print(f"base_dir not found: {base_dir!r}")
        return None
    g.es_print(f"Please use @string {path_setting}")
    return None
</t>
<t tx="ekr.20180217153459.1">def computeCommands(c: Cmdr, commands: list[str], command_setting: str) -&gt; list[str]:
    """
    Get the list of commands.
    If given, @data command_setting takes precedence.
    """
    if not commands and not command_setting:
        g.es_print('Please use commands, command_setting or both')
        return []
    # Prefer the setting to the static commands.
    if command_setting:
        if c:
            aList = c.config.getData(command_setting)
            # It's not an error for the setting to be empty.
            # Fall back to the commands.
            return aList or commands
        g.es_print('@data command_setting requires valid c arg')
        return []
    return commands
</t>
<t tx="ekr.20180311131353.1" str_leo_pos="3,11"></t>
<t tx="ekr.20180311131403.1">file:///c:/Test/04_Neural_Networks.ipynb
</t>
<t tx="ekr.20180311131424.1"></t>
<t tx="ekr.20180311131449.1">@language python

@ doc part (colored as **markdown**)
@c

def spam():
    '''Docstring'''
    # Comment.
    a = 'Regular string'

    </t>
<t tx="ekr.20180311195905.1">@language python

"""
Changes LaTeX section definition levels in the subtree of an @clean file node to their subtree level.
Only one LaTeX section level can therefore be used within a single node body.
"""

import re

section_levels = {
    1: 'chapter',
    2: 'section',
    3: 'subsection',
    4: 'subsubsection',
    5: 'paragraph',
    6: 'subparagraph'
}

def latex_convert_section_levels(p, adjusted_level_name):
    """ Replaces LaTeX section definition levels found on a single line (re multiline mode).
    Returns the modified node body."""
    return re.sub(r'\\(chapter|section|subsection|subsubsection|paragraph|subparagraph)(\[.*?\])?({.*})',
        r'\\'+adjusted_level_name+r'\g&lt;2&gt;\g&lt;3&gt;', p.b, re.M)

u, undoType = c.undoer, 'change-latex'
h = p.h.strip()
if g.match_word(h, 0, '@clean') and h.endswith('.tex'):
    bunch = u.beforeChangeTree(c.p)
    changed, dirtyVnodeList = 0, []
    root_level = p.level()
    for p in p.subtree():
        level = p.level() - root_level
        if level &lt; 7:
            level_name = section_levels[level]
        else:
            level_name = 'subparagraph'
        s = latex_convert_section_levels(p, level_name)
        if s != p.b:
            bunch2 = u.beforeChangeNodeContents(p)
            p.b = s
            u.afterChangeNodeContents(p, undoType, bunch2, dirtyVnodeList=dirtyVnodeList)
            p.v.setDirty()
            changed += 1
    if changed:
        u.afterChangeTree(c.p, undoType, bunch)
        g.es('Changed %s node%s.' % (changed, g.plural(changed)))
    else:
        g.es('No nodes changed')
else:
    g.es('not a LaTeX file node?')</t>
<t tx="ekr.20180311200239.1">@language tex
@others
</t>
<t tx="ekr.20180311200312.1">\paragraph{one}

</t>
<t tx="ekr.20180311200318.1">\paragraph{two}


</t>
<t tx="ekr.20180311210803.1"></t>
<t tx="ekr.20180311212134.1"></t>
<t tx="ekr.20180311212134.2">table = (
    # g.actualColor calls 
    'error', 'info', 'warning',
    'black', 'white',
    'xxx',
    'firebrick', 'grey', 'pink', 'purple', # Tk colors.
    # Solarized colors...
    'blue', 'cyan', 'green','magenta', 'orange', 'red',
    'violet', 'yellow',
)
for s in table:
    g.es(s, color=s)
</t>
<t tx="ekr.20180311212134.3"># g.cls()
g.error('error')
g.note('note')
g.warning('warning')
g.blue('blue')
g.red('red')
g.es_print('test')
g.es_print('black',color='black')</t>
<t tx="ekr.20180312050315.1">import os
print(g.os_path_abspath(os.curdir))</t>
<t tx="ekr.20180314081254.1">def os_path_normslashes(path: str) -&gt; str:
    """
    Convert backslashes to forward slashes (Windows only).

    In effect, this convert Windows paths to POSIX paths.
    """
    if not path:
        return ''
    return path.replace('\\', '/') if g.isWindows else path
</t>
<t tx="ekr.20180314120442.1">def glob_glob(pattern: str) -&gt; list:
    """Return the regularized glob.glob(pattern)"""
    aList = glob.glob(pattern)
    # os.path.normpath does the *reverse* of what we want.
    if g.isWindows:
        aList = [z.replace('\\', '/') for z in aList]
    return aList
</t>
<t tx="ekr.20180319044254.1"></t>
<t tx="ekr.20180319044254.10">C:\Users\edreamleo\SampleVideo_1280x720_1mb.mp4
</t>
<t tx="ekr.20180319044254.11">http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4

# This *does* play.</t>
<t tx="ekr.20180319044254.12"></t>
<t tx="ekr.20180319044254.13"># http://matplotlib.org/1.5.1/examples/animation/animate_decay.html
np = matplotlib = None
try:
    import numpy as np
except Exception:
    g.es_print('Can not import numpy')
try:
    import matplotlib.pyplot as plt
    import matplotlib.animation as animation
except Exception:
    g.es_print('Can not import matplotlib')

@others

# global data.
if np and matplotlib:
    fig, ax = plt.subplots()
    line, = ax.plot([], [], lw=2)
    ax.grid()
    xdata, ydata = [], []
    ani = animation.FuncAnimation(
        fig, run, data_gen, blit=False, interval=10,
        repeat=False, init_func=init)
    
    plt.ion()
        # sets interactive mode. Prevents this message:
        # QCoreApplication::exec: The event loop is already running
    plt.show()</t>
<t tx="ekr.20180319044254.14">def data_gen(t=0):
    cnt = 0
    while cnt &lt; 1000:
        cnt += 1
        t += 0.1
        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)
</t>
<t tx="ekr.20180319044254.15">def init():
    ax.set_ylim(-1.1, 1.1)
    ax.set_xlim(0, 10)
    del xdata[:]
    del ydata[:]
    line.set_data(xdata, ydata)
    return line,
</t>
<t tx="ekr.20180319044254.16">def run(data):
    # update the data
    t, y = data
    xdata.append(t)
    ydata.append(y)
    xmin, xmax = ax.get_xlim()
    if t &gt;= xmax:
        ax.set_xlim(xmin, 2*xmax)
        ax.figure.canvas.draw()
    line.set_data(xdata, ydata)
    return line,</t>
<t tx="ekr.20180319044254.17"># http://matplotlib.org/1.5.1/examples/animation/basic_example.html
if 0:
    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib.animation as animation

@others

if 0:
    plt.ion()
    # sets interactive mode. Prevents this message:
    # QCoreApplication::exec: The event loop is already running
plt.show()</t>
<t tx="ekr.20180319044254.18">if 1:
    
    def update_line(num, data, line):
        line.set_data(data[..., :num])
        return line, # a tuple.

    fig1 = plt.figure()
    data = np.random.rand(2, 25)
    l, = plt.plot([], [], 'r-')
    plt.xlim(0, 1)
    plt.ylim(0, 1)
    plt.xlabel('x')
    plt.title('test')
    line_ani = animation.FuncAnimation(fig1, update_line, 25,
        fargs=(data, l),
        interval=50,
        blit=True)
</t>
<t tx="ekr.20180319044254.19">fig2 = plt.figure()
x = np.arange(-9, 10)
y = np.arange(-9, 10).reshape(-1, 1)
base = np.hypot(x, y)
ims = []
for add in np.arange(15):
    ims.append((plt.pcolor(x, y, base + add, norm=plt.Normalize(0, 30)),))
animation.ArtistAnimation(fig2, ims,
    interval=50,
    repeat_delay=3000,
    blit=True)
#im_ani.save('im.mp4', metadata={'artist':'Guido'})</t>
<t tx="ekr.20180319044254.2">@language python

def spam():
    '''This is a docstring.'''
    pass</t>
<t tx="ekr.20180319044254.20">#!/usr/bin/env python
# a bar plot with errorbars
import numpy as np
import matplotlib.pyplot as plt

N = 5
menMeans = (20, 35, 30, 35, 27)
menStd = (2, 3, 4, 1, 2)

ind = np.arange(N)  # the x locations for the groups
width = 0.35       # the width of the bars

fig, ax = plt.subplots()

rects1 = ax.bar(ind, menMeans, width, color='r', yerr=menStd)

womenMeans = (25, 32, 34, 20, 25)
womenStd = (3, 5, 2, 3, 3)
rects2 = ax.bar(ind + width, womenMeans, width, color='y', yerr=womenStd)

# add some text for labels, title and axes ticks
ax.set_ylabel('Scores')
ax.set_title('Scores by group and gender')
ax.set_xticks(ind + width)
ax.set_xticklabels(('G1', 'G2', 'G3', 'G4', 'G5'))

ax.legend((rects1[0], rects2[0]), ('Men', 'Women'))


def autolabel(rects):
    # attach some text labels
    for rect in rects:
        height = rect.get_height()
        ax.text(rect.get_x() + rect.get_width()/2., 1.05*height,
                '%d' % int(height),
                ha='center', va='bottom')

autolabel(rects1)
autolabel(rects2)

plt.ion()
    # sets interactive mode. Prevents this message:
    # QCoreApplication::exec: The event loop is already running
plt.show()</t>
<t tx="ekr.20180319044254.21">@nocolor-node
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd"&gt;
&lt;svg width="20cm" height="15cm" viewBox="0 0 800 600"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlik/"
     baseProfile="tiny" version="1.2"&gt;
   &lt;title&gt;Spheres&lt;/title&gt;
   &lt;desc&gt;Semi-transparent bubbles on a colored background.&lt;/desc&gt;
     &lt;defs&gt;
       &lt;!-- Create radial gradients for each bubble. --&gt;
       &lt;radialGradient id="blueBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#cdcdff" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#cdaacd" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="redBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#ffcdcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#bbbb99" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="greenBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#cdffcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#99aaaa" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="yellowBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#ffffcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#bbbbaa" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="background" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="400" fx="250" fy="250"&gt;
         &lt;stop offset="0%" stop-color="#ffffee" /&gt;
         &lt;stop offset="100%" stop-color="#ccccaa" /&gt;
       &lt;/radialGradient&gt;
       &lt;linearGradient id="surface" gradientUnits="userSpaceOnUse"
                       x1="-100" y1="200" x2="400" y2="200"&gt;
         &lt;stop offset="0%" stop-color="#ffffcc" /&gt;
         &lt;stop offset="100%" stop-color="#bbbb88" /&gt;
       &lt;/linearGradient&gt;

       &lt;!-- Create radial gradients for each circle to make them look like
            spheres. --&gt;
       &lt;radialGradient id="blueSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="blue" /&gt;
         &lt;stop offset="100%" stop-color="#222244" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="redSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="red" /&gt;
         &lt;stop offset="100%" stop-color="#442222" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="greenSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="green" /&gt;
         &lt;stop offset="100%" stop-color="#113311" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="yellowSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="yellow" /&gt;
         &lt;stop offset="100%" stop-color="#444422" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="shadowGrad" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="50"&gt;
         &lt;stop offset="0%" stop-color="black" stop-opacity="1.0" /&gt;
         &lt;stop offset="100%" stop-color="black" stop-opacity="0.0" /&gt;
       &lt;/radialGradient&gt;

       &lt;!-- Define a shadow for each sphere. --&gt;
       &lt;circle id="shadow" fill="url(#shadowGrad)" cx="0" cy="0" r="100" /&gt;
       &lt;g id="bubble"&gt;
         &lt;circle fill="black" cx="0" cy="0" r="50" /&gt;
         &lt;circle fill="#a6ce39" cx="0" cy="0" r="33" /&gt;
         &lt;path fill="black" d="M 37,50 L 50,37 L 12,-1 L 22,-11 L 10,-24 L -24,10
                               L -11,22 L -1,12 Z" /&gt;
         &lt;circle cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/defs&gt;
   &lt;g&gt;
     &lt;rect fill="url(#background)" x="0" y="0" width="800" height="600" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(200,700)"&gt;
     &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="10s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(315,700)"&gt;
     &lt;g transform="scale(0.5,0.5)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="7s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(80,700)"&gt;
     &lt;g transform="scale(0.65,0.65)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="5s" dur="9s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(255,700)"&gt;
     &lt;g transform="scale(0.3,0.3)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="2s" dur="6s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(565,700)"&gt;
     &lt;g transform="scale(0.4,0.4)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="4s" dur="8s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(715,700)"&gt;
     &lt;g transform="scale(0.6,0.6)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="4s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(645,700)"&gt;
     &lt;g transform="scale(0.375,0.375)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="0s" dur="11s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(555,700)"&gt;
     &lt;g transform="scale(0.9,0.9)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="7.5s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(360,700)"&gt;
     &lt;g transform="scale(0.5,0.5)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="6s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(215,700)"&gt;
     &lt;g transform="scale(0.45,0.45)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="5.5s" dur="7s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(420,700)"&gt;
     &lt;g transform="scale(0.75,0.75)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="9s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(815,700)"&gt;
     &lt;g transform="scale(0.6,0.6)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="2s" dur="9.5s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(225,375)" &gt;
     &lt;g transform="scale(1.0,0.5)" &gt;
       &lt;path d="M 0 0 L 350 0 L 450 450 L -100 450 z"
             fill="url(#surface)" stroke="none" /&gt;
     &lt;/g&gt;
   &lt;/g&gt;
     &lt;g transform="translate(200,0)" &gt;
     &lt;g transform="translate(200,490) scale(2.0,1.0) rotate(45)" &gt;
       &lt;rect fill="#a6ce39" x="-69" y="-69" width="138" height="138" /&gt;
       &lt;circle fill="black" cx="0" cy="0" r="50" /&gt;
       &lt;circle fill="#a6ce39" cx="0" cy="0" r="33" /&gt;
       &lt;path fill="black" d="M 37,50 L 50,37 L 12,-1 L 22,-11 L 10,-24 L -24,10
                             L -11,22 L -1,12 Z" /&gt;
       &lt;animateTransform attributeName="transform"  type="rotate" additive="sum" values="0; 360"
                  begin="0s" dur="10s" fill="freeze" repeatCount="indefinite" /&gt;
     &lt;/g&gt;
     &lt;g transform="translate(200,375)"&gt;
       &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
       &lt;circle fill="url(#blueSphere)" cx="0" cy="0" r="100" /&gt;
     &lt;/g&gt;
     &lt;g transform="translate(315,440)"&gt;
       &lt;g transform="scale(0.5,0.5)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#redSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
     &lt;g transform="translate(80,475)"&gt;
       &lt;g transform="scale(0.65,0.65)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#greenSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
     &lt;g transform="translate(255,525)"&gt;
       &lt;g transform="scale(0.3,0.3)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#yellowSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
   &lt;/g&gt;
&lt;/svg&gt;</t>
<t tx="ekr.20180319044254.22">c:\leo.repo\leo-editor\leo\Icons\bubbles.svg
</t>
<t tx="ekr.20180319044254.23">[Leo's home page](http://leoeditor.com/)
</t>
<t tx="ekr.20180319044254.24">@language md
@wrap

[Leo's home page](http://leoeditor.com/)
</t>
<t tx="ekr.20180319044254.25">`Leo's home page &lt;http://leoeditor.com/&gt;`_

</t>
<t tx="ekr.20180319044254.26">@language rest
@wrap

`Leo's home page &lt;http://leoeditor.com/&gt;`_

</t>
<t tx="ekr.20180319044254.27">[weather.com](http://www.weather.com/weather/today/Madison+WI+53705?from=hp_promolocator&amp;lswe=53705&amp;lwsa=Weather36HourHealthCommand)
</t>
<t tx="ekr.20180319044254.28">`weather.com &lt;http://www.weather.com/weather/today/Madison+WI+53705?from=hp_promolocator&amp;lswe=53705&amp;lwsa=Weather36HourHealthCommand&gt;`_
</t>
<t tx="ekr.20180319044254.29">@language rest
@wrap

''' Creates a window for *live* rendering of rst, html, etc.  (Qt only).

Commands
========

viewrendered.py creates the following (``Alt-X``) commands:

``viewrendered``
    opens a new window where the current body text is rendered as HTML
    (if it starts with '&lt;'), or otherwise reStructuredText.
``viewrendered-big``
    as above, but zoomed in, useful for presentations
``viewrendered-html``
    displays the html source generated from reStructuredText, useful for
    debugging

``viewrendered`` sets the process current directory (os.chdir()) to the path
to the node being rendered, to allow relative paths to work in
``.. image::`` directives.

reStructuredText errors and warnings may be shown.  For example, both::

    Heading
    -------

    `This` is **really** a line of text.

and::

    &lt;h1&gt;Heading&lt;h1&gt;

    &lt;tt&gt;This&lt;/tt&gt; is &lt;b&gt;really&lt;/b&gt; a line of text.

will look something like:

**Heading**

`This` is **really** a line of text.

Settings
========

@string view-rendered-default-kind = rst
----------------------------------------

The default kind of rendering.  One of (big,rst,html)
    
@bool view-rendered-auto-create = False
---------------------------------------

When True, the plugin will create a rendering pane automatically.

'''
</t>
<t tx="ekr.20180319044254.3" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e">gs.clear()
gs.addText('\n%s\n%s' % (gv,gs))

if 0:
    for i in range(50):
        gs.addText('\n' * i +'More')
</t>
<t tx="ekr.20180319044254.30">@language md

# Title

This is **bold** and *italics*.

More info at [Leo's home page](&lt;http://leoeditor.com/).

### Section

- Bullet list
- Another item
- Third item.
</t>
<t tx="ekr.20180319044254.31">@language rest

#####
Title
#####

This is **bold** and *italics*.

More info at `Leo's home page &lt;http://leoeditor.com/&gt;`_.

Section
=======

- Bullet list
- Another item
- Third item.</t>
<t tx="ekr.20180319044254.4">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
ul.leo-tree-example  {
    background-color: #ffffec;
    zoom: 150%; # blurs icons a bit.
}
ul.leo-tree-example li {
    background-repeat: no-repeat;
    background-position: 0px 5px;
    padding-left: 27px;
}
li {
    background-image:
url('https://raw.github.com/vivainio/leo/master/leo/Icons/box00.GIF');
    background-repeat: no-repeat;
    background-position: 0px 5px;
    padding-left: 27px;
}
li.selected {
    background-color: lightgrey;
}
li.leaf {
    list-style-type: none;
}
li.plus {
  list-style-image: url('http://leoeditor.com/plusnode.gif')
}
li.minus {
  list-style-image: url('http://leoeditor.com/minusnode.gif')
}
li.leaf {
  background-image: url('http://leoeditor.com/box00.GIF')
}
li.body {
  background-image: url('http://leoeditor.com/box01.GIF')
}
li.mark {
  background-image: url('http://leoeditor.com/box02.GIF')
}
li.mark-body {
  background-image: url('http://leoeditor.com/box03.GIF')
}
li.clone {
  background-image: url('http://leoeditor.com/box04.GIF')
}
li.clone-body {
  background-image: url('http://leoeditor.com/box05.GIF')
}
li.clone-mark {
  background-image: url('http://leoeditor.com/box06.GIF')
}
li.clone-mark-body {
  background-image: url('http://leoeditor.com/box07.GIF')
}
li.dirty {
  background-image: url('http://leoeditor.com/box08.GIF')
}
li.dirty-body {
  background-image: url('http://leoeditor.com/box09.GIF')
}
li.dirty-mark {
  background-image: url('http://leoeditor.com/box10.GIF')
}
li.dirty-mark-body {
  background-image: url('http://leoeditor.com/box11.GIF')
}
li.dirty-clone {
  background-image: url('http://leoeditor.com/box12.GIF')
}
li.dirty-clone-body {
  background-image: url('http://leoeditor.com/box13.GIF')
}
li.dirty-clone-mark {
  background-image: url('http://leoeditor.com/box14.GIF')
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;ul class="leo-tree-example"&gt;
&lt;li class='plus clone-mark'&gt;
test
&lt;/li&gt;
&lt;ul&gt;
  &lt;li class='plus clone-body'&gt;
  child
  &lt;/li&gt;
  &lt;ul&gt;
    &lt;li class='leaf body'&gt;
    grandchild
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;li class='plus clone-body'&gt;
  child
  &lt;/li&gt;
  &lt;ul&gt;
    &lt;li class='leaf body'&gt;
    grandchild
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/ul&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</t>
<t tx="ekr.20180319044254.5">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!--@+leo-ver=5-thin--&gt;
&lt;!--@+node:ekr.20100808060203.4273: * @thin html/front.html--&gt;
&lt;!--@@first--&gt;
&lt;!--@@first--&gt;

&lt;!--@@language html--&gt;
&lt;!--@@tabwidth -2--&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
    &lt;!--@+&lt;&lt; head &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4274: ** &lt;&lt; head &gt;&gt;--&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;

    &lt;title&gt;Leo's Home Page&lt;/title&gt;
    &lt;link rel="stylesheet" href="_static/default.css" type="text/css" /&gt;
    &lt;link rel="stylesheet" href="_static/silver_city.css" type="text/css" /&gt;
    &lt;!--
    &lt;script type="text/javascript"&gt;
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.7-final',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    &lt;/script&gt;
    --&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/jquery.js"&gt;&lt;/script&gt;--&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/doctools.js"&gt;&lt;/script&gt;--&gt;
    &lt;link rel="top" title="Leo v4.7-final documentation" href="index.html" /&gt;
    &lt;link rel="Users Guide" title="Leo&amp;#8217;s Users Guide" href="leo_toc.html" /&gt;
    &lt;!-- &lt;link rel="prev" title="Chapter 5: Using LeoÃ¢â‚¬â„¢s Commands" href="commands.html" /&gt;--&gt; 
    &lt;!--@-&lt;&lt; head &gt;&gt;--&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--@+&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4276: ** &lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             accesskey="I"&gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             accesskey="N"&gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             accesskey="P"&gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt;

      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="document"&gt;
      &lt;div class="documentwrapper"&gt;
        &lt;div class="bodywrapper"&gt;
          &lt;div class="body"&gt;
            &lt;!--@+&lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;!--@+node:ekr.20100808060203.4286: ** &lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;div class="section" id="Leo&amp;#8217;s Home page"&gt;

                &lt;h1&gt;Leo&amp;#8217;s Home Page&lt;/h1&gt;

                Leo is...

                &lt;!--@+&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!--@+node:ekr.20100808060203.4288: *3* &lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;li&gt;
                    An outline-oriented &lt;i&gt;browser&lt;/i&gt; and &lt;i&gt;project manager&lt;/i&gt; that organizes&lt;br&gt;
                    programs, web sites, URL's, pictures, movies or any other kind of data.&lt;br&gt;
                    You can organize your data in as many ways as you like within a &lt;i&gt;single&lt;/i&gt; outline.&lt;/li&gt;
                &lt;li&gt;
                    A &lt;i&gt;programmer's editor&lt;/i&gt; that fully integrates outline structure with programming.
                    &lt;!--
                    &lt;a HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/a&gt; and
                    &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt; markup.&lt;/li&gt;
                    --&gt;
                &lt;li&gt;
                    &lt;i&gt;Fully scriptable&lt;/i&gt; using &lt;a HREF="http://www.python.org/"&gt;Python&lt;/a&gt;.
                    Leo's core is 100% pure Python.&lt;/li&gt;
                &lt;li&gt;
                    &lt;i&gt;Portable&lt;/i&gt;. Leo runs on Windows, Linux and MacOS X.&lt;br&gt;
                    Leo requires either the
                    &lt;a HREF="http://docs.python.org/library/tkinter.html"&gt;Tkinter&lt;/a&gt; or
                    &lt;a HREF="http://www.riverbankcomputing.co.uk/software/pyqt/intro"&gt;PyQt&lt;/a&gt; widget set.&lt;br&gt;
                    Leo's outline files are &lt;a HREF="http://www.w3.org/XML/"&gt;XML&lt;/a&gt; format.&lt;/li&gt;
                &lt;li&gt;
                    &lt;a href="http://www.opensource.org/"&gt;&lt;i&gt;Open Software&lt;/i&gt;&lt;/a&gt;,
                    distributed under the
                    &lt;a href="http://www.opensource.org/licenses/mit-license.php/"&gt;MIT License&lt;/a&gt;.&lt;/li&gt;
                &lt;!--@-&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!-- div body toc --&gt;
                &lt;!-- &lt; &lt; inner sections &gt; &gt; --&gt;

                &lt;p&gt;Leo has an active community of helpful users and developers.&lt;br&gt;
                Please use the &lt;a href="http://groups.google.com/group/leo-editor"&gt;leo-editor&lt;/a&gt;
                group to ask questions and make suggestions.&lt;/p&gt;

                &lt;p&gt;Leo's author is &lt;a HREF="ekr.html"&gt;Edward K. Ream&lt;/a&gt;&lt;/p&gt;

            &lt;/div&gt;
            &lt;!--@-&lt;&lt; div outer section &gt;&gt;--&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@+&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;!--@+node:ekr.20100808060203.4282: ** &lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="sphinxsidebar"&gt;
          &lt;div class="sphinxsidebarwrapper"&gt;
              &lt;!--@+&lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;!--@+node:ekr.20100808060203.4283: *3* &lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;p class="logo"&gt;&lt;a href="leo_toc.html"&gt;
                &lt;img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/&gt;&lt;/a&gt;&lt;/p&gt;

              &lt;a class="reference external" href="intro.html"&gt;
                Read this tutorial first&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;
                Another tutorial&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http:screen-shots.html"&gt;
                Screen shots of Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="testimonials.html"&gt;
                Quotes from Leo&amp;#8217;s Users&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external"
                href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;amp;package_id=29106"&gt;
                Download Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://groups.google.com/group/leo-editor"&gt;
                leo-editor: Google Groups&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://launchpad.net/leo-editor"&gt;
                leo-editor: Launchpad&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://leo.zwiki.org"&gt;
                Leo&amp;#8217;s Wiki&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.mind-mapping.org/"&gt;
                Mind Mapping&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="leoLinks.html"&gt;
                More links...&lt;/a&gt;&lt;br&gt;

              &lt;!-- &lt;a class="reference external"  href="install.html"&gt;Installing Leo&lt;/a&gt;&lt;br&gt;--&gt; 
              &lt;!-- &lt;a class="reference external"  href="intro.html"&gt;Beginners Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="leo_toc.html"&gt;Users Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="FAQ.html"&gt;FAQ&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!--Leo&amp;#8217;s &lt;a class="reference external" href="http://www.greygreen.org/leo/"&gt;Daily snapshots&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- 
              &lt;h5&gt;Edward K. Ream&lt;/h5&gt;
              &lt;a class="reference external" href="ekr.html"&gt;Home&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="mailto:edreamleo@gmail.com"&gt;Contact&lt;/a&gt;&lt;br&gt;
              --&gt; 
              &lt;!--@-&lt;&lt; sidebar contents &gt;&gt;--&gt;
          &lt;!-- &lt; &lt; sidebar links &gt; &gt; --&gt;
          &lt;!-- &lt; &lt; searchbox &gt; &gt; --&gt;
          &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@-&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="clearer"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;!--@+&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4277: ** &lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             &gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             &gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             &gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt; 
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+&lt;&lt; div footer &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4278: ** &lt;&lt; div footer &gt;&gt;--&gt;
    &lt;div class="footer"&gt;
      &amp;copy; Copyright 2010, Edward K. Ream.
      Last updated on Aug 08, 2010.
      Created using &lt;a href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt; 0.6.3.
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div footer &gt;&gt;--&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;!--@-leo--&gt;
</t>
<t tx="ekr.20180319044254.6">C:\leo.repo\leo-editor\leo\Icons\Leosplash.GIF

This is a comment</t>
<t tx="ekr.20180319044254.7">c:\leo.repo\leo-editor\leo\Icons\SplashScreen.ico

</t>
<t tx="ekr.20180319044254.8">C:\Users\edreamleo\Documents\Music\2001- A Space Odyssey [Rhino]\06 Gayane Ballet Suite.mp3</t>
<t tx="ekr.20180319044254.9">https://www.youtube.com/watch?v=EB3IokHelRk

# Doesn't play, probably because of https.</t>
<t tx="ekr.20180325023336.1">def backup_issues(self,
    base_url: str,
    c: Cmdr,
    label_list: list[str],
    root: Position,
    state: str = None,
) -&gt; None:

    self.base_url = base_url
    self.root = root
    self.milestone = None
    if label_list:
        for state in ('closed', 'open'):
            for label in label_list:
                self.get_one_issue(label, state)
    elif state is None:
        for state in ('closed', 'open'):
            organizer = root.insertAsLastChild()
            organizer.h = f"{state} issues..."
            self.get_all_issues(label_list, organizer, state)
    elif state in ('closed', 'open'):
        self.get_all_issues(label_list, root, state)
    else:
        g.es_print('state must be in (None, "open", "closed")')
</t>
<t tx="ekr.20180325024334.1">def get_all_issues(self, label_list: list, root: Position, state: Any, limit: int = 100) -&gt; None:
    """Get all issues for the base url."""
    try:
        import requests
    except Exception:
        g.trace('requests not found: `pip install requests`')
        return
    label = None
    assert state in ('open', 'closed')
    page_url = self.base_url + '?&amp;state=%s&amp;page=%s'
    page, total = 1, 0
    while True:
        url = page_url % (state, page)
        r = requests.get(url, timeout=2.0)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # Do not remove this trace. It's reassuring.
            g.trace(f"done: {done:5} page: {page:3} found: {n} label: {label}")
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page &gt; limit:
            g.trace('too many pages')
            break
</t>
<t tx="ekr.20180325025502.1">def backupGitIssues(c: Cmdr, base_url: str = None) -&gt; None:
    """Get a list of issues from Leo's GitHub site."""
    if base_url is None:
        base_url = 'https://api.github.com/repos/leo-editor/leo-editor/issues'

    root = c.lastTopLevel().insertAfter()
    root.h = f'Backup of issues: {time.strftime("%Y/%m/%d")}'
    label_list: list[str] = []
    GitIssueController().backup_issues(base_url, c, label_list, root)
    root.expand()
    c.selectPosition(root)
    c.redraw()
    g.trace('done')
</t>
<t tx="ekr.20180328170441.1">def caller(i: int = 1) -&gt; str:
    """Return the caller name i levels up the stack."""
    return g.callers(i + 1).split(',')[0]
</t>
<t tx="ekr.20180414195401.2">def __init__(self, binding: str) -&gt; None:

    self.s: str
    if binding:
        self.s = self.finalize_binding(binding)
    else:
        self.s = None
</t>
<t tx="ekr.20180415081209.2">def find_mods(self, s: str) -&gt; list[str]:
    """Return the list of all modifiers seen in s."""
    s = s.lower()
    table = (
        ['alt',],
        ['command', 'cmd',],
        ['ctrl', 'control',],  # Use ctrl, not control.
        ['meta',],
        ['shift', 'shft',],
        # 868: Allow alternative spellings.
        ['keypad', 'key_pad', 'numpad', 'num_pad'],
    )
    result = []
    for aList in table:
        kind = aList[0]
        for mod in aList:
            for suffix in '+-':
                if s.find(mod + suffix) &gt; -1:
                    s = s.replace(mod + suffix, '')
                    result.append(kind)
                    break
    return result
</t>
<t tx="ekr.20180415082249.1">def finalize_binding(self, binding: str) -&gt; str:

    # This trace is good for devs only.
    trace = False and 'keys' in g.app.debug
    self.mods = self.find_mods(binding)
    s = self.strip_mods(binding)
    s = self.finalize_char(s)  # May change self.mods.
    mods = ''.join([f"{z.capitalize()}+" for z in self.mods])
    if trace and 'meta' in self.mods:
        g.trace(f"{binding:20}:{self.mods:&gt;20} ==&gt; {mods+s}")
    return mods + s
</t>
<t tx="ekr.20180415083926.1">def finalize_char(self, s: str) -&gt; str:
    """Perform very-last-minute translations on bindings."""
    #
    # Retain "bigger" spelling for gang-of-four bindings with modifiers.
    shift_d = {
        'bksp': 'BackSpace',
        'backspace': 'BackSpace',
        'backtab': 'Tab',  # The shift mod will convert to 'Shift+Tab',
        'linefeed': 'Return',
        '\r': 'Return',
        'return': 'Return',
        'tab': 'Tab',
    }
    if self.mods and s.lower() in shift_d:
        # Returning '' breaks existing code.
        return shift_d.get(s.lower())
    #
    # Make all other translations...
    #
    # This dict ensures proper capitalization.
    # It also translates legacy Tk binding names to ascii chars.
    translate_d = {
        #
        # The gang of four...
        'bksp': 'BackSpace',
        'backspace': 'BackSpace',
        'backtab': 'Tab',  # The shift mod will convert to 'Shift+Tab',
        'linefeed': '\n',
        '\r': '\n',
        'return': '\n',
        'tab': 'Tab',
        #
        # Special chars...
        'delete': 'Delete',
        'down': 'Down',
        'end': 'End',
        'enter': 'Enter',
        'escape': 'Escape',
        'home': 'Home',
        'insert': 'Insert',
        'left': 'Left',
        'next': 'Next',
        'prior': 'Prior',
        'right': 'Right',
        'up': 'Up',
        #
        # Qt key names...
        'del': 'Delete',
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ins': 'Insert',
        'ltarrow': 'Left',
        'pagedn': 'Next',
        'pageup': 'Prior',
        'pgdown': 'Next',
        'pgup': 'Prior',
        'rtarrow': 'Right',
        'uparrow': 'Up',
        #
        # Legacy Tk binding names...
        "ampersand": "&amp;",
        "asciicircum": "^",
        "asciitilde": "~",
        "asterisk": "*",
        "at": "@",
        "backslash": "\\",
        "bar": "|",
        "braceleft": "{",
        "braceright": "}",
        "bracketleft": "[",
        "bracketright": "]",
        "colon": ":",
        "comma": ",",
        "dollar": "$",
        "equal": "=",
        "exclam": "!",
        "greater": "&gt;",
        "less": "&lt;",
        "minus": "-",
        "numbersign": "#",
        "quotedbl": '"',
        "quoteright": "'",
        "parenleft": "(",
        "parenright": ")",
        "percent": "%",
        "period": ".",
        "plus": "+",
        "question": "?",
        "quoteleft": "`",
        "semicolon": ";",
        "slash": "/",
        "space": " ",
        "underscore": "_",
    }
    #
    # pylint: disable=undefined-loop-variable
        # Looks like a pylint bug.
    if s in (None, 'none', 'None'):
        return 'None'
    if s.lower() in translate_d:
        s = translate_d.get(s.lower())
        return self.strip_shift(s)  # type:ignore
    if len(s) &gt; 1 and s.find(' ') &gt; -1:
        # #917: not a pure, but should be ignored.
        return ''
    if s.isalpha():
        if len(s) == 1:
            if 'shift' in self.mods:
                if len(self.mods) == 1:
                    self.mods.remove('shift')
                    s = s.upper()
                else:
                    s = s.lower()
            elif self.mods:
                s = s.lower()
        else:
            # 917: Ignore multi-byte alphas not in the table.
            s = ''
            if 0:
                # Make sure all special chars are in translate_d.
                if g.app.gui:  # It may not exist yet.
                    if s.capitalize() in g.app.gui.specialChars:
                        s = s.capitalize()
        return s
    #
    # Translate shifted keys to their appropriate alternatives.
    return self.strip_shift(s)
</t>
<t tx="ekr.20180415124853.1">def strip_mods(self, s: str) -&gt; str:
    """Remove all modifiers from s, without changing the case of s."""
    table = (
        'alt',
        'cmd', 'command',
        'control', 'ctrl',
        'keypad', 'key_pad',  # 868:
        'meta',
        'shift', 'shft',
    )
    for mod in table:
        for suffix in '+-':
            target = mod + suffix
            i = s.lower().find(target)
            if i &gt; -1:
                s = s[:i] + s[i + len(target) :]
                break
    return s
</t>
<t tx="ekr.20180415144534.1">def assert_is(obj: Any, list_or_class: Any, warn: bool = True) -&gt; bool:

    if warn:
        ok = isinstance(obj, list_or_class)
        if not ok:
            g.es_print(
                f"can not happen. {obj !r}: "
                f"expected {list_or_class}, "
                f"got: {obj.__class__.__name__}")
            g.es_print(g.callers())
        return ok
    ok = isinstance(obj, list_or_class)
    assert ok, (obj, obj.__class__.__name__, g.callers())
    return ok
</t>
<t tx="ekr.20180417100834.1">def toInsertableChar(self) -&gt; str:
    """Convert self to an (insertable) char."""
    # pylint: disable=len-as-condition
    s = self.s
    if not s or self.find_mods(s):
        return ''
    # Handle the "Gang of Four"
    d = {
        'BackSpace': '\b',
        'LineFeed': '\n',
        # 'Insert': '\n',
        'Return': '\n',
        'Tab': '\t',
    }
    if s in d:
        return d.get(s)
    return s if len(s) == 1 else ''
</t>
<t tx="ekr.20180417101435.1">def isAltCtrl(self) -&gt; bool:
    """Return True if this is an Alt-Ctrl character."""
    mods = self.find_mods(self.s)
    return 'alt' in mods and 'ctrl' in mods
</t>
<t tx="ekr.20180417102341.1">def isPlainKey(self) -&gt; bool:
    """
    Return True if self.s represents a plain key.

    A plain key is a key that can be inserted into text.

    **Note**: The caller is responsible for handling Alt-Ctrl keys.
    """
    s = self.s
    if s in g.app.gui.ignoreChars:
        # For unit tests.
        return False
    # #868:
    if s.find('Keypad+') &gt; -1:
        # Enable bindings.
        return False
    if self.find_mods(s) or self.isFKey():
        return False
    if s in g.app.gui.specialChars:
        return False
    if s == 'BackSpace':
        return False
    return True
</t>
<t tx="ekr.20180417160703.1">def dump(self) -&gt; None:
    """Show results of printable chars."""
    for i in range(128):
        s = chr(i)
        stroke = g.KeyStroke(s)
        if stroke.s != s:
            print(f"{i:2} {s!r:10} {stroke.s!r}")
    for ch in ('backspace', 'linefeed', 'return', 'tab'):
        stroke = g.KeyStroke(ch)
        print(f'{"":2} {ch!r:10} {stroke.s!r}')
</t>
<t tx="ekr.20180419170934.1">def prettyPrint(self) -&gt; str:

    s = self.s
    if not s:
        return '&lt;None&gt;'
    d = {' ': 'Space', '\t': 'Tab', '\n': 'Return', '\r': 'LineFeed'}
    ch = s[-1]
    return s[:-1] + d.get(ch, ch)
</t>
<t tx="ekr.20180420081530.1">def _assert(condition: Any, show_callers: bool = True) -&gt; bool:
    """A safer alternative to a bare assert."""
    if g.unitTesting:
        assert condition
        return True
    ok = bool(condition)
    if ok:
        return True
    g.es_print('\n===== g._assert failed =====\n')
    if show_callers:
        g.es_print(g.callers())
    return False
</t>
<t tx="ekr.20180502104829.1">def strip_shift(self, s: str) -&gt; str:
    """
    Handle supposedly shifted keys.

    User settings might specify an already-shifted key, which is not an error.

    The legacy Tk binding names have already been translated,
    so we don't have to worry about Shift-ampersand, etc.
    """
    #
    # The second entry in each line handles shifting an already-shifted character.
    # That's ok in user settings: the Shift modifier is just removed.
    shift_d = {
        # Top row of keyboard.
        "`": "~", "~": "~",
        "1": "!", "!": "!",
        "2": "@", "@": "@",
        "3": "#", "#": "#",
        "4": "$", "$": "$",
        "5": "%", "%": "%",
        "6": "^", "^": "^",
        "7": "&amp;", "&amp;": "&amp;",
        "8": "*", "*": "*",
        "9": "(", "(": "(",
        "0": ")", ")": ")",
        "-": "_", "_": "_",
        "=": "+", "+": "+",
        # Second row of keyboard.
        "[": "{", "{": "{",
        "]": "}", "}": "}",
        "\\": '|', "|": "|",
        # Third row of keyboard.
        ";": ":", ":": ":",
        "'": '"', '"': '"',
        # Fourth row of keyboard.
        ".": "&lt;", "&lt;": "&lt;",
        ",": "&gt;", "&gt;": "&gt;",
        "//": "?", "?": "?",
    }
    if 'shift' in self.mods and s in shift_d:
        self.mods.remove('shift')
        s = shift_d.get(s)
    return s
</t>
<t tx="ekr.20180511092713.1">def isNumPadKey(self) -&gt; bool:
    return self.s.find('Keypad+') &gt; -1

def isPlainNumPad(self) -&gt; bool:
    return (
        self.isNumPadKey() and
        len(self.s.replace('Keypad+', '')) == 1
    )

def removeNumPadModifier(self) -&gt; None:
    self.s = self.s.replace('Keypad+', '')
</t>
<t tx="ekr.20180528151850.1">def printTimes(times: list) -&gt; None:
    """
    Print the differences in the times array.

    times: an array of times (calls to time.process_time()).
    """
    for n, _junk in enumerate(times[:-1]):
        t = times[n + 1] - times[n]
        if t &gt; 0.1:
            g.trace(f"*** {n} {t:5.4f} sec.")
</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting: str) -&gt; None:
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20190114061452.26">def writeFile(contents: Union[bytes, str], encoding: str, fileName: str) -&gt; bool:
    """Create a file with the given contents."""
    try:
        if isinstance(contents, str):
            contents = g.toEncodedString(contents, encoding=encoding)
        # 'wb' preserves line endings.
        with open(fileName, 'wb') as f:
            f.write(contents)  # type:ignore
        return True
    except Exception as e:
        print(f"exception writing: {fileName}:\n{e}")
        # g.trace(g.callers())
        # g.es_exception()
        return False
</t>
<t tx="ekr.20190327192721.1">def get_files_in_directory(directory: str, kinds: list = None, recursive: bool = True) -&gt; list[str]:
    """
    Return a list of all files of the given file extensions in the directory.
    Default kinds: ['*.py'].
    """
    files: list[str] = []
    sep = os.path.sep
    if not g.os.path.exists(directory):
        g.es_print('does not exist', directory)
        return files
    try:
        if kinds:
            kinds = [z if z.startswith('*') else '*' + z for z in kinds]
        else:
            kinds = ['*.py']
        if recursive:
            # Works for all versions of Python.
            for root, _dirnames, filenames in os.walk(directory):
                for kind in kinds:
                    for filename in fnmatch.filter(filenames, kind):
                        files.append(os.path.join(root, filename))
        else:
            for kind in kinds:
                files.extend(glob.glob(directory + sep + kind))
        return list(set(sorted(files)))
    except Exception:
        g.es_exception()
        return []
</t>
<t tx="ekr.20190330062625.1">def null_object_print_attr(id_: int, attr: str) -&gt; None:
    suppress = True
    suppress_callers: list[str] = []
    suppress_attrs: list[str] = []
    if suppress:
        &lt;&lt; define suppression lists &gt;&gt;
    tag = tracing_tags.get(id_, "&lt;NO TAG&gt;")
    callers = g.callers(3).split(',')
    callers = ','.join(callers[:-1])
    in_callers = any(z in callers for z in suppress_callers)
    s = f"{tag}.{attr}"
    if suppress:
        # Filter traces.
        if not in_callers and s not in suppress_attrs:
            g.pr(f"{s:40} {callers}")
    else:
        # Print each signature once.  No need to filter!
        signature = f"{tag}.{attr}:{callers}"
        if signature not in tracing_signatures:
            tracing_signatures[signature] = True
            g.pr(f"{s:40} {callers}")
</t>
<t tx="ekr.20190330072026.1">suppress_callers = [
    'drawNode', 'drawTopTree', 'drawTree',
    'contractItem', 'getCurrentItem',
    'declutter_node',
    'finishCreate',
    'initAfterLoad',
    'show_tips',
    'writeWaitingLog',
    # 'set_focus', 'show_tips',
]
suppress_attrs = [
    # Leo...
    'c.frame.body.wrapper',
    'c.frame.getIconBar.add',
    'c.frame.log.createTab',
    'c.frame.log.enable',
    'c.frame.log.finishCreate',
    'c.frame.menu.createMenuBar',
    'c.frame.menu.finishCreate',
    # 'c.frame.menu.getMenu',
    'currentItem',
    'dw.leo_master.windowTitle',
    # Pyzo...
    'pyzo.keyMapper.connect',
    'pyzo.keyMapper.keyMappingChanged',
    'pyzo.keyMapper.setShortcut',
]
</t>
<t tx="ekr.20190330072832.1">def null_object_print(id_: int, kind: Any, *args: Any) -&gt; None:
    tag = tracing_tags.get(id_, "&lt;NO TAG&gt;")
    callers = g.callers(3).split(',')
    callers = ','.join(callers[:-1])
    s = f"{kind}.{tag}"
    signature = f"{s}:{callers}"
    if 1:
        # Always print:
        if args:
            args_s = ', '.join([repr(z) for z in args])
            g.pr(f"{s:40} {callers}\n\t\t\targs: {args_s}")
        else:
            g.pr(f"{s:40} {callers}")
    elif signature not in tracing_signatures:
        # Print each signature once.
        tracing_signatures[signature] = True
        g.pr(f"{s:40} {callers}")
</t>
<t tx="ekr.20190428173354.1">def getGitVersion(directory: str = None) -&gt; tuple[str, str, str]:
    """Return a tuple (author, build, date) from the git log, or None."""
    #
    # -n: Get only the last log.
    trace = 'git' in g.app.debug
    try:
        s = subprocess.check_output(
            'git log -n 1 --date=iso',
            cwd=directory or g.app.loadDir,
            stderr=subprocess.DEVNULL,
            shell=True,
        )
    # #1209.
    except subprocess.CalledProcessError as e:
        s = e.output
        if trace:
            g.trace('return code', e.returncode)
            g.trace('value', repr(s))
            g.es_print('Exception in g.getGitVersion')
            g.es_exception()
        s = g.toUnicode(s)
        if not isinstance(s, str):
            return '', '', ''
    except Exception:
        if trace:
            g.es_print('Exception in g.getGitVersion')
            g.es_exception()
        return '', '', ''

    info = [g.toUnicode(z) for z in s.splitlines()]

    def find(kind: str) -&gt; str:
        """Return the given type of log line."""
        for z in info:
            if z.startswith(kind):
                return z.lstrip(kind).lstrip(':').strip()
        return ''

    return find('Author'), find('commit')[:10], find('Date')
</t>
<t tx="ekr.20190503145501.1">def isascii(s: str) -&gt; bool:
    # s.isascii() is defined in Python 3.7.
    return all(ord(ch) &lt; 128 for ch in s)
</t>
<t tx="ekr.20190505052756.1">checkUnicode_dict: dict[str, bool] = {}

def checkUnicode(s: str, encoding: str = None) -&gt; str:
    """
    Warn when converting bytes. Report *all* errors.

    This method is meant to document defensive programming. We don't expect
    these errors, but they might arise as the result of problems in
    user-defined plugins or scripts.
    """
    tag = 'g.checkUnicode'
    if s is None and g.unitTesting:
        return ''
    if isinstance(s, str):
        return s
    if not isinstance(s, bytes):
        g.error(f"{tag}: unexpected argument: {s!r}")
        g.trace('callers:', g.callers())
        return ''
    #
    # Report the unexpected conversion.
    callers = g.callers(1)
    if callers not in checkUnicode_dict:
        g.error(f"\n{tag}: expected unicode. got: {s!r}\n")
        g.trace(g.callers())
        checkUnicode_dict[callers] = True
    #
    # Convert to unicode, reporting all errors.
    if not encoding:
        encoding = 'utf-8'
    try:
        s = s.decode(encoding, 'strict')
    except(UnicodeDecodeError, UnicodeError):  # noqa
        # https://wiki.python.org/moin/UnicodeDecodeError
        s = s.decode(encoding, 'replace')
        g.trace(g.callers())
        g.error(f"{tag}: unicode error. encoding: {encoding!r}, s:\n{s!r}")
    except Exception:
        g.trace(g.callers())
        g.es_exception()
        g.error(f"{tag}: unexpected error! encoding: {encoding!r}, s:\n{s!r}")
    return s
</t>
<t tx="ekr.20190608090856.1">def es_clickable_link(c: Cmdr, p: Position, line_number: int, message: str) -&gt; None:
    """
    Write a clickable message to the given line number of p.b.

    Negative line numbers indicate global lines.

    """
    # Not used in Leo's core.
    unl = p.get_UNL()
    c.frame.log.put(message.strip() + '\n', nodeLink=f"{unl}::{line_number}")
</t>
<t tx="ekr.20190903181030.1">def get_setting(self, key: str) -&gt; Any:
    """Return the canonical setting name."""
    key = key.replace('-', '').replace('_', '')
    gs = self.get(key)
    val = gs and gs.val
    return val

def get_string_setting(self, key: str) -&gt; Optional[str]:
    val = self.get_setting(key)
    return val if val and isinstance(val, str) else None
</t>
<t tx="ekr.20190904052828.1">def add_to_list(self, key: str, val: Any) -&gt; None:
    """Update the *list*, self.d [key]"""
    if key is None:
        g.trace('TypeDict: None is not a valid key', g.callers())
        return
    aList = self.get(key, [])
    if val not in aList:
        aList.append(val)
        self[key] = aList
</t>
<t tx="ekr.20190904103552.1">def name(self) -&gt; str:
    return self._name

def setName(self, name: str) -&gt; None:
    self._name = name
</t>
<t tx="ekr.20191013145307.1">class TkIDDialog(EmergencyDialog):
    """A class that creates an tkinter dialog to get the Leo ID."""

    message = (
        "leoID.txt not found\n\n"
        "Please enter an id that identifies you uniquely.\n"
        "Your git/cvs/bzr login name is a good choice.\n\n"
        "Leo uses this id to uniquely identify nodes.\n\n"
        "Your id should contain only letters and numbers\n"
        "and must be at least 3 characters in length.")

    title = 'Enter Leo id'

    def __init__(self) -&gt; None:
        super().__init__(self.title, self.message)
        self.val = ''

    @others
</t>
<t tx="ekr.20191013145710.1">def onKey(self, event: Any) -&gt; None:
    """Handle Key events in askOk dialogs."""
    if event.char in '\n\r':
        self.okButton()
</t>
<t tx="ekr.20191013145757.1">def createTopFrame(self) -&gt; None:
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    self.root = Tk.Tk()  # type:ignore
    self.top = Tk.Toplevel(self.root)  # type:ignore
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)  # type:ignore
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=self.message, bg='white')
    label.pack(pady=10)
    self.entry = Tk.Entry(self.frame)
    self.entry.pack()
    self.entry.focus_set()
</t>
<t tx="ekr.20191013150158.1">def okButton(self) -&gt; None:
    """Do default click action in ok button."""
    self.val = self.entry.get()  # Return is not possible.
    self.top.destroy()
    self.top = None
</t>
<t tx="ekr.20191220044128.1">def import_module(name: str, package: str = None) -&gt; Any:
    """
    A thin wrapper over importlib.import_module.
    """
    trace = 'plugins' in g.app.debug and not g.unitTesting
    exceptions = []
    try:
        m = importlib.import_module(name, package=package)
    except Exception as e:
        m = None
        if trace:
            t, v, tb = sys.exc_info()
            del tb  # don't need the traceback
            # In case v is empty, we'll at least have the exception type
            v = v or str(t)  # type:ignore
            if v not in exceptions:
                exceptions.append(v)
                g.trace(f"Can not import {name}: {e}")
    return m
</t>
<t tx="ekr.20200219071828.1">class TestLeoGlobals(unittest.TestCase):
    """Tests for leoGlobals.py."""
    @others
</t>
<t tx="ekr.20200219071958.1">def test_comment_delims_from_extension(self) -&gt; None:

    # pylint: disable=import-self
    from leo.core import leoGlobals as leo_g
    from leo.core import leoApp
    leo_g.app = leoApp.LeoApp()
    assert leo_g.comment_delims_from_extension(".py") == ('#', '', '')
    assert leo_g.comment_delims_from_extension(".c") == ('//', '/*', '*/')
    assert leo_g.comment_delims_from_extension(".html") == ('', '&lt;!--', '--&gt;')
</t>
<t tx="ekr.20200219072957.1">def test_is_sentinel(self) -&gt; None:

    # pylint: disable=import-self
    from leo.core import leoGlobals as leo_g
    # Python. Test regular and blackened sentinels.
    py_delims = leo_g.comment_delims_from_extension('.py')
    assert leo_g.is_sentinel("#@+node", py_delims)
    assert leo_g.is_sentinel("# @+node", py_delims)
    assert not leo_g.is_sentinel("#comment", py_delims)
    assert not leo_g.is_sentinel("# comment", py_delims)
    # C.
    c_delims = leo_g.comment_delims_from_extension('.c')
    assert leo_g.is_sentinel("//@+node", c_delims)
    assert not g.is_sentinel("//comment", c_delims)
    # Html.
    html_delims = leo_g.comment_delims_from_extension('.html')
    assert leo_g.is_sentinel("&lt;!--@+node--&gt;", html_delims)
    assert not leo_g.is_sentinel("&lt;!--comment--&gt;", html_delims)
</t>
<t tx="ekr.20200521075143.1">def inAtNosearch(p: Position) -&gt; bool:
    """Return True if p or p's ancestors contain an @nosearch directive."""
    if not p:
        return False  # #2288.
    for p in p.self_and_parents():
        if p.is_at_ignore() or re.search(r'(^@|\n@)nosearch\b', p.b):
            return True
    return False
</t>
<t tx="ekr.20200724132432.1">def gitInfoForFile(filename: str) -&gt; tuple[str, str]:
    """
    Return the git (branch, commit) info associated for the given file.
    """
    # g.gitInfo and g.gitHeadPath now do all the work.
    return g.gitInfo(filename)
</t>
<t tx="ekr.20200724133754.1">def gitInfoForOutline(c: Cmdr) -&gt; tuple[str, str]:
    """
    Return the git (branch, commit) info associated for commander c.
    """
    return g.gitInfoForFile(c.fileName())
</t>
<t tx="ekr.20200810074755.1">def isValidLanguage(language: str) -&gt; bool:
    """True if the given language may be used as an external file."""
    return bool(language and language in g.app.language_delims_dict)
</t>
<t tx="ekr.20200810093517.1"># Regex used by this module, and in leoColorizer.py.
g_language_pat = re.compile(r'^@language\s+(\w+)+', re.MULTILINE)

# g_is_directive_pattern excludes @encoding.whatever and @encoding(whatever)
# It must allow @language python, @nocolor-node, etc.
g_is_directive_pattern = re.compile(r'^\s*@([\w-]+)\s*')
g_tabwidth_pat = re.compile(r'(^@tabwidth)', re.MULTILINE)

# #2267: Support for @section-delims.
g_section_delims_pat = re.compile(r'^@section-delims[ \t]+([^ \w\n\t]+)[ \t]+([^ \w\n\t]+)[ \t]*$')

# Patterns used by the colorizer...

# New in Leo 6.6.4: gnxs must start with 'gnx:'
gnx_char = r"""[^.,"'\s]"""  # LeoApp.cleanLeoID() removes these characters.
gnx_id = fr"{gnx_char}{{3,}}"  # id's must have at least three characters.
gnx_regex = re.compile(fr"\bgnx:{gnx_id}\.[0-9]+\.[0-9]+")

# Unls end with quotes.
unl_regex = re.compile(r"""\bunl:[^`'"]+""")

# Urls end at space or quotes.
url_leadins = 'fghmnptw'
url_kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
url_regex = re.compile(fr"""\b{url_kinds}://[^\s'"]+""")
</t>
<t tx="ekr.20201127143342.1">def see_more_lines(s: str, ins: int, n: int = 4) -&gt; int:
    """
    Extend index i within string s to include n more lines.
    """
    # Show more lines, if they exist.
    if n &gt; 0:
        for _z in range(n):
            if ins &gt;= len(s):
                break
            i, j = g.getLine(s, ins)
            ins = j
    return max(0, min(ins, len(s)))
</t>
<t tx="ekr.20201211182659.1">def standard_timestamp() -&gt; str:
    """Return a reasonable timestamp."""
    return time.strftime("%Y%m%d-%H%M%S")
</t>
<t tx="ekr.20201211182722.1"></t>
<t tx="ekr.20201211183100.1">def get_backup_path(sub_directory: str) -&gt; Optional[str]:
    """
    Return the full path to the subdirectory of the main backup directory.

    The main backup directory is computed as follows:

    1. os.environ['LEO_BACKUP']
    2. ~/Backup
    """
    # Compute the main backup directory.
    # First, try the LEO_BACKUP directory.
    backup = None
    try:
        backup = os.environ['LEO_BACKUP']
        if not os.path.exists(backup):
            backup = None
    except KeyError:
        pass
    except Exception:
        g.es_exception()
    # Second, try ~/Backup.
    if not backup:
        backup = os.path.join(str(Path.home()), 'Backup')
        if not os.path.exists(backup):
            backup = None
    if not backup:
        return None
    # Compute the path to backup/sub_directory
    directory = os.path.join(backup, sub_directory)
    return directory if os.path.exists(directory) else None
</t>
<t tx="ekr.20210303123423.1">def findNodeInChildren(c: Cmdr, p: Position, headline: str, exact: bool = True) -&gt; Optional[Position]:
    """Search for a node in v's tree matching the given headline."""
    p1 = p.copy()
    h = headline.strip()
    for p in p1.children():
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in p1.children():
            if p.h.strip().startswith(h):
                return p.copy()
    return None
</t>
<t tx="ekr.20210303123423.2">def findNodeInTree(c: Cmdr, p: Position, headline: str, exact: bool = True) -&gt; Optional[Position]:
    """Search for a node in v's tree matching the given headline."""
    h = headline.strip()
    p1 = p.copy()
    for p in p1.subtree():
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in p1.subtree():
            if p.h.strip().startswith(h):
                return p.copy()
    return None
</t>
<t tx="ekr.20210303123423.3">def findNodeAnywhere(c: Cmdr, headline: str, exact: bool = True) -&gt; Optional[Position]:
    h = headline.strip()
    for p in c.all_unique_positions(copy=False):
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in c.all_unique_positions(copy=False):
            if p.h.strip().startswith(h):
                return p.copy()
    return None
</t>
<t tx="ekr.20210303123423.4">def findTopLevelNode(c: Cmdr, headline: str, exact: bool = True) -&gt; Optional[Position]:
    h = headline.strip()
    for p in c.rootPosition().self_and_siblings(copy=False):
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in c.rootPosition().self_and_siblings(copy=False):
            if p.h.strip().startswith(h):
                return p.copy()
    return None
</t>
<t tx="ekr.20210303123525.1">def findNodeByPath(c: Cmdr, path: str) -&gt; Optional[Position]:
    """Return the first @&lt;file&gt; node in Cmdr c whose path is given."""
    if not os.path.isabs(path):  # #2049. Only absolute paths could possibly work.
        g.trace(f"path not absolute: {repr(path)}")
        return None
    path = g.os_path_normpath(path)  # #2049. Do *not* use os.path.normpath.
    for p in c.all_positions():
        if p.isAnyAtFileNode():
            # #2049. Do *not* use os.path.normpath.
            if path == g.os_path_normpath(c.fullPath(p)):
                return p
    return None
</t>
<t tx="ekr.20210307060731.1">def createHiddenCommander(fn: str) -&gt; Cmdr:
    """Read the file into a hidden commander (Similar to g.openWithFileName)."""
    from leo.core.leoCommands import Commands
    c = Commands(fn, gui=g.app.nullGui)
    theFile = g.app.loadManager.openAnyLeoFile(fn)
    if theFile:
        c.fileCommands.openLeoFile(theFile, fn, readAtFileNodesFlag=True, silent=True)
        return c
    return None
</t>
<t tx="ekr.20210901065224.1">def run_unit_tests(tests: str = None, verbose: bool = False) -&gt; None:
    """
    Run the unit tests given by the "tests" string.

    Run *all* unit tests if "tests" is not given.
    """
    if 'site-packages' in __file__:
        # Add site-packages to sys.path.
        parent_dir = os.path.normpath(os.path.join(g.app.loadDir, '..', '..'))
        if parent_dir.endswith('site-packages'):
            if parent_dir not in sys.path:
                g.trace(f"Append {parent_dir!r} to sys.path")
                sys.path.insert(0, parent_dir)
        else:
            g.trace('Can not happen: wrong parent directory', parent_dir)
            return
        # Run tests in site-packages/leo
        os.chdir(os.path.normpath(os.path.join(g.app.loadDir, '..')))
    else:
        # Run tests in leo-editor.
        os.chdir(os.path.normpath(os.path.join(g.app.loadDir, '..', '..')))
    verbosity = '-v' if verbose else ''
    command = f"{sys.executable} -m unittest {verbosity} {tests or ''} "
    g.execute_shell_commands(command)
</t>
<t tx="ekr.20210901071523.1">def run_coverage_tests(module: str = '', filename: str = '') -&gt; None:
    """
    Run the coverage tests given by the module and filename strings.
    """
    unittests_dir = g.finalize_join(g.app.loadDir, '..', 'unittests')
    assert os.path.exists(unittests_dir)
    os.chdir(unittests_dir)
    prefix = r"python -m pytest --cov-report html --cov-report term-missing --cov "
    command = f"{prefix} {module} {filename}"
    g.execute_shell_commands(command)
</t>
<t tx="ekr.20210904114446.1">def dump_tree(c: Cmdr, dump_body: bool = False, msg: str = None) -&gt; None:
    if msg:
        print(msg.rstrip())
    else:
        print('')
    for p in c.all_positions():
        print(f"clone? {int(p.isCloned())} {' '*p.level()} {p.h}")
        if dump_body:
            for z in g.splitLines(p.b):
                print(z.rstrip())

def tree_to_string(c: Cmdr, dump_body: bool = False, msg: str = None) -&gt; str:
    result = ['\n']
    if msg:
        result.append(msg)
    for p in c.all_positions():
        result.append(f"clone? {int(p.isCloned())} {' '*p.level()} {p.h}")
        if dump_body:
            for z in g.splitLines(p.b):
                result.append(z.rstrip())
    return '\n'.join(result)
</t>
<t tx="ekr.20211029090118.1">def findAncestorVnodeByPredicate(p: Position, v_predicate: Any) -&gt; Optional[VNode]:
    """
    Return first ancestor vnode matching the predicate.

    The predicate must must be a function of a single vnode argument.
    """
    if not p:
        return None
    # First, look up the tree.
    for p2 in p.self_and_parents():
        if v_predicate(p2.v):
            return p2.v
    # Look at parents of all cloned nodes.
    if not p.isCloned():
        return None
    seen = []  # vnodes that have already been searched.
    parents = p.v.parents[:]  # vnodes to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        if v_predicate(parent_v):
            return parent_v
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    return None
</t>
<t tx="ekr.20220412193109.1"># Most code need only know about the *existence* of these patterns.

# For all *present* patterns, m.group(1) is the filename and m.group(2) is the line number.

# See link_table above LeoLog.put_html_links.

flake8_pat = re.compile(r'(.+?):([0-9]+):[0-9]+:.*$')
mypy_pat = re.compile(r'^(.+?):([0-9]+):\s*(error|note)\s*(.*)\s*$')
pyflakes_pat = re.compile(r'^(.*):([0-9]+):[0-9]+ .*?$')
pylint_pat = re.compile(r'^(.*):\s*([0-9]+)[,:]\s*[0-9]+:.*?\(.*\)\s*$')
python_pat = re.compile(r'^\s*File\s+"(.*?)",\s*line\s*([0-9]+)\s*$')
</t>
<t tx="ekr.20220605141445.1">def put_ret(self, arg: Any, n: int, path: str) -&gt; None:
    """Print arg, the value returned by a "return" statement."""
    indent = ' ' * max(0, n - self.n + 1) if self.indent else ''
    try:
        if isinstance(arg, types.GeneratorType):
            ret = '&lt;generator&gt;'
        elif isinstance(arg, (tuple, list)):
            ret_s = ','.join([self.show(z) for z in arg])
            if len(ret_s) &gt; 40:
                g.printObj(arg, indent=len(indent))
                ret = ''
            else:
                ret = f"[{ret_s}]"
        elif arg:
            ret = self.show(arg)
            if len(ret) &gt; 100:
                ret = f"\n    {ret}"
        else:
            ret = '' if arg is None else repr(arg)
        print(f"{path}:{indent}-{self.full_name} -&gt; {ret}")
    except Exception:
        exctype, value = sys.exc_info()[:2]
        try:  # Be extra careful.
            arg_s = f"arg: {arg!r}"
        except Exception:
            arg_s = ''  # arg.__class__.__name__
        print(
            f"{path}:{indent}-{self.full_name} -&gt; "
            f"{exctype.__name__}, {value} {arg_s}"
        )
</t>
<t tx="ekr.20220704211851.1">for match in g.unl_regex.finditer(line):
    # Don't open if we click after the unl.
    if match.start() &lt;= col &lt; match.end():
        unl = match.group()
        g.handleUnl(unl, c)
        return None
</t>
<t tx="ekr.20220820050145.1">def function_name() -&gt; str:
    """Return the name of function or method that called this function."""
    try:  # get the function name from the call stack.
        f1 = sys._getframe(1)  # The stack frame, one level up.
        code1 = f1.f_code  # The code object
        name = code1.co_name  # The code name
    except Exception:
        name = g.shortFileName(__file__)
    if name == '&lt;module&gt;':
        name = g.shortFileName(__file__)
    if name.endswith('.pyc'):
        name = name[:-1]
    return name
</t>
<t tx="ekr.20220824084642.1">if TYPE_CHECKING:  # pragma: no cover
    from leo.core.leoCommands import Commands as Cmdr
    from leo.core.leoGui import LeoGui
    from leo.core.leoNodes import Position, VNode
    Event = Any
</t>
<t tx="ekr.20230113043029.1">def write_file_if_changed(fn: str, s: str, encoding: str = 'utf-8') -&gt; bool:
    """
    Replace file whose filename is give with s, but *only* if file's
    context has changed (or the file does not exist).

    Return True if the file was written.
    """
    try:
        encoded_s = g.toEncodedString(s, encoding=encoding, reportErrors=True)
        if os.path.exists(fn):
            with open(fn, 'rb') as f:
                contents = f.read()
            if contents == encoded_s:
                return False
        with open(fn, 'wb') as f:
            f.write(encoded_s)
        return True
    except Exception:
        g.es_print(f"Exception writing {fn}")
        g.es_exception()
        return False
</t>
<t tx="ekr.20230128025911.1">def callers(n: int = 4) -&gt; str:
    """
    Return a string containing a comma-separated list of the calling
    function's callers.
    """
    # Be careful to call g._callerName with smaller values of i first:
    # sys._getframe throws ValueError if there are less than i entries.
    i, result = 3, []
    while 1:
        s = _callerName(n=i)
        if s:
            result.append(s)
        if not s or len(result) &gt;= n:
            break
        i += 1
    return ','.join(reversed(result))
</t>
<t tx="ekr.20230128030346.1">def callers_list(n: int = 4) -&gt; list[str]:
    """
    Return a string containing a comma-separated list of the calling
    function's callers.
    """
    # Be careful to call g._callerName with smaller values of i first:
    # sys._getframe throws ValueError if there are less than i entries.
    i, result = 3, []
    while 1:
        s = _callerName(n=i)
        if s:
            result.append(s)
        if not s or len(result) &gt;= n:
            break
        i += 1
    return list(reversed(result))
</t>
<t tx="ekr.20230129093329.1">def get_ctor_name(self: Any, file_name: str, width: int = 25) -&gt; str:
    """
    Return &lt;module-name&gt;.&lt;class-name&gt;:&gt;width.

    self: Any object.
    """
    class_name = self.__class__.__name__
    module_name = shortFileName(file_name).replace(".py", "")
    combined_name = f"{module_name}.{class_name}"
    padding = " " * max(0, 25 - len(combined_name))
    return f"{padding}{combined_name}"
</t>
<t tx="ekr.20230410133838.1">def finalize_join(*args: Any) -&gt; str:
    """
    Join and finalize. Do not call os.path.realpath.

    - Return an empty string if all of the args are empty.
    - Call os.path.expanduser and  os.path.expandvars for each arg.
    - Call os.path.join on the resulting list of expanded arguments.
    - Convert to an absolute path, relative to os.getwd().
    - On Windows, convert backslashes to forward slashes.
    """
    uargs = [z for z in args if z]
    if not uargs:
        return ''
    # Expand everything before joining.
    uargs2 = [os.path.expandvars(os.path.expanduser(z)) for z in uargs]

    # Join the paths.
    path = os.path.join(*uargs2)

    # Convert to an absolute path, similar to os.path.normpath(os.getcwd(), path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)

    # Convert backslashes to forward slashes, regradless of platform.
    path = g.os_path_normslashes(path)
    return path

os_path_finalize_join = finalize_join  # Compatibility.
</t>
<t tx="ekr.20230410134119.1">def finalize(path: str) -&gt; str:
    """
    Finalize the path. Do not call os.path.realpath.

    - Call os.path.expanduser and  os.path.expandvars.
    - Convert to an absolute path, relative to os.getwd().
    - On Windows, convert backslashes to forward slashes.
    """
    if not path:
        return ''
    path = os.path.expanduser(path)
    path = os.path.expandvars(path)

    # Convert to an absolute path, similar to os.path.normpath(os.getcwd(), path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)

    # Convert backslashes to forward slashes, regradless of platform.
    path = g.os_path_normslashes(path)
    return path

os_path_finalize = finalize  # Compatibility.
</t>
<t tx="ekr.20230418102243.1">def os_path_expanduser(path: str) -&gt; str:
    """Wrap both os.path.expanduser and os.path.expandvars."""
    if not path:
        return ''
    path = os.path.expanduser(path)
    path = os.path.expandvars(path)
    path = os.path.normpath(path)
    return path
</t>
<t tx="ekr.20230615034937.1">def check_options(self) -&gt; None:
    """Make sure all command-line options pass sanity checks."""
    option_prefixes = [z[:-1] for z in self.valid_options if z.endswith('=')]
    for arg in sys.argv:
        if arg in self.obsolete_options:
            print(f"Ignoring obsolete option: {arg!r}")
        elif arg.startswith('-'):
            for option in self.valid_options:
                if arg.startswith(option) and not arg.endswith('='):
                    break
            else:
                for prefix in option_prefixes:
                    if arg.startswith(prefix):
                        self.option_error(arg, 'Missing value')
                self.option_error(arg, 'Unknown option')
        else:
            # Do a simple check for file arguments.
            if any(z in arg for z in ',='):
                self.option_error(arg, 'Invalid file arg')
</t>
<t tx="ekr.20230615062610.1">def compute_valid_options(self) -&gt; list[str]:
    """
    Return a list of valid options by parsing the given usage message.
    Options requiring an argument end with '='.
    """
    # Abbreviations (-whatever) must appear before full options (--whatever).
    option_pattern = re.compile(r'\s*(-\w)?,?\s*(--[\w-]+=?)')
    valid = ['-?']
    for line in g.splitLines(self.usage):
        m = option_pattern.match(line)
        if m:
            if m.group(1):
                valid.append(m.group(1))
            if m.group(2):
                valid.append(m.group(2))
    return sorted(list(set(valid)))
</t>
<t tx="ekr.20230615084117.1">def find_complex_option(self, regex: str) -&gt; Optional[re.Match]:
    """
    Check arguments that take an argument.

    Exit if the option exists but contains argument.
    """
    assert '=' in regex, repr(regex)
    prefix = regex.split('=')[0]
    for arg in sys.argv:
        if arg.split('=')[0] == prefix:
            m = re.match(regex, arg)
            if m:
                return m
            self.option_error(arg, 'Missing or erroneous value')
    return None
</t>
<t tx="ekr.20230616075049.1">def option_error(self, arg: str, message: str) -&gt; None:
    """Print an error message and help message, then exit."""
    g.trace(g.callers(6))
    message2 = f"Invalid {arg!r} option: {message}"
    print(message2)
    print(self.usage)
    print(message2)
    sys.exit(1)
</t>
<t tx="ekr.20230616134732.1">class OptionsUtils:
    """
    A stateless class for handling command-line options.

    This class *calculates* valid options from the usage message.
    """

    def __init__(self, usage: str, obsolete_options: list[str] = None) -&gt; None:
        # This class is essentially stateless because these ivars never change.
        self.usage = usage
        self.obsolete_options = obsolete_options
        self.valid_options = self.compute_valid_options()
        self.check_options()

    @others
</t>
<t tx="ekr.20230622112535.1"></t>
<t tx="ekr.20230622112641.1"></t>
<t tx="ekr.20230622112649.1"># These links will be active only if the @&lt;file&gt; node exists.

# Absolute file names

# Exists, non-empty.
C:/Repos/leo-editor/leo/plugins/importers/__init__.py:1:0:flake8 error

# Exists, empty.
C:/Repos/leo-editor/leo/plugins/leo_babel/__init__.py:1:0:flake8 error

# Large.
# C:/Repos/leo-editor/leo/core/leoGlobals.py:100:0:flake8 error
</t>
<t tx="ekr.20230622114548.1"></t>
<t tx="ekr.20230622114556.1">h = 'Error messages (copy to log)'
p = g.findNodeAnywhere(c, h)
if p:
    lines = [z for z in g.splitLines(p.b) if not z.strip().startswith('#')]
    c.frame.log.put_html_links(''.join(lines))
else:
    print('Not found:', h)
</t>
<t tx="ekr.20230623064935.1">convert-unls
copy-test</t>
<t tx="ekr.20230623141357.1">https://github.com/leo-editor/leo-editor/pull/3215/files

# Exists: Recent
unl:gnx:ekr.20180311131424.1

# Error mssages (copy to log)
unl:gnx:ekr.20230622112649.1

# Bad gnx
unl:gnx:xyzzy.20230622112649.1

# Temporty gnx in another file.
unl:gnx:ekr.20230625135805.2
</t>
<t tx="ekr.20230624015529.1">def findGNX(gnx: str, c: Cmdr) -&gt; Optional[Position]:
    """
    Return the position with the given gnx.
    """
    file_pat = re.compile(r'^(.*)::([-\d]+)?$')  # '::' is the separator.
    n: int = None  # The line number.
    m = file_pat.match(gnx)
    if m:
        gnx = m.group(1)
        try:
            n = int(m.group(2))
        except(TypeError, ValueError):
            pass
    g.trace('gnx', gnx, 'n', repr(n))
    # Search c followed by all other open commanders.
    commanders = [c] + [z for z in g.app.commanders() if z != c]
    for c2 in commanders:
        for p in c2.all_unique_positions():
            if p.gnx == gnx:
                if c2 != c:
                    # Switch outlines.
                    g.app.selectLeoWindow(c2)
                    c2.selectPosition(p)
                if n is None:
                    return p
                p2, offset = c2.gotoCommands.find_file_line(-n, p)  # calls c2.redraw.
                return p2 or p
    return None
</t>
<t tx="ekr.20230624100622.1">@language rest
@wrap
@
The code related to clickable links is inherently complex. The goal: create
the *illusion* of simplicity and consistency.

To follow a clickable link, control-click the link.

Clickable links have the following four forms:

1. Error messages produced by flake8, mypy, pyflakes, pylint, python:

   Some of these tools produce clickable links in the log pane when run
   *within* Leo. Some do not.

   When running these tools *outside of* Leo, copying an error message from
   the *console* to Leo's log pane will create clickable links in the log
   pane. Control-clicking these links will select the proper node and line
   provided the outline contains an `@&lt;file&gt;` node for file mentioned in
   the error message.

2. New in Leo 6.7.4: UNLs based on gnx's (global node indices):

   Links of the form `unl:gnx:&lt;gnx&gt;` select the first outline node with the
   given gnx. These UNLs will work as long as the node exists anywhere in
   the outline.

   For example this link: `unl:gnx:ekr.20031218072017.2406` refers to this
   outline's "Code" node. Try it. The link works in this outline.

   The `copy-gnx` command (aka `gnx-show` and `show-gnx`) copies the unl to
   the clipboard and shows the full unl in the status area. Pasting this
   unl to the body pane will create a clickable link.

3. Leo's headline-based UNLs, as shown in the status pane:

   Headline-based UNLs consist of `unl://` followed by a `--&gt;`-separated list of
   headlines. Leo resolves such UNLs by searching for the given headlines.

   *Note*: Prior to Leo 6.7.4, headline-based outlines contained a
   reference to the outline: Like this:

   `unl://` + path + `#` + `--&gt;`-separated list of headlines,

   The legacy (more verbose) forms of headline-based UNLs still work:
   unl://#Code--&gt;About this file
   unl://c:/Repos/leo-editor/leo/core/leoPy.leo#Code--&gt;About this file

   The following example work in this outline:

   An empty file: unl://@clean ../plugins/leo_babel/__init__.py
   The same file, as a gnx: unl:gnx:ekr.20230624114517.1

   The LoadManager class: unl://Code--&gt;Core classes--&gt;@file leoApp.py--&gt;class LoadManager
   The LoadManager class, as a gnx: unl:gnx:ekr.20120209051836.10242

4. Web URLs: file, ftp, gopher, http, https, mailto, news, nntp, prospero, telnet, wais.

   For example, Leo's forum: https://leo-editor.github.io/leo-editor/

=== LeoQtLog.put writes clickable links in the log pane

- **p.get_UNL** `unl:gnx:tbrown.20111010104549.26758` returns a clickable link to p.
- **g.es** `unl:gnx:ekr.20070626132332`
  and **LeoLog.put_html_links** `unl:gnx:ekr.20220410180439.1`
  both call **LeoQtLog.put** `unl:gnx:ekr.20110605121601.18322`.
- LeoQtLog.put generates a clickable html link in the log pane as follows::

    w.insertHtml(f'&lt;a href="{url}" title="{nodeLink}"&gt;{s}&lt;/a&gt;')

=== Leo's syntax colorer makes clickable links in the body pane

See **jedit.match_any_url**: `unl:gnx:ekr.20110605121601.18608`.

=== g.handleUrl `unl:gnx:tbrown.20090219095555.63` handles all clicks.

=== Regular expressions define UNLs and URLs

The section `define global error regexes` `unl:gnx:ekr.20220412193109.1`
defines the format of the error messages each tool produces.

The section `define regex's` `unl:gnx:ekr.20200810093517.1`
defines the format of all other kinds of clickable links.
</t>
<t tx="ekr.20230625084119.1"># Shorter UNL:
unl://#Coloring tests--&gt;Syntax coloring template

# Exists, non-empty.
unl://C:/Repos/leo-editor/leo/test/test.leo#@file ../plugins/importers/__init__.py
unl://#@file ../plugins/importers/__init__.py

# Exists, empty.
unl://C:/Repos/leo-editor/leo/test/test.leo#@clean ../plugins/leo_babel/__init__.py
unl://#@clean ../plugins/leo_babel/__init__.py

# Exists
unl://C:/Repos/leo-editor/leo/test/test.leo#Viewrendered examples
unl://#Viewrendered examples

unl://C:/Repos/leo-editor/leo/test/test.leo#Viewrendered examples--&gt;Python code
unl://#Viewrendered examples--&gt;Python code

# In LeoDocs.leo
unl://LeoDocs.leo#Web pages

# In new outline
unl://root
unl://root--&gt;child 1
unl://root--&gt;child 1--&gt;grandchild 1
</t>
<t tx="ekr.20230626113050.1"></t>
<t tx="ekr.20230626113103.1"></t>
<t tx="ekr.20230626113114.1"></t>
<t tx="ekr.20230626113118.1"></t>
<t tx="ekr.20230627150454.1"># Exists: Recent
unl:gnx://test.leo#ekr.20180311131424.1
unl:gnx://#ekr.20180311131424.1

# Error mssages (copy to log)
unl:gnx://test.leo#ekr.20230622112649.1
unl:gnx://#ekr.20230622112649.1

# These links depend on @data unl-path-prefixes.

# In LeoDocs.leo: Leo 6.7.3 release notes
unl:gnx://LeoDocs.leo#ekr.20230409052507.1

# In LeoDocs.leo: ** Read me first **
unl:gnx://LeoDocs.leo#ekr.20050831195449</t>
<t tx="ekr.20230628090119.1"># These links depend on @data unl-path-prefixes.

unl://LeoDocs.leo#Release Notes--&gt;Leo 6.7.3 release notes</t>
<t tx="maphew.20171112205129.1">def gitDescribe(path: str = None) -&gt; tuple[str, str, str]:
    """
    Return the Git tag, distance-from-tag, and commit hash for the
    associated path. If path is None, use the leo-editor directory.

    Given `git describe` cmd line output: `x-leo-v5.6-55-ge1129da\n`
    This function returns ('x-leo-v5.6', '55', 'e1129da')
    """
    describe = g.execGitCommand('git describe --tags --long', path)
    # rsplit not split, as '-' might be in tag name.
    tag, distance, commit = describe[0].rsplit('-', 2)
    if 'g' in commit[0:]:
        # leading 'g' isn't part of the commit hash.
        commit = commit[1:]
    commit = commit.rstrip()
    return tag, distance, commit
</t>
<t tx="tbrown.20090219095555.63">def handleUrl(url: str, c: Cmdr = None, p: Position = None) -&gt; Any:
    """Open a url or a unl."""
    if c and not p:
        p = c.p
    # These two special cases should match the hacks in jedit.match_any_url.
    if url.endswith('.'):
        url = url[:-1]
    if '(' not in url and url.endswith(')'):
        url = url[:-1]
    # Lower the url.
    urll = url.lower()
    if urll.startswith('@url'):
        url = url[4:].lstrip()
    if (
        urll.startswith(('#', 'unl://', 'unl:gnx:')) or
        urll.startswith('file://') and '--&gt;' in urll
    ):
        return g.handleUnl(url, c)
    try:
        g.handleUrlHelper(url, c, p)
        return urll  # For unit tests.
    except Exception:
        g.es_print("g.handleUrl: exception opening", repr(url))
        g.es_exception()
        return None
</t>
<t tx="tbrown.20180226113621.1">def expand_range(
    self,
    s: str,
    left: int,
    right: int,
    max_right: int,
    expand: bool = False,
) -&gt; tuple[Any, Any, Any, Any]:
    """
    Find the bracket nearest the cursor searching outwards left and right.

    Expand the range (left, right) in string s until either s[left] or
    s[right] is a bracket.  right can not exceed max_right, and if expand is
    True, the new range must encompass the old range, in addition to s[left]
    or s[right] being a bracket.

    Returns
        new_left, new_right, bracket_char, index_of_bracket_char
    if expansion succeeds, otherwise
        None, None, None, None

    Note that only one of new_left and new_right will necessarily be a
    bracket, but index_of_bracket_char will definitely be a bracket.
    """
    expanded: Union[bool, str] = False
    left = max(0, min(left, len(s)))  # #2240
    right = max(0, min(right, len(s)))  # #2240
    orig_left = left
    orig_right = right
    while (
        (s[left] not in self.brackets or expand and not expanded)
        and (s[right] not in self.brackets or expand and not expanded)
        and (left &gt; 0 or right &lt; max_right)
    ):
        expanded = False
        if left &gt; 0:
            left -= 1
            if s[left] in self.brackets:
                other = self.find_matching_bracket(s[left], s, left)
                if other is not None and other &gt;= orig_right:
                    expanded = 'left'
        if right &lt; max_right:
            right += 1
            if s[right] in self.brackets:
                other = self.find_matching_bracket(s[right], s, right)
                if other is not None and other &lt;= orig_left:
                    expanded = 'right'
    if s[left] in self.brackets and (not expand or expanded == 'left'):
        return left, right, s[left], left
    if s[right] in self.brackets and (not expand or expanded == 'right'):
        return left, right, s[right], right
    return None, None, None, None
</t>
<t tx="tom.20220328141455.1"># Navigate to section reference if one was clicked.
l_ = line.strip()
if l_.endswith('&gt;&gt;') and l_.startswith('&lt;&lt;'):
    p = c.p
    px = None
    for p1 in p.subtree():
        if p1.h.strip() == l_:
            px = p1
            break
    if px:
        c.selectPosition(px)
        c.redraw()
    return None
</t>
<t tx="tom.20220328141544.1"># Find the url on the line.
for match in g.url_regex.finditer(line):
    # Don't open if we click after the url.
    if match.start() &lt;= col &lt; match.end():
        url = match.group(0)
        if g.isValidUrl(url):
            break
</t>
<t tx="tom.20220328142302.1">target = None
for match in gnx_regex.finditer(line):
    # Don't open if we click after the gnx.
    if match.start() &lt;= col &lt; match.end():
        target = match.group(0)[4:]  # Strip the leading 'gnx:'
        break

if target:
    found_gnx = False
    if c.p.gnx == target:
        return target
    for p in c.all_unique_positions():
        if p.v.gnx == target:
            found_gnx = True
            break
    if found_gnx:
        c.selectPosition(p)
        c.redraw()
    return target
</t>
<t tx="tom.20230130102836.1"># Part 4: #2546: look for a file name.
s = w.getAllText()
i, j = w.getSelectionRange()
m = re.match(r'(\w+)\.(\w){1,4}\b', s[i:])
filename, filename_w = '', ''
if m:
    filename = m.group(0)
# Part 5: #3112: look for import statement
else:
    FROMre = r'^from [\./\\]*([^\s/\\].+)\s+import'
    IMPORTre = r'^import\s+[\./\\]*([^\s/\\].+)'
    IMPORTSre = FROMre + '|' + IMPORTre

    m = re.match(IMPORTSre, s[i:], re.MULTILINE)
    module = m and (m[2] or m[1])
    if module:
        filename = module + '.py'
        filename_w = module + '.pyw'

if filename:
    # Navigate to the first node whose headline ends with the filename.
    effective_filename = ''
    for p in c.all_unique_positions():
        headline = p.h.strip()
        if headline.endswith(filename):
            effective_filename = filename
        elif filename_w and headline.endswith(filename_w):
            effective_filename = filename_w
        if effective_filename:
            # Set the find text.
            c.findCommands.ftm.set_find_text(effective_filename)
            # Select.
            c.redraw(p)
            break
</t>
<t tx="ville.20090521164644.5924">class Command:
    """
    A global decorator for creating commands.

    This is the recommended way of defining all new commands, including
    commands that could be defined inside a class. The typical usage is:

        @g.command('command-name')
        def A_Command(event):
            c = event.get('c')
            ...

    g can *not* be used anywhere in this class!
    """

    def __init__(self, name: str, **kwargs: Any) -&gt; None:
        """Ctor for command decorator class."""
        self.name = name

    def __call__(self, func: Callable) -&gt; Callable:
        """Register command for all future commanders."""
        global_commands_dict[self.name] = func
        if app:
            for c in app.commanders():
                c.k.registerCommand(self.name, func)
        # Inject ivars for plugins_menu.py.
        func.__func_name__ = func.__name__  # For leoInteg.
        func.is_command = True
        func.command_name = self.name
        return func

command = Command
</t>
<t tx="ville.20090701144325.14942">def guessExternalEditor(c: Cmdr = None) -&gt; Optional[str]:
    """ Return a 'sensible' external editor """
    editor = (
        c and c.config.getString('external-editor') or
        os.environ.get("LEO_EDITOR") or
        os.environ.get("EDITOR") or
        g.app.db and g.app.db.get("LEO_EDITOR")
        )
    if editor:
        return editor
    # fallbacks
    platform = sys.platform.lower()
    if platform.startswith('win'):
        return "notepad"
    if platform.startswith('linux'):
        return 'gedit'
    g.es(
        '''No editor set.
Please set LEO_EDITOR or EDITOR environment variable,
or do g.app.db['LEO_EDITOR'] = "gvim"''',
    )
    return None
</t>
<t tx="ville.20090827174345.9963">class UiTypeException(Exception):
    pass

def assertUi(uitype: Any) -&gt; None:
    if not g.app.gui.guiName() == uitype:
        raise UiTypeException
</t>
<t tx="ville.20120502221057.7500">childrenModifiedSet: set[VNode] = set()
contentModifiedSet: set[VNode] = set()
</t>
<t tx="vitalije.20170714085545.1">def defaultLeoFileExtension(c: Cmdr = None) -&gt; str:
    conf = c.config if c else g.app.config
    return conf.getString('default-leo-extension') or '.leo'
</t>
</tnodes>
</leo_file>
