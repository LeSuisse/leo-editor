
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>History of Leo &#8212; Leo 6.7.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Glossary" href="glossary.html" />
    <link rel="prev" title="Videos about Leo" href="screencasts.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="glossary.html" title="Glossary"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="screencasts.html" title="Videos about Leo"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="leo_toc.html">Leo 6.7.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="toc-more-links.html" accesskey="U">More Leo Links</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">History of Leo</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="history-of-leo">
<h1>History of Leo<a class="headerlink" href="#history-of-leo" title="Permalink to this heading">¶</a></h1>
<p>This chapter discusses the most important milestones in history of Leo and summarizes each of Leo’s public releases.  The focus is on the <em>important</em> and <em>interesting</em> developments.  It is not a chronicle of every change made to Leo.</p>
<p>One of Leo’s most important developments, &#64;button, came directly from e’s dyna_menu plugin. The exact date seems lost, but it certainly existed by Leo 4.3.</p>
<nav class="contents local" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#beginnings" id="id1">1995: Beginnings</a></p></li>
<li><p><a class="reference internal" href="#breakthroughs" id="id2">1996: Breakthroughs</a></p></li>
<li><p><a class="reference internal" href="#apple-and-yellowbox" id="id3">1996-1998: Apple and YellowBox</a></p></li>
<li><p><a class="reference internal" href="#borland-c" id="id4">1999-2001: Borland C++</a></p></li>
<li><p><a class="reference internal" href="#discovering-python" id="id5">2001: Discovering Python</a></p></li>
<li><p><a class="reference internal" href="#putting-sentinel-lines-in-external-files" id="id6">2001: Putting sentinel lines in external files</a></p>
<ul>
<li><p><a class="reference internal" href="#overview" id="id7">Overview</a></p></li>
<li><p><a class="reference internal" href="#first-steps" id="id8">First steps</a></p></li>
<li><p><a class="reference internal" href="#a-prototype-simplified-noweb" id="id9">A prototype: simplified noweb</a></p></li>
<li><p><a class="reference internal" href="#avoiding-error-notifications" id="id10">Avoiding error notifications</a></p></li>
<li><p><a class="reference internal" href="#the-write-code" id="id11">The write code</a></p></li>
<li><p><a class="reference internal" href="#the-read-code" id="id12">The read code</a></p></li>
<li><p><a class="reference internal" href="#the-load-save-code" id="id13">The load/save code</a></p></li>
<li><p><a class="reference internal" href="#attributes-mirroring-and-dummy-nodes" id="id14">Attributes, mirroring and dummy nodes</a></p></li>
<li><p><a class="reference internal" href="#clones" id="id15">Clones</a></p></li>
<li><p><a class="reference internal" href="#error-recovery-at-last" id="id16">Error recovery, at last</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#untangling-file-is-easy" id="id17">2002: Untangling &#64;file is easy!</a></p></li>
<li><p><a class="reference internal" href="#leo-3-x-continuous-improvement" id="id18">2002: Leo 3.x: Continuous improvement</a></p></li>
<li><p><a class="reference internal" href="#sourceforge-new-energy" id="id19">2003: SourceForge: new energy</a></p></li>
<li><p><a class="reference internal" href="#new-read-logic-eliminates-read-errors-eliminated-child-indices" id="id20">2003: 4.0: New read logic eliminates read errors, eliminated child indices</a></p></li>
<li><p><a class="reference internal" href="#the-debut-of-gnx-s" id="id21">2004: 4.1: The debut of gnx’s</a></p></li>
<li><p><a class="reference internal" href="#generators-ua-s-the-end-of-sync-problems-shared-tnodes" id="id22">2004: 4.2: generators, uA’s the end of sync problems, shared tnodes</a></p></li>
<li><p><a class="reference internal" href="#settings-trees-plugins-manager-predefined-c-g-p" id="id23">2005: 4.3: &#64;settings trees, plugins manager, predefined c, g, p</a></p></li>
<li><p><a class="reference internal" href="#the-minibuffer-key-bindings-autocompletion-multiple-log-panes" id="id24">2006: 4.4: The minibuffer, key bindings autocompletion, multiple log panes</a></p></li>
<li><p><a class="reference internal" href="#x-hundreds-of-improvements" id="id25">2006-2008: 4.4.x: Hundreds of improvements</a></p></li>
<li><p><a class="reference internal" href="#qt-gui-edit-auto-rst" id="id26">2009: 4.6: Qt gui, &#64;edit, &#64;auto-rst</a></p></li>
<li><p><a class="reference internal" href="#the-one-node-world-python-3k" id="id27">2010: 4.7: The one node world &amp; Python 3k</a></p></li>
<li><p><a class="reference internal" href="#new-sentinels-recovery-nodes" id="id28">2010: 4.8: New sentinels &amp; recovery nodes</a></p></li>
<li><p><a class="reference internal" href="#the-end-of-tk-autocompleter-vr-pane" id="id29">2011: 4.9: The end of Tk, autocompleter, vr pane</a></p></li>
<li><p><a class="reference internal" href="#vim-mode-plays-well-with-others" id="id30">2014: 5.0 Vim mode, plays well with others</a></p></li>
<li><p><a class="reference internal" href="#clean" id="id31">2015: 5.1 &#64;clean</a></p></li>
<li><p><a class="reference internal" href="#through-5-9-precursors-to-leointeg" id="id32">2016-2018: 5.2 through 5.9: precursors to leoInteg</a></p></li>
<li><p><a class="reference internal" href="#leo-6-0-and-beyond-supporting-leointeg" id="id33">2019-2023: Leo 6.0 and beyond: supporting leoInteg</a></p></li>
</ul>
</nav>
<section id="beginnings">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">1995: Beginnings</a><a class="headerlink" href="#beginnings" title="Permalink to this heading">¶</a></h2>
<p>Leo grew out of my efforts to use Donald Knuth’s “CWEB system of Structured documentation.” I had known of literate programming since the mid 1980’s, but I never understood how to make it work for me. In November 1995 I started thinking about programming in earnest. Over the holidays I mused about making programs more understandable.</p>
</section>
<section id="breakthroughs">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">1996: Breakthroughs</a><a class="headerlink" href="#breakthroughs" title="Permalink to this heading">¶</a></h2>
<p>In January 1996 the fog of confusion suddenly cleared. I summarized my thinking with the phrase, <strong>web are outlines in disguise</strong>. I suspected that outline views were the key to programming, but many details remained obscure.</p>
<p>March 5, 1996, is the most important date in Leo’s history. While returning from a day of skiing, I discussed my thoughts with Rebecca. During that conversation I realized that I could use the MORE outliner as a prototype for a “programming outliner.” I immediately started work on my first outlined program. It quickly became apparent that outlines work: all my old problems with programming vanished. The &#64;others directive dates from this day. I realized that MORE’s outlines could form the basis for Leo’s screen design. Rather than opening body text within the outline, as MORE does, I decided to use a separate body pane.</p>
<p>I hacked a translator called M2C which allowed me to use MORE to write real code. I would write code in MORE, copy the text to the clipboard in MORE format, then run M2C, which would convert the outline into C code. This process was useful, if clumsy. I called the language used in the outline SWEB, for simplified CWEB. Much later Leo started supporting the noweb language.</p>
</section>
<section id="apple-and-yellowbox">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">1996-1998: Apple and YellowBox</a><a class="headerlink" href="#apple-and-yellowbox" title="Permalink to this heading">¶</a></h2>
<p>Throughout 1996 I created a version of Leo on the Macintosh in plain C and the native Mac Toolbox. This was a poor choice; I wasted a huge amount of time programming with these primitive tools. However, this effort convinced me that Leo was a great way to program.</p>
<p>Late in 1997 I wrote a Print command to typeset an outline. Printing (Weaving) is supposedly a key feature of literate programming. Imagine my surprise when I realized that such a “beautiful” program listing was almost unintelligible; all the structure inherent in the outline was lost! I saw clearly that typesetting, no matter how well done, is no substitute for explicit structure.</p>
<p>In 1998 I created a version of Leo using Apple’s YellowBox environment. Alas, Apple broke its promises to Apple developers. I had to start again.</p>
</section>
<section id="borland-c">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">1999-2001: Borland C++</a><a class="headerlink" href="#borland-c" title="Permalink to this heading">¶</a></h2>
<p>In May of 1999 I began work on the Borland version of Leo for Windows. Borland C++ was much better than CodeWarrior C, but it was still C++. Still, the Borland Delphi classes were a pleasure to use and free of bugs. I redesigned Leo’s file format for the Windows version of Leo; the Yellow Box file format was a binary format that requires the Yellow Box runtime.</p>
<p>There are two significant problems with the Borland version of Leo. First, it works only on Windows. Second, it can never be Open software, because it uses Borland’s Delphi classes and a commercial syntax coloring component.</p>
<p>This version of Leo was the first version to use xml as the format of .leo files. Marc-Antoine Parent urged me to use XML and patiently explained how to use XML properly.</p>
</section>
<section id="discovering-python">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">2001: Discovering Python</a><a class="headerlink" href="#discovering-python" title="Permalink to this heading">¶</a></h2>
<p>I attended the Python conference in early 2001. In May of 2000 I began work on a wxWindows version of Leo. The wxWindows project failed in a useful way. While adding python scripting, I became familiar with Python and its internals.</p>
<p>I started to ‘get’ Python in September 2001. In October of 2001 I began work on leo.py, based on Tk. The rewrite took only two months! leo.py 0.05 alpha went out the door on December 17, 2001.</p>
<p>I wrote the white papers around this time. Python solved <em>all</em> my programming problems. I was no longer anxious while programming; it simply isn’t possible to create hard-to-find bugs in Python.</p>
</section>
<section id="putting-sentinel-lines-in-external-files">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">2001: Putting sentinel lines in external files</a><a class="headerlink" href="#putting-sentinel-lines-in-external-files" title="Permalink to this heading">¶</a></h2>
<p>In the summer of 2001 I began to consider using sentinel lines in external files. Previously I had thought that outline structure must be ‘protected’ by remaining inside .leo files. Accepting the possibility that sentinels might be corrupted opened vast new design possibilities. In retrospect, problems with sentinels almost never happen, but that wasn’t obvious at the time! The result of this design was known then as Leo2. That terminology is extinct. I think of this version as the first version to support &#64;file and automatic tangling and untangling.</p>
<section id="overview">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Overview</a><a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h3>
<p>The following sections describe the complexities that were involved in designing Leo’s simple-looking mechanisms. They give a pseudo-chronological list of the major Aha’s involved in creating Leo2. These Aha’s form the real design and theory of operation of Leo.</p>
<p>I am writing these notes for several reasons. First, the initial design and coding of Leo2, spanning a period of about 8 weeks, was some of the most creative and rewarding work I have ever done. The result is elegant and simple. I’m proud of it. Second, much of the design work is not reflected in the code, because improved design often eliminated code entirely. The final code is so elegant that it obscures the hard work that created it. Third, you must understand this design in order to understand the implementation of &#64;file trees and their external files. Someday someone else may take charge of Leo. That person should know what really makes Leo work.</p>
</section>
<section id="first-steps">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">First steps</a><a class="headerlink" href="#first-steps" title="Permalink to this heading">¶</a></h3>
<p>In the summer of 2001 I began work on a project that for a long time I had considered impossible. I had long considered that “private” file formats such as .leo files were the only way to represent an outline properly and safely. I’m not sure what changed my mind, but I finally was willing to consider that information embedded in external files might be useful. This meant accepting the possibility that sentinel lines might be corrupted. This was a crucial first step. If we can trust the user not to corrupt sentinel lines than we can embed almost any kind of information into a external file.</p>
<p>There were several motivations for this work. I wanted to eliminate the need for explicit Tangle and Untangle commands. I thought of this as “Untangle on Read/Tangle on Write.” If tangling and untangling could be made automatic it would save the user a lot of work. I also wanted to make external files the primary sources files. .leo files might be made much smaller external files contained the primary source information. This hope turned out to be false.</p>
<p>The result of this design work was something I originally called Leo2. Now, I prefer to talk about &#64;file trees. Initially most design issues were unresolved or unknown. I resolved to attempt a robust error-recovery scheme, not knowing in advance what that might involve. I also wanted to solve what I thought of as the “cross-file clone” problem: clones that point from a .leo outline into a external file. With Leo1 cross-file clones do not exist; everything is in the same .leo file. It was clear that Leo2 would have to change some aspects of clones, but all details were fuzzy.</p>
</section>
<section id="a-prototype-simplified-noweb">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">A prototype: simplified noweb</a><a class="headerlink" href="#a-prototype-simplified-noweb" title="Permalink to this heading">¶</a></h3>
<p>The next step was also crucial. I started to use Leo1 as a prototype to design what the new body pane would look like to the user. In retrospect, using Leo1 as a prototype for Leo2 was just as inspired as using MORE as a prototype for Leo1. Both prototypes marked the true beginning of their respective projects. The Leo2 prototype was a mockup in Python of the code for reading and writing derived files.</p>
<p>Writing the prototype got me thinking about improving noweb. With my experience with Leo1, I was able to create a new markup language that took advantage of outline structure. I called the new language “simplified noweb”, though that terminology is obsolete. I created &#64;file nodes to distinguish between the old and new ways of creating external files. In Leo1, the &#64;code directive is simply an abbreviation for a section definition line. Simplified noweb used &#64;c as an abbreviation for &#64;code. More importantly, simplified noweb used &#64;c to separate doc parts from code parts without necessarily specifying a section name. It quickly became apparent that most nodes could be unnamed. All I needed was the &#64;others directive to specify the location for all such unnamed nodes.</p>
<p>From the start, simplified noweb was a joy to use. The &#64;others directive could replace all section definition lines. Furthermore, I could make &#64;doc directive optional if the body pane started in “code mode”. But this meant that plain body text could become a program! This was an amazing discovery. These Aha’s got me excited about Leo2. This was important, as it motivated me to do a lot of difficult design work.</p>
</section>
<section id="avoiding-error-notifications">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Avoiding error notifications</a><a class="headerlink" href="#avoiding-error-notifications" title="Permalink to this heading">¶</a></h3>
<p>In spite of this excitement, I was uneasy. After much “daydreaming” I realized that I was afraid that reading and writing external files would be interrupted by a long series of alerts. I saw that designing the “user interaction” during reading and writing would be very important. The next Aha was that I could replace a long series of alerts with messages to the log window, followed by a single “summary” alert. Much later I saw how to eliminate alerts entirely.</p>
<p>At this time I thought there would be two kinds of “errors” while reading external files. Warnings would alert the user that something non-serious had happened. True errors would alert the user that data might have been lost. Indeed, if Leo2 saves orphan and ignored nodes in a .leo file under an &#64;file node, then read errors could endanger such nodes. Much later I saw that a robust error recovery scheme demands that &#64;file nodes not contain orphan and &#64;ignored nodes. (More on this subject later.) But if orphan and &#64;ignored nodes are moved out of &#64;file trees, there are no read errors that can cause data loss! So the distinction between warnings and errors finally went away.</p>
</section>
<section id="the-write-code">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">The write code</a><a class="headerlink" href="#the-write-code" title="Permalink to this heading">¶</a></h3>
<p>I next turned my attention to writing &#64;file nodes. A huge Aha: I realized that sentinel lines must contain both a leading and a trailing newline. The general principle is this: the write code must contain absolutely no “conditional” logic, because otherwise the read code could not figure out whether the condition should be true or false. So external files contain blank lines between sentinel lines. These “extra” newlines are very useful, because the read (untangle) code can now easily determine exactly where every blank, tab and newline of the external file came from. It would be hard to overstate how important this simplifying principle was in practice.</p>
<p>Much later, with urging from a customer, I realized that the write code could safely remove “extra” newlines between sentinels with a caching scheme in the low level atFile::os() routine. This scheme does not alter the body of the write code in any way: in effect, sentinels still contain leading and trailing “logical” newlines. The read code had to be modified to handle “missing” leading newlines, but this can always be done assuming that sentinels still contain logical leading and trailing newlines!</p>
<p>At about this time I designed a clever way of having the write code tell the read code which newlines were inserted in doc parts. (The whole point of doc parts is to have the write code format long comments by splitting long lines.) To quote from my diary:</p>
<p>“We can use the following convention to determine where putDocPart has inserted line breaks: A line in a doc part is followed by an inserted newline if and only if the newline is preceded by whitespace. This is an elegant convention, and is essentially invisible to the user. Tangle outputs words until the line would become too long, and then it inserts a newline. To preserve all whitespace, tangle always includes the whitespace that terminates a word on the same line as the word itself. Therefore, split lines always end in whitespace. To make this convention work, tangle only has to delete the trailing whitespace of all lines that are followed by a ‘real’ newline.”</p>
</section>
<section id="the-read-code">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">The read code</a><a class="headerlink" href="#the-read-code" title="Permalink to this heading">¶</a></h3>
<p>After the write code was working I turned my attention to the read (untangle) code. Leo’s Untangle command is the most complex and difficult code I have ever written. Imagine my surprise when I realized that the Leo2 read code is essentially trivial! Indeed, the Leo2 untangle code is like an assembler. The read code scans lines of a external files looking for “opcodes”, that is, sentinel lines, and executes some simple code for each separate opcode. The heart of this code is the scanText routine in atFile.cpp.</p>
<p>The read code was written and debugged in less than two days! It is the most elegant code I have ever written. While perfecting the read code I realized that sentinel lines should show the complete nesting structure found in the outline, even if this information seems redundant. For example, I was tempted to use a single sentinel to represent an &#64;other directive, but finally abandoned this plan in favor of the &#64;+other and &#64;-other sentinels.</p>
<p>This redundancy greatly simplified the read code and made the structure of external files absolutely clear. Moreover, it turned out that we need, in general, all the information created by the present sentinel lines. In short, sentinels are as simple as they can be, and no simpler.</p>
<p>The atFile::createNthChild method is a very important: it ensures that nodes will be correctly inserted into the outline. createNthChild must be bullet-proof if the Read code is to be robust. Note that the write code outputs &#64;node sentinels, that is, section definitions, in the order in which sections are referenced in the outline, not the order in which sections appear in the outline. So createNthChild must insert the n’th node of parent p properly even if p contains fewer than n-1 children! The write code ensures that section references are properly nested: &#64;node sentinels are enclosed in &#64;node sentinels for all their ancestors in the &#64;file tree. createNthChild creates dummy siblings as needed, then replaces the dummy siblings later when their actual definitions, that is, &#64;node sentinels, are encountered.</p>
<p>At this point the fundamental read/write code was complete. I found three minor bugs in the code over the next week or so, but it was clear that the read/write code formed a rock-solid base from which to continue design and implementation. This was an entirely unexpected surprise.</p>
</section>
<section id="the-load-save-code">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">The load/save code</a><a class="headerlink" href="#the-load-save-code" title="Permalink to this heading">¶</a></h3>
<p>At this point I could read and write external files “by hand”, using temporary Read and Write commands. The next step was to integrate the reading and writing of external files with the loading and saving of .leo files. From time to time I made minor changes to the drivers for the read/write code to accommodate the Load and Save code, but at no time did I significantly alter the read or write code itself.</p>
<p>The user interaction of the Load and Save commands drove the design and implementation of the load/store code. The most important questions were: “what do we tell the user?”, and “what does the user do with the information?” It turns out that the user can’t make any complex decision during error recovery because the user doesn’t have nearly enough information to make an informed choice. In turn, this means that certain kinds of error recovery schemes are out of the question…</p>
</section>
<section id="attributes-mirroring-and-dummy-nodes">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Attributes, mirroring and dummy nodes</a><a class="headerlink" href="#attributes-mirroring-and-dummy-nodes" title="Permalink to this heading">¶</a></h3>
<p>I now turned my attention to “attributes” of nodes. Most attributes, like user marks, are non-essential. However, clone information is essential; we must never lose clone links. At this time I had a preliminary design for cross-file clones that involved a two part “pointer” consisting of a full path name and an immutable clone index within the external file. Eventually such pointers completely disappeared, but the immutable clone indices remain.</p>
<p>My first thought was that it would be good to store all attributes in &#64;node sentinels in the external file, but experience showed that would be irritating. Indeed, one wants Leo2 to rewrite external files only if something essential has changed. For example, one doesn’t want to rewrite the external file just because a different node as been selected.</p>
<p>At this point I had another Aha: we can use the .leo file to store all non-essential attributes. For example, this means that the .leo file, not the external files, will change if we select a new node. In effect, the .leo file mirrors the external file. The only reason to store nodes in the .leo file under an &#64;file node is to carry these attributes, so Leo2 wrote dummy nodes that do not reference body text. Much later I saw that dummy nodes were dangerous and that .leo files should contain all information found in external files.</p>
</section>
<section id="clones">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Clones</a><a class="headerlink" href="#clones" title="Permalink to this heading">¶</a></h3>
<p>The concept of mirroring created a huge breakthrough with cross-file clones: Here is an excerpt of an email i sent to my brother Speed:</p>
<p>“I realized this morning that since a .leo file contains dummy vnodes for all nodes in a external file, those dummy nodes can carry clone info! I changed one line to make sure that the write code always writes clone info in dummy vnodes and voila! Cross-file clones worked!”</p>
<p>All of Leo1’s clone code could be used completely unchanged. Everything “just works”.</p>
</section>
<section id="error-recovery-at-last">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Error recovery, at last</a><a class="headerlink" href="#error-recovery-at-last" title="Permalink to this heading">¶</a></h3>
<p>At first I thought we could make sure that the .leo file always correctly mirrors all external file, but disastrous experience showed that is a completely false hope. Indeed, backup .leo files will almost never mirror external file correctly. So it became urgent to find a completely fool-proof error recovery scheme.</p>
<p>I had known for quite a while that error recovery should work “as if” the mirroring nodes were deleted, then recreated afresh. Several failed attempts at an error recovery scheme convinced me that error recovery would actually have to delete all dummy nodes and then do a complete reread. This is what Leo2 does.</p>
<p>But erasing dummy nodes would destroy any orphan and ignored nodes–by definition such nodes appear nowhere in the external file. Therefore, I had to enforce the rule that &#64;file nodes should contain no such nodes. Here is an email I wrote to my brother, Speed Ream discussing what turned out to be the penultimate error recovery scheme:</p>
<p>“The error recovery saga continues. After much pondering and some trial coding I have changed my mind about orphans and &#64;ignored nodes. They simply should never appear as descendants of &#64;file nodes. Fortunately, this simplifies all aspects of Leo2. Leo2 will issue a warning (not an error) if an orphan or &#64;ignored node appears as the descendant of an &#64;file node when a .leo file is being saved. If any warnings occur while writing the external file, Leo2 will write the “offending” &#64;file tree to the .leo file instead of the external file. This has several advantages:</p>
<ol class="arabic simple">
<li><p>The user gets warned about orphan nodes. These are useful warnings! Orphan nodes arise from missing &#64;others directives or missing section references.</p></li>
<li><p>The user doesn’t have to change anything immediately in order to save an outline. This is very important. Besides warnings about orphans, Leo2 will also warn about undefined or unreferenced sections. User’s shouldn’t have to fix these warnings to do a Save!</p></li>
<li><p>No errors or alerts will occur during Reading or Writing, so the user’s anxiety level goes way down. At worst, some informational message will be sent to the log. The user will never have to make important decisions during Loads or Saves. [At last the dubious distinction between errors and warnings disappears.]</p></li>
<li><p>Error recovery can be bullet-proof. Simple code will guarantee that after any read operation the structure of an &#64;file node will match the structure of the external file. Also, sentinels in external files will now account for all children of an &#64;file node. There are no more “missing nodes” that must be filled in using the .leo file. Finally, error recovery will never change the &#64;file tree in any way: no more “recovered nodes” nodes.</p></li>
<li><p>The present read code can be used almost unchanged. The only addition is the posting of a warning if the structure of the .leo file does not match the structure of the external file. We need a warning because non-essential attribute of nodes (like user marks) may be altered.”</p></li>
</ol>
<p>This ends the original history of Leo2. In fact, it took quite a while before Leo recovered properly from all errors. I finally saw that .leo files should duplicate all information in external files. This allows a .leo file to be used a single backup file and allows maximal error recovery in all situations. It took several months to stamp out several subtle bugs involving clones that caused spurious read errors. Such errors undermine confidence in Leo and can cause disastrous reversions. See my diary entries for January 2002 in leo.py for details.</p>
</section>
</section>
<section id="untangling-file-is-easy">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">2002: Untangling &#64;file is easy!</a><a class="headerlink" href="#untangling-file-is-easy" title="Permalink to this heading">¶</a></h2>
<p>The biggest surprise in Leo’s history was the realization it is <strong>much</strong> easier to untangle files derived from &#64;file. Indeed, the old tangle code created all sorts of problems that just disappear when using &#64;file. The new Python version of Leo became fully operational in early 2002. It was probably about this time that I chose noweb as Leo’s preferred markup language. My decision not to support noweb’s escape sequences made Leo’s read code much more robust.</p>
</section>
<section id="leo-3-x-continuous-improvement">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">2002: Leo 3.x: Continuous improvement</a><a class="headerlink" href="#leo-3-x-continuous-improvement" title="Permalink to this heading">¶</a></h2>
<p>I spent 2002 taking advantages of Python’s tremendous power and safety. Many improvements were at last easy enough to do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nested</span> <span class="nd">@others</span> <span class="n">directives</span> <span class="n">appeared</span> <span class="ow">in</span> <span class="mf">3.2</span><span class="o">.</span>
<span class="n">Unicode</span> <span class="n">support</span> <span class="n">started</span> <span class="ow">in</span> <span class="mf">3.3</span><span class="o">.</span>
<span class="nd">@first</span> <span class="ow">and</span> <span class="nd">@last</span> <span class="n">appeared</span> <span class="ow">in</span> <span class="mf">3.7</span>
<span class="nd">@asis</span> <span class="ow">and</span> <span class="nd">@nosent</span> <span class="n">appeared</span> <span class="ow">in</span> <span class="mf">3.8</span><span class="o">.</span>
<span class="n">Incremental</span> <span class="n">syntax</span> <span class="n">coloring</span> <span class="ow">and</span> <span class="n">incremental</span> <span class="n">undo</span> <span class="n">appeared</span> <span class="ow">in</span> <span class="mf">3.9</span><span class="o">.</span>
<span class="n">Paul</span> <span class="n">Paterson</span> <span class="n">created</span> <span class="n">Leo</span><span class="s1">&#39;s plugin architecture sometime during this period.</span>
<span class="mf">3.12</span> <span class="n">fixed</span> <span class="n">a</span> <span class="n">huge</span> <span class="n">memory</span> <span class="n">leak</span><span class="o">.</span>
<span class="mf">3.12</span> <span class="n">Final</span><span class="p">,</span> <span class="n">the</span> <span class="n">last</span> <span class="mf">3.</span><span class="n">x</span> <span class="n">version</span><span class="p">,</span> <span class="n">appeared</span> <span class="n">July</span> <span class="mi">17</span><span class="p">,</span> <span class="mf">2003.</span>
</pre></div>
</div>
</section>
<section id="sourceforge-new-energy">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">2003: SourceForge: new energy</a><a class="headerlink" href="#sourceforge-new-energy" title="Permalink to this heading">¶</a></h2>
<p>I registered the Leo project on SourceForge on March 10, 2003. Leo started a new life shortly thereafter. Prior to SourceForge my interest in Leo had been waning.</p>
</section>
<section id="new-read-logic-eliminates-read-errors-eliminated-child-indices">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">2003: 4.0: New read logic eliminates read errors, eliminated child indices</a><a class="headerlink" href="#new-read-logic-eliminates-read-errors-eliminated-child-indices" title="Permalink to this heading">¶</a></h2>
<p>4.0 final: October 17, 2003.</p>
<p>In late 2002 and throughout 2003 I worked on an entirely new file format.</p>
<p>Version 4.0 is a major advance in Leo’s error handling. Using 4.0 is much safer than all previous versions. The new read code makes no changes to the outline until it is known that no read errors have occurred.</p>
<p>This was a time of intense design work trying to improve error recovery scheme used while reading external files. In the summer of 2003 I realized that orphan and &#64;ignore’d nodes must be prohibited in &#64;file trees. With this restriction, Leo could finally recreate &#64;file trees in outlines using <strong>only</strong> the information in external files. This made the read code much more robust, and eliminated all the previous unworkable error recovery schemes. At last Leo was on a completely firm foundation.</p>
<p>Leo’s read code now writes a message to the log pane whenever it sees that the body text in the external file does not match the body text in the outline. These messages do not indicate errors, only that the body text has been changed outside of Leo.</p>
<p>Leo’s read code now warns if any non-empty node is unvisited. This check, and the check that headlines match pretty much guarantees that out-of-sync outlines will generate errors. Thus, there is no need a gnx timestamp in &#64;+leo sentinels!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">Added</span> <span class="n">support</span> <span class="k">for</span> <span class="n">uA</span><span class="s1">&#39;s</span>
<span class="o">-</span> <span class="n">Eliminated</span> <span class="n">child</span> <span class="n">indices</span><span class="p">,</span> <span class="n">extraneous</span> <span class="n">blank</span> <span class="n">lines</span> <span class="ow">and</span> <span class="nd">@body</span> <span class="n">sentinels</span>
<span class="o">-</span> <span class="n">Eliminated</span> <span class="nd">@node</span> <span class="n">sentinels</span>
<span class="o">-</span> <span class="n">New</span> <span class="nd">@nl</span> <span class="ow">and</span> <span class="nd">@nonl</span> <span class="n">sentinels</span>
<span class="o">-</span> <span class="n">Read</span> <span class="n">errors</span> <span class="n">leave</span> <span class="n">the</span> <span class="n">outline</span> <span class="n">completely</span> <span class="n">unchanged</span>
</pre></div>
</div>
</section>
<section id="the-debut-of-gnx-s">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">2004: 4.1: The debut of gnx’s</a><a class="headerlink" href="#the-debut-of-gnx-s" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.1: February 20, 2004.</p>
<p>This release reorganized the code base to support gui’s other than tkinter.</p>
<p>Leo first used gnx’s (global node indices) as a foolproof way of associating nodes in .leo files with nodes in external files. At the time, there was still intense discussions about protecting the logical consistency of outlines. &#64;thin was later to solve all those problems, but nobody knew that then.</p>
</section>
<section id="generators-ua-s-the-end-of-sync-problems-shared-tnodes">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">2004: 4.2: generators, uA’s the end of sync problems, shared tnodes</a><a class="headerlink" href="#generators-ua-s-the-end-of-sync-problems-shared-tnodes" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.2: September 20, 2004.</p>
<p>This is one of the most significant dates in Leo’s history. There were so many significant changes that it is hard to remember what Leo was like before it.</p>
<p>Leo 4.2 eliminated worries about consistency of outlines and external files: Leo recreates all essential information from &#64;thin files, so <em>there is nothing left in the .leo file to get out of sync</em>. Thin external files use gnx’s extensively. This simplifies the file format and makes thin external files more cvs friendly.</p>
<p>Leo 4.2 forms the <strong>great divide</strong> in Leo’s internal data structures. Before 4.2, Leo every node in the outline had its own vnode. This was a big performance problem: clone operations had to traverse the entire outline!</p>
<p>4.2 represents clones by sharing subtrees. Kent Tenney and Bernhard Mulder made absolutely crucial contributions. Kent pointed out that it is a tnode, not a vnode that must form the root of the shared data. Bernhard showed that iterators avoid creating huge numbers of positions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">debut</span> <span class="n">of</span> <span class="nd">@all</span><span class="p">,</span> <span class="nd">@test</span> <span class="ow">and</span> <span class="nd">@suite</span>
<span class="n">The</span> <span class="n">mod_scripting</span> <span class="n">plugin</span> <span class="n">creates</span> <span class="n">script</span> <span class="n">buttons</span>
<span class="n">A</span> <span class="n">much</span> <span class="n">faster</span> <span class="ow">and</span> <span class="n">more</span> <span class="n">robust</span> <span class="n">spell</span> <span class="n">checker</span> <span class="n">plugin</span>
<span class="n">Leo</span> <span class="n">saves</span> <span class="n">t</span><span class="o">.</span><span class="n">unknownAttributes</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">root</span> <span class="n">nodes</span> <span class="n">of</span> <span class="nd">@thin</span> <span class="n">trees</span>
<span class="n">New</span> <span class="n">iterators</span>
</pre></div>
</div>
</section>
<section id="settings-trees-plugins-manager-predefined-c-g-p">
<h2><a class="toc-backref" href="#id23" role="doc-backlink">2005: 4.3: &#64;settings trees, plugins manager, predefined c, g, p</a><a class="headerlink" href="#settings-trees-plugins-manager-predefined-c-g-p" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.3: May 23, 2005. Leo 4.3.3: September 17, 2005.</p>
<p>Leo 4.3 introduced settings files. These files replaced config.txt and made settings completely extensible and flexible. This release also introduced the ill-fated settings pane. It was soon retired because it inhibited development.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Leo</span> <span class="n">stores</span> <span class="n">recent</span> <span class="n">files</span> <span class="ow">in</span> <span class="o">.</span><span class="n">leoRecentFiles</span><span class="o">.</span><span class="n">txt</span> <span class="n">files</span>
<span class="n">Added</span> <span class="n">PluginsManager</span> <span class="n">plugin</span>
<span class="n">Support</span> <span class="k">for</span> <span class="n">extensions</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">leo</span><span class="o">/</span><span class="n">extensions</span> <span class="n">directory</span>
<span class="n">Leo</span> <span class="n">predefines</span> <span class="n">c</span><span class="p">,</span> <span class="n">g</span> <span class="ow">and</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">scripts</span> <span class="ow">and</span> <span class="nd">@test</span> <span class="n">nodes</span>
</pre></div>
</div>
<p>Leo 4.3.3:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Added</span> <span class="n">the</span> <span class="n">rst3</span> <span class="n">plugin</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="the-minibuffer-key-bindings-autocompletion-multiple-log-panes">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">2006: 4.4: The minibuffer, key bindings autocompletion, multiple log panes</a><a class="headerlink" href="#the-minibuffer-key-bindings-autocompletion-multiple-log-panes" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.4: May 11, 2006.</p>
<p>Leo 4.4 completed a year-long effort to incorporate an Emacs-style minibuffer and related commands into Leo. Leo 4.4 also featured many improvements in how keys are bound to commands, including per-pane bindings and user-defined key-binding modes. These features allow users to emulate Emacs, Vim, or any other editor. They also make it easy to use Leo without a mouse.</p>
<p>This release created many Emacs-like commands, including cursor and screen movement, basic character, word and paragraph manipulation, and commands to manipulate buffers, the kill ring, regions and rectangles. Much of the work started with a prototype by LeoUser (B.H).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">tabbed</span> <span class="n">log</span> <span class="n">pane</span>
<span class="n">Autocompletion</span> <span class="ow">and</span> <span class="n">calltips</span>
<span class="nd">@mode</span> <span class="n">nodes</span>
<span class="n">The</span> <span class="o">**</span><span class="n">New</span> <span class="n">World</span> <span class="n">Order</span><span class="o">**</span><span class="p">:</span> <span class="n">drawing</span> <span class="n">happens</span> <span class="n">immediately</span><span class="p">,</span> <span class="ow">not</span> <span class="n">at</span> <span class="n">idle</span> <span class="n">time</span>
<span class="n">The</span> <span class="o">**</span><span class="n">Newer</span> <span class="n">World</span> <span class="n">Order</span><span class="o">**</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">endUpdate</span> <span class="ow">is</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="n">c</span><span class="o">.</span><span class="n">redraw_now</span>
</pre></div>
</div>
<p>Development on long-delayed projects accelerated after 4.4 final went out the door:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Syntax</span> <span class="n">coloring</span> <span class="n">controlled</span> <span class="n">using</span> <span class="n">jEdit</span><span class="s1">&#39;s xml language-description files</span>
<span class="n">Support</span> <span class="k">for</span> <span class="n">debugging</span> <span class="n">scripts</span> <span class="n">using</span> <span class="n">external</span> <span class="n">debuggers</span>
<span class="n">Leo</span><span class="s1">&#39;s vnodes and tnodes can support ZODB</span>
<span class="n">Using</span> <span class="n">pymacs</span> <span class="n">to</span> <span class="n">write</span> <span class="n">Leo</span> <span class="n">scripts</span> <span class="n">within</span> <span class="n">Emacs</span>
<span class="n">Added</span> <span class="n">the</span> <span class="n">leoBridge</span> <span class="n">module</span>
</pre></div>
</div>
</section>
<section id="x-hundreds-of-improvements">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">2006-2008: 4.4.x: Hundreds of improvements</a><a class="headerlink" href="#x-hundreds-of-improvements" title="Permalink to this heading">¶</a></h2>
<p>This series of releases featured hundreds of improvements.</p>
<p>Leo 4.4.1: August 30, 2006:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Added</span> <span class="n">new</span> <span class="n">colorizer</span> <span class="n">plugin</span> <span class="n">controlled</span> <span class="n">by</span> <span class="n">jEdit</span> <span class="n">language</span> <span class="n">description</span> <span class="n">files</span>
<span class="n">Added</span> <span class="n">the</span> <span class="n">shadow</span> <span class="n">files</span> <span class="n">plugin</span><span class="p">,</span> <span class="n">a</span> <span class="n">precursor</span> <span class="n">to</span> <span class="nd">@shadow</span>
<span class="n">Added</span> <span class="n">support</span> <span class="k">for</span> <span class="n">multiple</span> <span class="n">editors</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">pane</span>
</pre></div>
</div>
<p>Leo 4.4.2.1: October 29, 2006:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Added</span> <span class="n">leoPymacs</span> <span class="n">module</span><span class="p">,</span> <span class="n">a</span> <span class="n">bridge</span> <span class="n">to</span> <span class="n">Emacs</span><span class="o">.</span>
</pre></div>
</div>
<p>Leo 4.4.3: June 26, 2006. Leo 4.4.3.1: July 3, 2006.</p>
<p>The <strong>big reorg</strong> made the vnode and tnode classes completely independent of the rest of Leo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Added</span> <span class="n">chapters</span>
<span class="n">Added</span> <span class="n">zipped</span> <span class="o">.</span><span class="n">leo</span> <span class="n">files</span>
<span class="n">Added</span> <span class="n">a</span> <span class="n">leoBridge</span> <span class="n">module</span>
<span class="n">Added</span> <span class="n">spell</span> <span class="n">checking</span> <span class="k">with</span> <span class="n">aspell</span>
</pre></div>
</div>
<p>Leo 4.4.4: November 2, 2007:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Added</span> <span class="nd">@auto</span>
<span class="n">Added</span> <span class="nd">@menus</span> <span class="n">trees</span>
<span class="n">Added</span> <span class="nd">@buttons</span> <span class="n">trees</span>
</pre></div>
</div>
<p>Leo 4.4.7: February 18, 2008:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Added</span> <span class="n">ipython</span> <span class="n">plugin</span><span class="p">,</span> <span class="n">a</span> <span class="n">collaboration</span> <span class="n">between</span> <span class="n">EKR</span> <span class="ow">and</span> <span class="n">Ville</span> <span class="n">M</span><span class="o">.</span> <span class="n">Vainio</span><span class="o">.</span>
</pre></div>
</div>
<p>Leo 4.4.8: April 6, 2008:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Leo</span><span class="s1">&#39;s discussion is now hosted by Google Groups</span>
</pre></div>
</div>
</section>
<section id="qt-gui-edit-auto-rst">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">2009: 4.6: Qt gui, &#64;edit, &#64;auto-rst</a><a class="headerlink" href="#qt-gui-edit-auto-rst" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.6: July 15, 2009. Leo 4.6.1:  July 30, 2009:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Leo</span> <span class="n">used</span> <span class="n">Qt</span> <span class="n">interface</span> <span class="n">by</span> <span class="n">default</span><span class="o">.</span>
<span class="n">Added</span> <span class="nd">@auto</span><span class="o">-</span><span class="n">rst</span> <span class="ow">and</span> <span class="nd">@edit</span>
</pre></div>
</div>
</section>
<section id="the-one-node-world-python-3k">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">2010: 4.7: The one node world &amp; Python 3k</a><a class="headerlink" href="#the-one-node-world-python-3k" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.7: February 23, 2010. Leo 4.7.1: February 26, 2010.</p>
<p>Leo 4.7 accomplishes something I long thought to be impossible: the unification of vnodes and tnodes. tnodes no longer exist: vnodes contain all data. The Aha that made this possible is that iterators and positions allow a single node to appear in more than one place in a tree traversal.</p>
<p>This was one of the most significant developments in Leo’s history. At last the endless confusion between vnodes and tnodes is gone. At the most fundamental level, Leo’s data structures are as simple as possible. This makes them as general and as powerful as possible!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">single</span> <span class="n">code</span> <span class="n">base</span> <span class="n">runs</span> <span class="n">on</span> <span class="n">both</span> <span class="n">Python</span> <span class="mi">2</span> <span class="ow">and</span> <span class="mi">3</span>
<span class="n">Automatically</span> <span class="n">converts</span> <span class="kn">from</span> <span class="nn">old</span><span class="o">-</span><span class="n">style</span> <span class="n">to</span> <span class="n">new</span><span class="o">-</span><span class="n">style</span> <span class="n">sentinels</span>
</pre></div>
</div>
</section>
<section id="new-sentinels-recovery-nodes">
<h2><a class="toc-backref" href="#id28" role="doc-backlink">2010: 4.8: New sentinels &amp; recovery nodes</a><a class="headerlink" href="#new-sentinels-recovery-nodes" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.8: November 26, 2010.</p>
<p>This release simplified Leo’s sentinels as much as possible. This version also added “Resurrected” and “Recovered” nodes. These nodes protect against data loss, and also implicitly warn when unusual data-changing events occur. Creating this scheme was yet another chapter in the epic saga of error recovery in Leo.</p>
</section>
<section id="the-end-of-tk-autocompleter-vr-pane">
<h2><a class="toc-backref" href="#id29" role="doc-backlink">2011: 4.9: The end of Tk, autocompleter, vr pane</a><a class="headerlink" href="#the-end-of-tk-autocompleter-vr-pane" title="Permalink to this heading">¶</a></h2>
<p>Leo 4.9: June 21, 2011:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Use</span> <span class="n">the</span> <span class="n">Qt</span> <span class="n">gui</span>
<span class="n">Completed</span> <span class="n">the</span> <span class="n">Autocompleter</span>
<span class="n">The</span> <span class="n">rendering</span> <span class="n">pane</span> <span class="n">can</span> <span class="n">now</span> <span class="n">display</span> <span class="n">movies</span><span class="p">,</span> <span class="n">html</span><span class="p">,</span> <span class="n">svg</span> <span class="n">images</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="vim-mode-plays-well-with-others">
<h2><a class="toc-backref" href="#id30" role="doc-backlink">2014: 5.0 Vim mode, plays well with others</a><a class="headerlink" href="#vim-mode-plays-well-with-others" title="Permalink to this heading">¶</a></h2>
<p>Leo 5.0: November 24, 2014.</p>
<p>Leo now stores “ephemeral” or position-related data <em>in vnodes</em>. This was a completely new idea in Leo’s history!</p>
</section>
<section id="clean">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">2015: 5.1 &#64;clean</a><a class="headerlink" href="#clean" title="Permalink to this heading">¶</a></h2>
<p>Leo 5.1: April 16, 2015.</p>
<p>This release added &#64;clean, one of the most important developments in Leo’s history.
The Mulder/Ream update algorithm puts &#64;clean on a completely sound footing.</p>
</section>
<section id="through-5-9-precursors-to-leointeg">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">2016-2018: 5.2 through 5.9: precursors to leoInteg</a><a class="headerlink" href="#through-5-9-precursors-to-leointeg" title="Permalink to this heading">¶</a></h2>
<p>This “fallow” period prepared contained important performance improvements and paved the way for leoInteg.</p>
<p>Leo 5.4: October 22, 2016. The clone-find commands.</p>
<p>Leo 5.5: March 23, 2017. A bug fix made syntax coloring 20x faster!</p>
<p>Leo 5.6: September 25, 2017.</p>
<ul class="simple">
<li><p>Added the git-diff command.</p></li>
<li><p>Added the cursesGui2.py plugin. This plugin contained the p_to_ap and
ap_to_p functions that became crucial parts of leoInteg.</p></li>
</ul>
<p>Leo 5.8: October 1, 2018. Replace caching with Vitalije’s super-fast new read code.</p>
<p>Leo 5.9: May 1, 2019. Add LeoWapp: Leo in a browser.</p>
</section>
<section id="leo-6-0-and-beyond-supporting-leointeg">
<h2><a class="toc-backref" href="#id33" role="doc-backlink">2019-2023: Leo 6.0 and beyond: supporting leoInteg</a><a class="headerlink" href="#leo-6-0-and-beyond-supporting-leointeg" title="Permalink to this heading">¶</a></h2>
<p>August, 2020: edreamleo’s first PR. Iirc, Félix encouraged me to use PRs for all significant code changes.</p>
<p>Leo 6.1: November 8, 2019. This release contained the dawn of leoInteg: integration of Leo with VS code. leoInteg and leoJS are the future of Leo. All later releases contain support for leoInteg and leoJS.</p>
<p>6.2: March 27, 2020. The rise of f-strings in Leo.</p>
<p>6.3: November 6, 2020. leoAst.py.</p>
<p>6.5: October 22, 2021. Replace &#64;test/&#64;suite with leoTest2.py.</p>
<p>6.7.0: September 26, 2022. Fully annotate Leo’s core files and important plugins.</p>
<p>6.7.4: August 17, 2023. A spectacular collapse in the importer architecture. The Aha! Use <strong>guide lines</strong> to make parsing incoming lines easier.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="leo_toc.html">
              <img class="logo" src="_static/LeoLogo.svg" alt="Logo"/>
            </a></p>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="screencasts.html"
                          title="previous chapter">Videos about Leo</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="glossary.html"
                          title="next chapter">Glossary</a></p>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="glossary.html" title="Glossary"
             >next</a> |</li>
        <li class="right" >
          <a href="screencasts.html" title="Videos about Leo"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="leo_toc.html">Leo 6.7.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="toc-more-links.html" >More Leo Links</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">History of Leo</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1997-2023, Edward K. Ream.
      Last updated on September 08, 2023.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  </body>
</html>