from leo.core.leoColor import leo_color_database as leo_color_database
from leo.core.leoQt import Qsci as Qsci, QtGui as QtGui, QtWidgets as QtWidgets, isQt6 as isQt6
from typing import Any, Callable, Dict

def make_colorizer(c, widget, wrapper): ...

class BaseColorizer:
    c: Any
    widget: Any
    wrapper: Any
    enabled: bool
    highlighter: Any
    language: str
    showInvisibles: bool
    count: int
    full_recolor_count: int
    recolorCount: int
    matcher_name: str
    delegate_name: str
    def __init__(self, c, widget: Any | None = ..., wrapper: Any | None = ...) -> None: ...
    def init(self, p) -> None: ...
    def updateSyntaxColorer(self, p) -> None: ...
    def scanLanguageDirectives(self, p, use_default: bool = ...): ...
    def useSyntaxColoring(self, p): ...
    color_directives_pat: Any
    def findColorDirectives(self, p): ...

class BaseJEditColorizer(BaseColorizer):
    def addImportedRules(self, mode, rulesDict, rulesetName) -> None: ...
    def addLeoRules(self, theDict) -> None: ...
    def configure_hard_tab_width(self, font) -> None: ...
    def configure_tags(self) -> None: ...
    def configure_colors(self) -> None: ...
    def configure_fonts(self) -> None: ...
    zoom_dict: Dict[str, int]
    def find_font(self, key, setting_name): ...
    def configure_variable_tags(self) -> None: ...
    default_colors_dict: Any
    def defineDefaultColorsDict(self) -> None: ...
    default_font_dict: Any
    def defineDefaultFontDict(self) -> None: ...
    leoKeywordsDict: Any
    def defineLeoKeywordsDict(self) -> None: ...
    def getFontFromParams(self, family, size, slant, weight, defaultSize: int = ...) -> None: ...
    language: Any
    def init_mode(self, name): ...
    rulesetName: Any
    properties: Any
    keywordsDict: Any
    attributesDict: Any
    rulesDict: Any
    defaultColor: str
    mode: Any
    def init_mode_from_module(self, name, mode): ...
    def nameToRulesetName(self, name): ...
    word_chars: Any
    def setKeywords(self) -> None: ...
    def setModeAttributes(self) -> None: ...
    modeBunch: Any
    def initModeFromBunch(self, bunch) -> None: ...
    def updateDelimsTables(self) -> None: ...
    actualColorDict: Any
    hyperCount: int
    default: str
    digit_re: str
    escape: str
    highlight_digits: bool
    ignore_case: bool
    no_word_sep: str
    allow_mark_prev: bool
    n_setTag: int
    tagCount: int
    trace_leo_matches: bool
    trace_match_flag: bool
    recolorCount: int
    stateCount: int
    totalStates: int
    maxStateNumber: int
    totalKeywordsCalls: int
    totalLeoKeywordsCalls: int
    defaultRulesList: Any
    importedRulesets: Any
    initLanguage: Any
    prev: Any
    fonts: Any
    keywords: Any
    modes: Any
    modeStack: Any
    tags: Any
    def init_style_ivars(self) -> None: ...
    def munge(self, s): ...
    color_tags_list: Any
    showInvisibles: Any
    underline_undefined: Any
    use_hyperlinks: Any
    use_pygments: Any
    use_pygments_styles: Any
    bold_font: Any
    italic_font: Any
    bolditalic_font: Any
    def reloadSettings(self) -> None: ...
    prev_use_pygments: Any
    prev_use_styles: Any
    prev_style: Any
    def report_changes(self) -> None: ...
    last_v: Any
    def setTag(self, tag, s, i, j) -> None: ...

class JEditColorizer(BaseJEditColorizer):
    highlighter: Any
    after_doc_language: Any
    initialStateNumber: int
    old_v: Any
    nextState: int
    n2languageDict: Any
    restartDict: Any
    stateDict: Any
    stateNameDict: Any
    def __init__(self, c, widget, wrapper) -> None: ...
    prev: Any
    def init(self, p: Any | None = ...) -> None: ...
    def init_all_state(self, v) -> None: ...
    def reloadSettings(self) -> None: ...
    def dump(self, s): ...
    def match_at_color(self, s, i): ...
    def restartColor(self, s): ...
    def match_at_killcolor(self, s, i): ...
    def restartKillColor(self, s): ...
    def match_at_language(self, s, i): ...
    def match_at_nocolor(self, s, i): ...
    def restartNoColor(self, s): ...
    def match_at_nocolor_node(self, s, i): ...
    def restartNoColorNode(self, s): ...
    def match_at_wrap(self, s, i): ...
    def match_blanks(self, s, i): ...
    language: str
    def match_doc_part(self, s, i): ...
    def restartDocPart(self, s): ...
    image_url: Any
    image_src: Any
    def match_image(self, s, i): ...
    def match_leo_keywords(self, s, i): ...
    def match_section_ref(self, s, i): ...
    def match_tabs(self, s, i): ...
    def match_trailing_ws(self, s, i): ...
    def match_unl(self, s, i): ...
    url_regex_f: Any
    url_regex_g: Any
    url_regex_h: Any
    url_regex_m: Any
    url_regex_n: Any
    url_regex_p: Any
    url_regex_t: Any
    url_regex_w: Any
    kinds: str
    url_regex: Any
    def match_any_url(self, s, i): ...
    def match_url_f(self, s, i): ...
    def match_url_g(self, s, i): ...
    def match_url_h(self, s, i): ...
    def match_url_m(self, s, i): ...
    def match_url_n(self, s, i): ...
    def match_url_p(self, s, i): ...
    def match_url_t(self, s, i): ...
    def match_url_w(self, s, i): ...
    def match_compiled_regexp(self, s, i, kind, regexp, delegate: str = ...): ...
    match_obj: Any
    def match_compiled_regexp_helper(self, s, i, regex): ...
    def match_eol_span(self, s, i, kind: Any | None = ..., seq: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., delegate: str = ..., exclude_match: bool = ...): ...
    def match_eol_span_regexp(self, s, i, kind: str = ..., regexp: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., delegate: str = ..., exclude_match: bool = ...): ...
    def match_keywords(self, s, i): ...
    def match_line(self, s, i, kind: Any | None = ..., delegate: str = ..., exclude_match: bool = ...): ...
    def match_lua_literal(self, s, i, kind): ...
    def match_mark_following(self, s, i, kind: str = ..., pattern: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., exclude_match: bool = ...): ...
    def getNextToken(self, s, i): ...
    def match_mark_previous(self, s, i, kind: str = ..., pattern: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., exclude_match: bool = ...): ...
    def match_regexp_helper(self, s, i, pattern): ...
    def match_seq(self, s, i, kind: str = ..., seq: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., delegate: str = ...): ...
    def match_seq_regexp(self, s, i, kind: str = ..., regexp: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., delegate: str = ...): ...
    def match_span(self, s, i, kind: str = ..., begin: str = ..., end: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., delegate: str = ..., exclude_match: bool = ..., no_escape: bool = ..., no_line_break: bool = ..., no_word_break: bool = ...): ...
    def match_span_helper(self, s, i, pattern, no_escape, no_line_break, no_word_break): ...
    matcher_name: Any
    def restart_match_span(self, s, delegate, end, exclude_match, kind, no_escape, no_line_break, no_word_break): ...
    def match_span_regexp(self, s, i, kind: str = ..., begin: str = ..., end: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., delegate: str = ..., exclude_match: bool = ..., no_escape: bool = ..., no_line_break: bool = ..., no_word_break: bool = ...): ...
    ascii_letters: Any
    def match_tex_backslash(self, s, i, kind): ...
    def match_wiki_pattern(self, s, i, pattern): ...
    def match_word_and_regexp(self, s, i, kind1: str = ..., word: str = ..., kind2: str = ..., pattern: str = ..., at_line_start: bool = ..., at_whitespace_end: bool = ..., at_word_start: bool = ..., exclude_match: bool = ...): ...
    def skip_line(self, s, i): ...
    def trace_match(self, kind, s, i, j) -> None: ...
    def clearState(self): ...
    def computeState(self, f, keys): ...
    def currentBlockNumber(self): ...
    def currentState(self): ...
    def prevState(self): ...
    def setState(self, n): ...
    def inColorState(self): ...
    def setRestart(self, f, **keys): ...
    def showState(self, n): ...
    def showCurrentState(self): ...
    def showPrevState(self): ...
    def stateNameToStateNumber(self, f, stateName): ...
    delegate_name: Any
    def colorRangeWithTag(self, s, i, j, tag, delegate: str = ..., exclude_match: bool = ...) -> None: ...
    tot_time: float
    last_v: Any
    def mainLoop(self, n, s) -> None: ...
    def recolor(self, s) -> None: ...
    def initBlock0(self): ...
    blankStateNumber: Any
    def setInitialStateNumber(self): ...
    def languageTag(self, name): ...
    rulesDict: Any
    def set_wikiview_patterns(self, leadins, patterns): ...

class LeoHighlighter(QtGui.QSyntaxHighlighter):
    c: Any
    colorizer: Any
    n_calls: int
    leo_document: Any
    def __init__(self, c, colorizer, document) -> None: ...
    def highlightBlock(self, s) -> None: ...
    def reloadSettings(self) -> None: ...
    key_error_d: Dict[str, bool]
    def setStyle(self, style) -> None: ...

class NullScintillaLexer(Qsci.QsciLexerCustom):
    leo_c: Any
    def __init__(self, c, parent: Any | None = ...) -> None: ...
    def description(self, style): ...
    def setStyling(self, length, style) -> None: ...
    def styleText(self, start, end) -> None: ...
    def configure_lexer(self) -> None: ...

class PygmentsColorizer(BaseJEditColorizer):
    highlighter: Any
    color_enabled: Any
    old_v: Any
    def __init__(self, c, widget, wrapper) -> None: ...
    prev: Any
    def init(self, p: Any | None = ...) -> None: ...
    def addLeoRules(self, theDict) -> None: ...
    getDefaultFormat: Any
    getFormat: Any
    setFormat: Any
    def reloadSettings(self) -> None: ...
    def getLegacyDefaultFormat(self) -> None: ...
    traced_dict: Dict[str, str]
    def getLegacyFormat(self, token, text): ...
    def getPygmentsFormat(self, token, text): ...
    def setLegacyFormat(self, index, length, format, s) -> None: ...
    def setPygmentsFormat(self, index, length, format, s) -> None: ...
    format_dict: Dict[str, str]
    lexers_dict: Dict[str, Callable]
    state_s_dict: Dict[str, int]
    state_n_dict: Dict[int, str]
    state_index: int
    tot_time: float
    language: Any
    def mainLoop(self, s) -> None: ...
    def at_color_callback(self, lexer, match) -> None: ...
    def at_language_callback(self, lexer, match) -> None: ...
    def get_lexer(self, language): ...
    def patch_lexer(self, language, lexer): ...
    def section_ref_callback(self, lexer, match) -> None: ...
    def set_lexer(self): ...
    def recolor(self, s) -> None: ...

class QScintillaColorizer(BaseColorizer):
    count: int
    colorCacheFlag: bool
    error: bool
    flag: bool
    full_recolor_count: int
    language: str
    highlighter: Any
    lexer: Any
    lexersDict: Any
    nullLexer: Any
    def __init__(self, c, widget, wrapper) -> None: ...
    enabled: Any
    def reloadSettings(self) -> None: ...
    def scanColorDirectives(self, p): ...
    def changeLexer(self, language) -> None: ...
    def colorize(self, p) -> None: ...
    def configure_lexer(self, lexer) -> None: ...
    def init(self, p) -> None: ...
    def makeLexersDict(self): ...

def get_tokens_unprocessed(self, text, stack=...) -> None: ...

class PygmentsBlockUserData(QtGui.QTextBlockUserData):
    syntax_stack: Any
    def __init__(self, **kwds) -> None: ...
