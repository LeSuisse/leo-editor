import io
import unittest
from typing import Any, Callable, Dict, List, Optional, Set

StringIO = io.StringIO
in_bridge: bool
minimum_python_version: str
isPython3: Any
isMac: Any
isWindows: Any
globalDirectiveList: Any
directives_pat: Any
global_commands_dict: Any
cmd_instance_dict: Any

def callback(func): ...
def check_cmd_instance_dict(c, g) -> None: ...

class Command:
    name: Any
    def __init__(self, name, **kwargs) -> None: ...
    def __call__(self, func): ...
command = Command

def command_alias(alias, func) -> None: ...

class CommanderCommand:
    name: Any
    def __init__(self, name, **kwargs) -> None: ...
    def __call__(self, func): ...
commander_command = CommanderCommand

def ivars2instance(c, g, ivars): ...
def new_cmd_decorator(name, ivars): ...

g_language_pat: Any
g_is_directive_pattern: Any
g_noweb_root: Any
g_pos_pattern: Any
g_tabwidth_pat: Any
tree_popup_handlers: List[Callable]
user_dict: Dict[Any, Any]
app: Any
inScript: bool
unitTesting: bool

def standard_timestamp(): ...
def get_backup_path(sub_directory): ...

class BindingInfo:
    kind: Any
    commandName: Any
    func: Any
    nextMode: Any
    pane: Any
    stroke: Any
    def __init__(self, kind, commandName: str = ..., func: Any | None = ..., nextMode: Any | None = ..., pane: Any | None = ..., stroke: Any | None = ...) -> None: ...
    def __hash__(self): ...
    def dump(self): ...
    def isModeBinding(self): ...

def isBindingInfo(obj): ...

class Bunch:
    def __init__(self, **keywords) -> None: ...
    def ivars(self): ...
    def keys(self): ...
    def toString(self): ...
    def __setitem__(self, key, value): ...
    def __getitem__(self, key): ...
    def get(self, key, theDefault: Any | None = ...): ...
    def __contains__(self, key): ...
bunch = Bunch

class EmergencyDialog:
    answer: Any
    title: Any
    message: Any
    buttonsFrame: Any
    defaultButtonCommand: Any
    frame: Any
    root: Any
    top: Any
    def __init__(self, title, message) -> None: ...
    def createButtons(self, buttons): ...
    def createTopFrame(self) -> None: ...
    def okButton(self) -> None: ...
    def onKey(self, event) -> None: ...
    def run(self) -> None: ...

class FileLikeObject:
    encoding: Any
    list: Any
    ptr: int
    def __init__(self, encoding: str = ..., fromString: Any | None = ...) -> None: ...
    def clear(self) -> None: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    def get(self): ...
    getvalue: Any
    read: Any
    def readline(self): ...
    def write(self, s) -> None: ...
fileLikeObject = FileLikeObject

class GeneralSetting:
    encoding: Any
    ivar: Any
    kind: Any
    path: Any
    unl: Any
    setting: Any
    val: Any
    tag: Any
    def __init__(self, kind, encoding: Any | None = ..., ivar: Any | None = ..., setting: Any | None = ..., val: Any | None = ..., path: Any | None = ..., tag: str = ..., unl: Any | None = ...) -> None: ...
    dump: Any

class KeyStroke:
    s: Any
    def __init__(self, binding) -> None: ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __ne__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __hash__(self): ...
    def dump(self) -> None: ...
    mods: Any
    def finalize_binding(self, binding): ...
    def finalize_char(self, s): ...
    def strip_shift(self, s): ...
    def find(self, pattern): ...
    def lower(self): ...
    def startswith(self, s): ...
    def find_mods(self, s): ...
    def isAltCtrl(self): ...
    def isFKey(self): ...
    def isPlainKey(self): ...
    def isNumPadKey(self): ...
    def isPlainNumPad(self): ...
    def removeNumPadModifier(self) -> None: ...
    def prettyPrint(self): ...
    def strip_mods(self, s): ...
    def toGuiChar(self): ...
    def toInsertableChar(self): ...

def isStroke(obj): ...
def isStrokeOrNone(obj): ...

class MatchBrackets:
    c: Any
    p: Any
    language: Any
    close_brackets: str
    open_brackets: str
    brackets: Any
    matching_brackets: Any
    def __init__(self, c, p, language) -> None: ...
    def is_regex(self, s, i): ...
    def scan_regex(self, s, i): ...
    def scan_string(self, s, i): ...
    def expand_range(self, s, left, right, max_right, expand: bool = ...): ...
    forward: Any
    def find_matching_bracket(self, ch1, s, i): ...
    def scan(self, ch1, target, s, i): ...
    def scan_comment(self, s, i): ...
    def starts_comment(self, s, i): ...
    def scan_back(self, ch1, target, s, i): ...
    def back_scan_comment(self, s, i): ...
    def ends_comment(self, s, i): ...
    def oops(self, s) -> None: ...
    def run(self) -> None: ...

class PosList(list):
    c: Any
    def __init__(self, c, aList: Any | None = ...) -> None: ...
    def dump(self, sort: bool = ..., verbose: bool = ...): ...
    def select(self, pat, regex: bool = ..., removeClones: bool = ...): ...
    def removeClones(self, aList): ...

class ReadLinesClass:
    lines: Any
    i: int
    def __init__(self, s) -> None: ...
    def next(self): ...
    __next__: Any

class RedirectClass:
    old: Any
    encoding: str
    def __init__(self) -> None: ...
    def isRedirected(self): ...
    def flush(self, *args) -> None: ...
    def rawPrint(self, s) -> None: ...
    def redirect(self, stdout: int = ...) -> None: ...
    def undirect(self, stdout: int = ...) -> None: ...
    def write(self, s) -> None: ...

redirectStdErrObj: Any
redirectStdOutObj: Any

def redirectStderr() -> None: ...
def redirectStdout() -> None: ...
def restoreStderr() -> None: ...
def restoreStdout() -> None: ...
def stdErrIsRedirected(): ...
def stdOutIsRedirected(): ...
def rawPrint(s) -> None: ...

class SherlockTracer:
    bad_patterns: Any
    dots: Any
    contents_d: Any
    n: int
    stats: Any
    patterns: Any
    pattern_stack: Any
    show_args: Any
    show_return: Any
    trace_lines: bool
    verbose: Any
    def __init__(self, patterns, dots: bool = ..., show_args: bool = ..., show_return: bool = ..., verbose: bool = ...) -> None: ...
    def __call__(self, frame, event, arg): ...
    def bad_pattern(self, pattern) -> None: ...
    def check_pattern(self, pattern): ...
    def dispatch(self, frame, event, arg): ...
    def do_call(self, frame, unused_arg) -> None: ...
    def get_args(self, frame): ...
    bad_fns: List[str]
    def do_line(self, frame, arg) -> None: ...
    def do_return(self, frame, arg) -> None: ...
    def format_ret(self, arg): ...
    def fn_is_enabled(self, func, patterns): ...
    def get_full_name(self, locals_, name): ...
    ignored_files: List[str]
    ignored_functions: List[str]
    def is_enabled(self, file_name, function_name, patterns: Any | None = ...): ...
    def print_stats(self, patterns: Any | None = ...) -> None: ...
    def run(self, frame: Any | None = ...) -> None: ...
    def push(self, patterns) -> None: ...
    def pop(self) -> None: ...
    def set_patterns(self, patterns) -> None: ...
    def show(self, item): ...
    def stop(self) -> None: ...

class TkIDDialog(EmergencyDialog):
    message: str
    title: str
    val: str
    def __init__(self) -> None: ...
    def onKey(self, event) -> None: ...
    root: Any
    top: Any
    frame: Any
    entry: Any
    def createTopFrame(self) -> None: ...
    def okButton(self) -> None: ...

class Tracer:
    callDict: Any
    calledDict: Any
    count: int
    inited: bool
    limit: Any
    stack: Any
    trace: Any
    verbose: Any
    def __init__(self, limit: int = ..., trace: bool = ..., verbose: bool = ...) -> None: ...
    def computeName(self, frame): ...
    def report(self) -> None: ...
    def stop(self) -> None: ...
    def tracer(self, frame, event, arg): ...
    def updateStats(self, name) -> None: ...

def startTracer(limit: int = ..., trace: bool = ..., verbose: bool = ...): ...

tracing_tags: Any
tracing_vars: Any
tracing_signatures: Any

class NullObject:
    def __init__(self, ivars: Any | None = ..., *args, **kwargs) -> None: ...
    def __call__(self, *args, **keys): ...
    def __delattr__(self, attr) -> None: ...
    def __getattr__(self, attr): ...
    def __setattr__(self, attr, val) -> None: ...
    def __bool__(self): ...
    def __contains__(self, item): ...
    def __getitem__(self, key) -> None: ...
    def __setitem__(self, key, val) -> None: ...
    def __iter__(self): ...
    def __len__(self): ...
    def __next__(self) -> None: ...

class TracingNullObject:
    def __init__(self, tag, ivars: Any | None = ..., *args, **kwargs) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def __delattr__(self, attr): ...
    def __getattr__(self, attr): ...
    def __setattr__(self, attr, val) -> None: ...
    def __bool__(self): ...
    def __contains__(self, item): ...
    def __getitem__(self, key) -> None: ...
    def __iter__(self): ...
    def __len__(self): ...
    def __next__(self) -> None: ...
    def __setitem__(self, key, val) -> None: ...

def null_object_print_attr(id_, attr) -> None: ...
def null_object_print(id_, kind, *args) -> None: ...

class TypedDict:
    d: Any
    keyType: Any
    valType: Any
    def __init__(self, name, keyType, valType) -> None: ...
    def __setitem__(self, key, val) -> None: ...
    def add_to_list(self, key, val) -> None: ...
    def copy(self, name: Any | None = ...): ...
    def get(self, key, default: Any | None = ...): ...
    def items(self): ...
    def keys(self): ...
    def values(self): ...
    def get_setting(self, key): ...
    def get_string_setting(self, key): ...
    def name(self): ...
    def setName(self, name) -> None: ...
    def update(self, d) -> None: ...

class UiTypeException(Exception): ...

def assertUi(uitype) -> None: ...

class TestLeoGlobals(unittest.TestCase):
    def test_comment_delims_from_extension(self) -> None: ...
    def test_is_sentinel(self) -> None: ...

def isTextWidget(w): ...
def isTextWrapper(w): ...
def alert(message, c: Any | None = ...) -> None: ...
def assert_is(obj, list_or_class, warn: bool = ...): ...
def callers(n: int = ..., count: int = ..., excludeCaller: bool = ..., verbose: bool = ...): ...
def caller(i: int = ...): ...
def dump(s): ...
def oldDump(s): ...
def dump_encoded_string(encoding, s) -> None: ...
def module_date(mod, format: Any | None = ...): ...
def plugin_date(plugin_mod, format: Any | None = ...): ...
def file_date(theFile, format: Any | None = ...): ...
def get_line(s, i): ...
def get_line_after(s, i): ...
getLineAfter = get_line_after

def getIvarsDict(obj): ...
def checkUnchangedIvars(obj, d, exceptions: Any | None = ...): ...
def pause(s) -> None: ...
def pdb(message: str = ...) -> None: ...
def dictToString(d, indent: str = ..., tag: Any | None = ...): ...
def listToString(obj, indent: str = ..., tag: Any | None = ...): ...
def objToString(obj, indent: str = ..., printCaller: bool = ..., tag: Any | None = ...): ...
toString = objToString

def run_pylint(fn, rc, dots: bool = ..., patterns: Any | None = ..., sherlock: bool = ..., show_return: bool = ..., stats_patterns: Any | None = ..., verbose: bool = ...) -> None: ...
def sleep(n) -> None: ...
def printObj(obj, indent: str = ..., printCaller: bool = ..., tag: Any | None = ...) -> None: ...
printDict = printObj
printList = printObj
printTuple = printObj

def tupleToString(obj, indent: str = ..., tag: Any | None = ...): ...
def clearAllIvars(o) -> None: ...
def enable_gc_debug() -> None: ...
def printGc() -> None: ...

lastObjectCount: int

def printGcObjects(): ...
def printGcRefs() -> None: ...
def printGcSummary() -> None: ...
def printTimes(times) -> None: ...
def clearStats() -> None: ...
def printStats(event: Any | None = ..., name: Any | None = ...) -> None: ...
def stat(name: Any | None = ...) -> None: ...
def getTime(): ...
def esDiffTime(message, start): ...
def printDiffTime(message, start): ...
def timeSince(start): ...
def comment_delims_from_extension(filename): ...
def findAllValidLanguageDirectives(p): ...
def findTabWidthDirectives(c, p): ...
def findFirstValidAtLanguageDirective(p): ...
def findLanguageDirectives(c, p): ...
def findReference(name, root): ...
def get_directives_dict(p, root: Any | None = ...): ...
def get_directives_dict_list(p): ...
def getLanguageFromAncestorAtFileNode(p): ...
def getLanguageAtPosition(c, p): ...
def getOutputNewline(c: Any | None = ..., name: Any | None = ...): ...
def inAtNosearch(p): ...
def isDirective(s): ...
def isValidLanguage(language): ...
def scanAtCommentAndAtLanguageDirectives(aList): ...
def scanAtEncodingDirectives(aList): ...
def scanAtHeaderDirectives(aList) -> None: ...
def scanAtLineendingDirectives(aList): ...
def scanAtPagewidthDirectives(aList, issue_error_flag: bool = ...): ...
def scanAtPathDirectives(c, aList): ...
def scanAllAtPathDirectives(c, p): ...
def scanAtTabwidthDirectives(aList, issue_error_flag: bool = ...): ...
def scanAllAtTabWidthDirectives(c, p): ...
def scanAtWrapDirectives(aList, issue_error_flag: bool = ...): ...
def scanAllAtWrapDirectives(c, p): ...
def scanForAtIgnore(c, p): ...
def scanForAtLanguage(c, p): ...
def scanForAtSettings(p): ...
def set_delims_from_language(language): ...
def set_delims_from_string(s): ...
def set_language(s, i, issue_errors_flag: bool = ...): ...
def stripPathCruft(path): ...
def update_directives_pat() -> None: ...
def chdir(path) -> None: ...
def computeGlobalConfigDir(): ...
def computeHomeDir(): ...
def computeLeoDir(): ...
def computeLoadDir(): ...
def computeMachineName(): ...
def computeStandardDirectories(): ...
def computeWindowTitle(fileName): ...
def create_temp_file(textMode: bool = ...): ...
def createHiddenCommander(fn): ...
def defaultLeoFileExtension(c: Any | None = ...): ...
def ensure_extension(name, ext): ...
def fullPath(c, p, simulate: bool = ...): ...
def get_files_in_directory(directory, kinds: Any | None = ..., recursive: bool = ...): ...
def getBaseDirectory(c): ...
def getEncodingAt(p, s: Any | None = ...): ...
def guessExternalEditor(c: Any | None = ...): ...
def init_dialog_folder(c, p, use_at_path: bool = ...): ...
def is_binary_file(f): ...
def is_binary_external_file(fileName): ...
def is_binary_string(s): ...
def is_sentinel(line, delims): ...
def makeAllNonExistentDirectories(theDir): ...
def makePathRelativeTo(fullPath, basePath): ...
def openWithFileName(fileName, old_c: Any | None = ..., gui: Any | None = ...): ...
def readFileIntoEncodedString(fn, silent: bool = ...): ...
def readFileIntoString(fileName, encoding: str = ..., kind: Any | None = ..., verbose: bool = ...): ...
def readFileIntoUnicodeString(fn, encoding: Any | None = ..., silent: bool = ...): ...
def readlineForceUnixNewline(f, fileName: Any | None = ...): ...
def sanitize_filename(s): ...
def setGlobalOpenDir(fileName) -> None: ...
def shortFileName(fileName, n: Any | None = ...): ...
shortFilename = shortFileName

def splitLongFileName(fn, limit: int = ...): ...
def writeFile(contents, encoding, fileName): ...
def find_word(s, word, i: int = ...): ...
def findRootsWithPredicate(c, root, predicate: Any | None = ...): ...
def recursiveUNLSearch(unlList, c, depth: int = ..., p: Any | None = ..., maxdepth: int = ..., maxp: Any | None = ..., soft_idx: bool = ..., hard_idx: bool = ...): ...
def recursiveUNLFind(unlList, c, depth: int = ..., p: Any | None = ..., maxdepth: int = ..., maxp: Any | None = ..., soft_idx: bool = ..., hard_idx: bool = ...): ...
def recursiveUNLParts(text): ...
def scanError(s) -> None: ...
def scanf(s, pat): ...
def see_more_lines(s, ins, n: int = ...): ...
def splitLines(s): ...
splitlines = splitLines

def joinLines(aList): ...
joinlines = joinLines

def skip_block_comment(s, i): ...
def skip_braces(s, i): ...
def skip_parens(s, i): ...
def skip_pascal_begin_end(s, i): ...
def skip_pascal_block_comment(s, i): ...
def skip_pascal_string(s, i): ...
def skip_heredoc_string(s, i): ...
def skip_pp_directive(s, i): ...
def skip_pp_if(s, i): ...
def skip_pp_part(s, i): ...
def skip_python_string(s, i, verbose: bool = ...): ...
def skip_string(s, i, verbose: bool = ...): ...
def skip_to_semicolon(s, i): ...
def skip_typedef(s, i): ...
def escaped(s, i): ...
def find_line_start(s, i): ...
def find_on_line(s, i, pattern): ...
def is_c_id(ch): ...
def is_nl(s, i): ...
def is_special(s, directive): ...
def is_ws(c): ...
def is_ws_or_nl(s, i): ...
def match(s, i, pattern): ...
def match_c_word(s, i, name): ...
def match_ignoring_case(s1, s2): ...
def match_word(s, i, pattern): ...
def match_words(s, i, patterns): ...
def skip_blank_lines(s, i): ...
def skip_c_id(s, i): ...
def skip_id(s, i, chars: Any | None = ...): ...
def skip_line(s, i): ...
def skip_to_end_of_line(s, i): ...
def skip_to_start_of_line(s, i): ...
def skip_long(s, i): ...
def skip_nl(s, i): ...
def skip_non_ws(s, i): ...
def skip_pascal_braces(s, i): ...
def skip_to_char(s, i, ch): ...
def skip_ws(s, i): ...
def skip_ws_and_nl(s, i): ...
def backupGitIssues(c, base_url: Any | None = ...) -> None: ...
def execGitCommand(command, directory: Any | None = ...): ...
def getGitIssues(c, base_url: Any | None = ..., label_list: Any | None = ..., milestone: Any | None = ..., state: Any | None = ...) -> None: ...

class GitIssueController:
    base_url: Any
    root: Any
    milestone: Any
    def backup_issues(self, base_url, c, label_list, root, state: Any | None = ...) -> None: ...
    def get_all_issues(self, label_list, root, state, limit: int = ...) -> None: ...
    def get_issues(self, base_url, label_list, milestone, root, state) -> None: ...
    def get_one_issue(self, label, state, limit: int = ...) -> None: ...
    def get_one_page(self, label, page, r, root): ...
    def print_header(self, r) -> None: ...

def getGitVersion(directory: Any | None = ...): ...
def gitBranchName(path: Any | None = ...): ...
def gitCommitNumber(path: Any | None = ...): ...
def gitInfoForFile(filename): ...
def gitInfoForOutline(c): ...
def gitDescribe(path: Any | None = ...): ...
def gitHeadPath(path): ...
def gitInfo(path: Any | None = ...): ...
def dummy_act_on_node(c, p, event) -> None: ...
act_on_node = dummy_act_on_node
childrenModifiedSet: Set[bool]
contentModifiedSet: Set[bool]

def doHook(tag, *args, **keywords): ...
def loadOnePlugin(pluginName, verbose: bool = ...): ...
def registerExclusiveHandler(tags, fn): ...
def registerHandler(tags, fn): ...
def plugin_signon(module_name, verbose: bool = ...): ...
def unloadOnePlugin(moduleOrFileName, verbose: bool = ...): ...
def unregisterHandler(tags, fn): ...
def getHandlersForTag(tags): ...
def getLoadedPlugins(): ...
def getPluginModule(moduleName): ...
def pluginIsLoaded(fn): ...
def disableIdleTimeHook() -> None: ...
def enableIdleTimeHook(*args, **keys) -> None: ...
def IdleTime(handler, delay: int = ..., tag: Any | None = ...): ...
def idleTimeHookHandler(timer) -> None: ...
def cantImport(moduleName, pluginName: Any | None = ..., verbose: bool = ...) -> None: ...
def import_module(name, package: Any | None = ...): ...
def convertPythonIndexToRowCol(s, i): ...
def convertRowColToPythonIndex(s, row, col, lines: Any | None = ...): ...
def getWord(s, i): ...
def getLine(s, i): ...
def toPythonIndex(s, index): ...
def flatten_list(obj) -> None: ...
def join_list(aList, indent: str = ..., leading: str = ..., sep: str = ..., trailing: str = ...): ...
def list_to_string(obj): ...
def isascii(s): ...
def angleBrackets(s): ...
virtual_event_name = angleBrackets

def ensureLeadingNewlines(s, n): ...
def ensureTrailingNewlines(s, n): ...
def longestCommonPrefix(s1, s2): ...
def itemsMatchingPrefixInList(s, aList, matchEmptyPrefix: bool = ...): ...
def removeLeading(s, chars): ...
def removeTrailing(s, chars): ...
def stripBrackets(s): ...
def unCamel(s): ...

checkUnicode_dict: Any

def checkUnicode(s, encoding: Any | None = ...): ...
def getPythonEncodingFromString(s): ...
def isBytes(s): ...
def isCallable(obj): ...
def isInt(obj): ...
def isList(s): ...
def isString(s): ...
def isUnicode(s): ...
def isValidEncoding(encoding): ...
def isWordChar(ch): ...
def isWordChar1(ch): ...
def stripBOM(s): ...
def toEncodedString(s, encoding: str = ..., reportErrors: bool = ...): ...

unicode_warnings: Dict[str, bool]

def toUnicode(s: Any, encoding: Optional[str] = ..., reportErrors: bool = ...) -> str: ...
def u(s): ...
def computeLeadingWhitespace(width, tab_width): ...
def computeLeadingWhitespaceWidth(s, tab_width): ...
def computeWidth(s, tab_width): ...
def adjustTripleString(s, tab_width): ...
def removeExtraLws(s, tab_width): ...
def wrap_lines(lines, pageWidth, firstLineWidth: Any | None = ...): ...
def get_leading_ws(s): ...
def optimizeLeadingWhitespace(line, tab_width): ...
def regularizeTrailingNewlines(s, kind) -> None: ...
def removeBlankLines(s): ...
def removeLeadingBlankLines(s): ...
def removeLeadingWhitespace(s, first_ws, tab_width): ...
def removeTrailingWs(s): ...
def skip_leading_ws(s, i, ws, tab_width): ...
def skip_leading_ws_with_indent(s, i, tab_width): ...
def stripBlankLines(s): ...
def doKeywordArgs(keys, d: Any | None = ...): ...
def ecnl(tabName: str = ...) -> None: ...
def ecnls(n, tabName: str = ...) -> None: ...
def enl(tabName: str = ...) -> None: ...
def blue(*args, **keys) -> None: ...
def error(*args, **keys) -> None: ...
def note(*args, **keys) -> None: ...
def red(*args, **keys) -> None: ...
def warning(*args, **keys) -> None: ...
def es(*args, **keys) -> None: ...
log = es

def es_clickable_link(c, p, line_number, message) -> None: ...
def es_debug(*args, **keys) -> None: ...
def es_dump(s, n: int = ..., title: Any | None = ...) -> None: ...
def es_error(*args, **keys) -> None: ...
def es_print_error(*args, **keys) -> None: ...
def es_event_exception(eventName, full: bool = ...) -> None: ...
def es_exception(full: bool = ..., c: Any | None = ..., color: str = ...): ...
def es_exception_type(c: Any | None = ..., color: str = ...) -> None: ...
def es_print(*args, **keys) -> None: ...
def print_exception(full: bool = ..., c: Any | None = ..., flush: bool = ..., color: str = ...): ...
def es_trace(*args, **keys) -> None: ...
def getLastTracebackFileAndLineNumber(): ...
def goto_last_exception(c) -> None: ...
def internalError(*args) -> None: ...
def log_to_file(s, fn: Any | None = ...) -> None: ...
def pr(*args, **keys) -> None: ...
def prettyPrintType(obj): ...
def print_bindings(name, window) -> None: ...
def printEntireTree(c, tag: str = ...) -> None: ...
def printGlobals(message: Any | None = ...) -> None: ...
def printLeoModules(message: Any | None = ...) -> None: ...
def printStack() -> None: ...
def trace(*args, **keys) -> None: ...

console_encoding: Any

def translateArgs(args, d): ...
def translateString(s): ...
tr = translateString

def actualColor(color): ...
def CheckVersion(s1, s2, condition: str = ..., stringCompare: Any | None = ..., delimiter: str = ..., trace: bool = ...): ...
def CheckVersionToInt(s): ...
def choose(cond, a, b): ...
def cls(event: Any | None = ...) -> None: ...
def createScratchCommander(fileName: Any | None = ...) -> None: ...
def funcToMethod(f, theClass, name: Any | None = ...) -> None: ...

init_zodb_import_failed: bool
init_zodb_failed: Dict[str, bool]
init_zodb_db: Dict[str, Any]

def init_zodb(pathToZodbStorage, verbose: bool = ...): ...
def input_(message: str = ..., c: Any | None = ...): ...
def isMacOS(): ...
def issueSecurityWarning(setting) -> None: ...
def makeDict(**keys): ...
def pep8_class_name(s): ...

aList: Any

def plural(obj): ...
def truncate(s, n): ...
def windows(): ...
def glob_glob(pattern): ...
def os_path_abspath(path): ...
def os_path_basename(path): ...
def os_path_dirname(path): ...
def os_path_exists(path): ...

deprecated_messages: Any

def os_path_expandExpression(s, **keys): ...
def os_path_expanduser(path): ...
def os_path_finalize(path): ...
def os_path_finalize_join(*args, **keys): ...
def os_path_getmtime(path): ...
def os_path_getsize(path): ...
def os_path_isabs(path): ...
def os_path_isdir(path): ...
def os_path_isfile(path): ...
def os_path_join(*args, **keys): ...
def os_path_normcase(path): ...
def os_path_normpath(path): ...
def os_path_normslashes(path): ...
def os_path_realpath(path): ...
def os_path_split(path): ...
def os_path_splitext(path): ...
def os_startfile(fname): ...
def createTopologyList(c, root: Any | None = ..., useHeadlines: bool = ...): ...
def getDocString(s): ...
def getDocStringForFunction(func): ...
def python_tokenize(s, line_numbers: bool = ...): ...
def exec_file(path, d, script: Any | None = ...) -> None: ...
def execute_shell_commands(commands, trace: bool = ...) -> None: ...
def execute_shell_commands_with_options(base_dir: Any | None = ..., c: Any | None = ..., command_setting: Any | None = ..., commands: Any | None = ..., path_setting: Any | None = ..., trace: bool = ..., warning: Any | None = ...) -> None: ...
def computeBaseDir(c, base_dir, path_setting, trace: bool = ...): ...
def computeCommands(c, commands, command_setting, trace: bool = ...): ...
def executeFile(filename, options: str = ...): ...
def findNodeAnywhere(c, headline, exact: bool = ...): ...
def findNodeByPath(c, path): ...
def findNodeInChildren(c, p, headline, exact: bool = ...): ...
def findNodeInTree(c, p, headline, exact: bool = ...): ...
def findTopLevelNode(c, headline, exact: bool = ...): ...
def getScript(c, p, useSelectedText: bool = ..., forcePythonSentinels: bool = ..., useSentinels: bool = ...): ...
def composeScript(c, p, s, forcePythonSentinels: bool = ..., useSentinels: bool = ...): ...
def extractExecutableString(c, p, s): ...
def handleScriptException(c, p, script, script1) -> None: ...
def insertCodingLine(encoding, script): ...
def findTestScript(c, h, where: Any | None = ..., warn: bool = ...): ...
def getTestVars(): ...
def run_unit_test_in_separate_process(command) -> None: ...
def toEncodedStringWithErrorCode(s, encoding, reportErrors: bool = ...): ...
def toUnicodeWithErrorCode(s, encoding, reportErrors: bool = ...): ...

unl_regex: Any
kinds: str
url_regex: Any

def unquoteUrl(url): ...
def computeFileUrl(fn, c: Any | None = ..., p: Any | None = ...): ...
def getUrlFromNode(p): ...
def handleUrl(url, c: Any | None = ..., p: Any | None = ...): ...
def handleUrlHelper(url, c, p) -> None: ...
def traceUrl(c, path, parsed, url) -> None: ...
def handleUnl(unl, c): ...
def isValidUrl(url): ...
def openUrl(p) -> None: ...
def openUrlOnClick(event, url: Any | None = ...): ...
def openUrlHelper(event, url: Any | None = ...): ...

g: Any
